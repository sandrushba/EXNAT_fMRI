<?xml version="1.0" ?>
<PsychoPy2experiment encoding="utf-8" version="2024.1.1">
  <Settings>
    <Param val="3" valType="str" updates="None" name="Audio latency priority"/>
    <Param val="ptb" valType="str" updates="None" name="Audio lib"/>
    <Param val="" valType="str" updates="None" name="Completed URL"/>
    <Param val="tab" valType="str" updates="None" name="Data file delimiter"/>
    <Param val="u'Analysis/Data_EXNAT_3_training/%s_%s_%s' % (expInfo['participant'], expName, expInfo['date'])" valType="code" updates="None" name="Data filename"/>
    <Param val="True" valType="bool" updates="None" name="Enable Escape"/>
    <Param val="" valType="str" updates="None" name="End Message"/>
    <Param val="{'participant': 'sub-', 'session': '001', 'testing_mode': 'yes', 'RT_per_rectangle_oneback_single': '', 'RT_per_rectangle_twoback_single': '', 'RT_per_letter_baseline': '', 'RT_per_letter_oneback_dual': '', 'RT_per_letter_twoback_dual': ''}" valType="code" updates="None" name="Experiment info"/>
    <Param val="True" valType="bool" updates="None" name="Force stereo"/>
    <Param val="True" valType="bool" updates="None" name="Full-screen window"/>
    <Param val="" valType="str" updates="None" name="HTML path"/>
    <Param val="" valType="str" updates="None" name="Incomplete URL"/>
    <Param val="testMonitor" valType="str" updates="None" name="Monitor"/>
    <Param val="[]" valType="list" updates="None" name="Resources"/>
    <Param val="False" valType="bool" updates="None" name="Save csv file"/>
    <Param val="False" valType="bool" updates="None" name="Save excel file"/>
    <Param val="False" valType="bool" updates="None" name="Save hdf5 file"/>
    <Param val="True" valType="bool" updates="None" name="Save log file"/>
    <Param val="True" valType="bool" updates="None" name="Save psydat file"/>
    <Param val="True" valType="bool" updates="None" name="Save wide csv file"/>
    <Param val="1" valType="num" updates="None" name="Screen"/>
    <Param val="True" valType="bool" updates="None" name="Show info dlg"/>
    <Param val="False" valType="bool" updates="None" name="Show mouse"/>
    <Param val="height" valType="str" updates="None" name="Units"/>
    <Param val="2024.1.0" valType="str" updates="None" name="Use version"/>
    <Param val="[1470, 956]" valType="list" updates="None" name="Window size (pixels)"/>
    <Param val="none" valType="str" updates="None" name="backgroundFit"/>
    <Param val="" valType="str" updates="None" name="backgroundImg"/>
    <Param val="avg" valType="str" updates="None" name="blendMode"/>
    <Param val="float" valType="str" updates="None" name="clockFormat"/>
    <Param val="{'thisRow.t': 'priority.CRITICAL', 'expName': 'priority.LOW'}" valType="dict" updates="None" name="colPriority"/>
    <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
    <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
    <Param val="100.1.1.1" valType="str" updates="None" name="elAddress"/>
    <Param val="FILTER_LEVEL_2" valType="str" updates="None" name="elDataFiltering"/>
    <Param val="FILTER_LEVEL_OFF" valType="str" updates="None" name="elLiveFiltering"/>
    <Param val="EYELINK 1000 DESKTOP" valType="str" updates="None" name="elModel"/>
    <Param val="ELLIPSE_FIT" valType="str" updates="None" name="elPupilAlgorithm"/>
    <Param val="PUPIL_AREA" valType="str" updates="None" name="elPupilMeasure"/>
    <Param val="1000" valType="num" updates="None" name="elSampleRate"/>
    <Param val="False" valType="bool" updates="None" name="elSimMode"/>
    <Param val="RIGHT_EYE" valType="str" updates="None" name="elTrackEyes"/>
    <Param val="PUPIL_CR_TRACKING" valType="str" updates="None" name="elTrackingMode"/>
    <Param val="EXNAT_3_fMRI" valType="str" updates="None" name="expName"/>
    <Param val="on Sync" valType="str" updates="None" name="exportHTML"/>
    <Param val="None" valType="str" updates="None" name="eyetracker"/>
    <Param val="" valType="code" updates="None" name="frameRate"/>
    <Param val="Attempting to measure frame rate of screen, please wait..." valType="str" updates="None" name="frameRateMsg"/>
    <Param val="127.0.0.1" valType="str" updates="None" name="gpAddress"/>
    <Param val="4242" valType="num" updates="None" name="gpPort"/>
    <Param val="ioHub" valType="str" updates="None" name="keyboardBackend"/>
    <Param val="warning" valType="code" updates="None" name="logging level"/>
    <Param val="False" valType="bool" updates="None" name="measureFrameRate"/>
    <Param val="('MIDDLE_BUTTON',)" valType="list" updates="None" name="mgBlink"/>
    <Param val="CONTINUOUS" valType="str" updates="None" name="mgMove"/>
    <Param val="0.5" valType="num" updates="None" name="mgSaccade"/>
    <Param val="neon.local" valType="str" updates="None" name="plCompanionAddress"/>
    <Param val="8080" valType="num" updates="None" name="plCompanionPort"/>
    <Param val="True" valType="bool" updates="None" name="plCompanionRecordingEnabled"/>
    <Param val="0.6" valType="num" updates="None" name="plConfidenceThreshold"/>
    <Param val="True" valType="bool" updates="None" name="plPupilCaptureRecordingEnabled"/>
    <Param val="" valType="str" updates="None" name="plPupilCaptureRecordingLocation"/>
    <Param val="127.0.0.1" valType="str" updates="None" name="plPupilRemoteAddress"/>
    <Param val="50020" valType="num" updates="None" name="plPupilRemotePort"/>
    <Param val="1000" valType="num" updates="None" name="plPupilRemoteTimeoutMs"/>
    <Param val="False" valType="bool" updates="None" name="plPupillometryOnly"/>
    <Param val="psychopy_iohub_surface" valType="str" updates="None" name="plSurfaceName"/>
    <Param val="1" valType="code" updates="None" name="runMode"/>
    <Param val="False" valType="bool" updates="None" name="rush"/>
    <Param val="time" valType="str" updates="None" name="sortColumns"/>
    <Param val="" valType="str" updates="None" name="tbLicenseFile"/>
    <Param val="" valType="str" updates="None" name="tbModel"/>
    <Param val="60" valType="num" updates="None" name="tbSampleRate"/>
    <Param val="" valType="str" updates="None" name="tbSerialNo"/>
    <Param val="pyglet" valType="str" updates="None" name="winBackend"/>
  </Settings>
  <Routines>
    <Routine name="Settings">
      <RoutineSettingsComponent name="Settings" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="Settings" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <CodeComponent name="functions" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="import {visual} from 'psychopy';&amp;#10;import * as datetime from 'datetime';&amp;#10;import * as np from 'numpy';&amp;#10;import * as random from 'random';&amp;#10;import * as pd from 'pandas';&amp;#10;import * as time from 'time';&amp;#10;import {instr_1back_dual_main, instr_1back_single_main, instr_1back_single_training1, instr_1back_single_training2, instr_2back_dual_main, instr_2back_single_main, instr_2back_single_training1, instr_2back_single_training2, instr_Reading_Baseline_main, instr_Reading_Baseline_training, instr_click_training, instr_pic_1back_dual_main, instr_pic_1back_single_main, instr_pic_1back_single_training1, instr_pic_1back_single_training2, instr_pic_2back_dual_main, instr_pic_2back_single_main, instr_pic_2back_single_training1, instr_pic_2back_single_training2, instr_pic_Reading_Baseline_main, instr_pic_Reading_Baseline_training, instr_pic_click_training, instr_pic_path, instr_pic_vis_task, instr_vis_task_1, instr_vis_task_2, reading_bl_tr_Q1, reading_bl_tr_Q1_ans, reading_bl_tr_Q1_corr, reading_bl_tr_Q2, reading_bl_tr_Q2_ans, reading_bl_tr_Q2_corr, reading_bl_tr_Q3, reading_bl_tr_Q3_ans, reading_bl_tr_Q3_corr, reading_bl_tr_text, text_01, text_01_Q1, text_01_Q1_ans, text_01_Q1_corr, text_01_Q2, text_01_Q2_ans, text_01_Q2_corr, text_01_Q3, text_01_Q3_ans, text_01_Q3_corr, text_02, text_02_Q1, text_02_Q1_ans, text_02_Q1_corr, text_02_Q2, text_02_Q2_ans, text_02_Q2_corr, text_02_Q3, text_02_Q3_ans, text_02_Q3_corr, text_03, text_03_Q1, text_03_Q1_ans, text_03_Q1_corr, text_03_Q2, text_03_Q2_ans, text_03_Q2_corr, text_03_Q3, text_03_Q3_ans, text_03_Q3_corr, text_04, text_04_Q1, text_04_Q1_ans, text_04_Q1_corr, text_04_Q2, text_04_Q2_ans, text_04_Q2_corr, text_04_Q3, text_04_Q3_ans, text_04_Q3_corr, text_05, text_05_Q1, text_05_Q1_ans, text_05_Q1_corr, text_05_Q2, text_05_Q2_ans, text_05_Q2_corr, text_05_Q3, text_05_Q3_ans, text_05_Q3_corr, text_06, text_06_Q1, text_06_Q1_ans, text_06_Q1_corr, text_06_Q2, text_06_Q2_ans, text_06_Q2_corr, text_06_Q3, text_06_Q3_ans, text_06_Q3_corr, text_07, text_07_Q1, text_07_Q1_ans, text_07_Q1_corr, text_07_Q2, text_07_Q2_ans, text_07_Q2_corr, text_07_Q3, text_07_Q3_ans, text_07_Q3_corr, text_08, text_08_Q1, text_08_Q1_ans, text_08_Q1_corr, text_08_Q2, text_08_Q2_ans, text_08_Q2_corr, text_08_Q3, text_08_Q3_ans, text_08_Q3_corr, text_09, text_09_Q1, text_09_Q1_ans, text_09_Q1_corr, text_09_Q2, text_09_Q2_ans, text_09_Q2_corr, text_09_Q3, text_09_Q3_ans, text_09_Q3_corr, text_10, text_10_Q1, text_10_Q1_ans, text_10_Q1_corr, text_10_Q2, text_10_Q2_ans, text_10_Q2_corr, text_10_Q3, text_10_Q3_ans, text_10_Q3_corr, warning_sign} from 'EXNAT2_texts_MC_Qs';&amp;#10;import {change_bg_colour} from 'EXNAT2_study_components';&amp;#10;import {create_0back_stimlist, create_nback_stimlist, draw_without_replacement, get_targets} from 'nback_colour_generator';&amp;#10;[SCN_W, SCN_H] = [1280, 800];&amp;#10;sys.stdout = open(sys.stdout.fileno(), {&quot;mode&quot;: &quot;w&quot;, &quot;encoding&quot;: &quot;utf8&quot;, &quot;buffering&quot;: 1});&amp;#10;console.log(sys.executable);&amp;#10;function flatten_list(nested_list) {&amp;#10;    var flattened_list;&amp;#10;    flattened_list = [];&amp;#10;    for (var item, _pj_c = 0, _pj_a = nested_list, _pj_b = _pj_a.length; (_pj_c &lt; _pj_b); _pj_c += 1) {&amp;#10;        item = _pj_a[_pj_c];&amp;#10;        if ((item instanceof list)) {&amp;#10;            flattened_list.concat(flatten_list(item));&amp;#10;        } else {&amp;#10;            flattened_list.push(item);&amp;#10;        }&amp;#10;    }&amp;#10;    return flattened_list;&amp;#10;}&amp;#10;function escape_quotes(string) {&amp;#10;    return string.replace(&quot;\&quot;&quot;, &quot;\&quot;\&quot;&quot;);&amp;#10;}&amp;#10;psychoJS.window.setMouseVisible(false);&amp;#10;my_timer = new core.CountdownTimer(0.01);&amp;#10;" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="# set screen resolution for eyetracker here:&amp;#10;SCN_W, SCN_H = (1280, 800)&amp;#10;&amp;#10;### import packages:&amp;#10;&amp;#10;# for setting the output encoding to UTF-8&amp;#10;# import sys&amp;#10;# --&gt; if you don't do this, German &quot;Umlaute&quot; can't be displayed correctly:&amp;#10;sys.stdout = open(sys.stdout.fileno(), mode='w', encoding='utf8', buffering=1)&amp;#10;# print Python environment psychopy is currently using&amp;#10;print(sys.executable)&amp;#10;&amp;#10;# for showing pictures&amp;#10;from psychopy import visual&amp;#10;# for getting current date &amp; time:&amp;#10;import datetime&amp;#10;# numpy for being able to calculate&amp;#10;import numpy as np&amp;#10;# for random number generator:&amp;#10;import random&amp;#10;# for saving data in csv / working with pd data frames:&amp;#10;import pandas as pd&amp;#10;# additional timing package (I know we have core.wait, but I also want this one)&amp;#10;import time&amp;#10;# for calculations&amp;#10;import math&amp;#10;&amp;#10;# Get functions from my custom scripts:&amp;#10;# import all texts and instructions&amp;#10;from EXNAT3_texts_MC_Qs import (instr_pic_path, instr_Reading_Baseline_main_no_click, instr_Reading_pseudotext_no_click, \&amp;#10;    instr_1back_single_main_no_click, instr_pic_1back_single_main_no_click, instr_1back_dual_main_no_click, \&amp;#10;    instr_pic_1back_dual_main_no_click, instr_2back_single_main_no_click, instr_pic_2back_single_main_no_click, instr_2back_dual_main_no_click, \&amp;#10;    instr_pic_2back_dual_main_no_click, warning_sign, text_01, text_01_Q1, text_01_Q1_ans, text_01_Q1_corr, \&amp;#10;    text_01_Q2, text_01_Q2_ans, text_01_Q2_corr, text_01_Q3, text_01_Q3_ans, text_01_Q3_corr, text_02, text_02_Q1, \&amp;#10;    text_02_Q1_ans, text_02_Q1_corr, text_02_Q2, text_02_Q2_ans, text_02_Q2_corr, text_02_Q3, text_02_Q3_ans, \&amp;#10;    text_02_Q3_corr, text_03, text_03_Q1, text_03_Q1_ans, text_03_Q1_corr, text_03_Q2, text_03_Q2_ans, text_03_Q2_corr, \&amp;#10;    text_03_Q3, text_03_Q3_ans, text_03_Q3_corr, text_04, text_04_Q1, text_04_Q1_ans, text_04_Q1_corr, text_04_Q2, \&amp;#10;    text_04_Q2_ans, text_04_Q2_corr, text_04_Q3, text_04_Q3_ans, text_04_Q3_corr, text_05, text_05_Q1, text_05_Q1_ans, \&amp;#10;    text_05_Q1_corr, text_05_Q2, text_05_Q2_ans, text_05_Q2_corr, text_05_Q3, text_05_Q3_ans, text_05_Q3_corr, text_06, \&amp;#10;    text_06_Q1, text_06_Q1_ans, text_06_Q1_corr, text_06_Q2, text_06_Q2_ans, text_06_Q2_corr, text_06_Q3, \&amp;#10;    text_06_Q3_ans, text_06_Q3_corr, text_07, text_07_Q1, text_07_Q1_ans, text_07_Q1_corr, text_07_Q2, text_07_Q2_ans, \&amp;#10;    text_07_Q2_corr, text_07_Q3, text_07_Q3_ans, text_07_Q3_corr, text_08, text_08_Q1, text_08_Q1_ans, text_08_Q1_corr, \&amp;#10;    text_08_Q2, text_08_Q2_ans, text_08_Q2_corr, text_08_Q3, text_08_Q3_ans, text_08_Q3_corr, text_09, text_09_Q1, \&amp;#10;    text_09_Q1_ans, text_09_Q1_corr, text_09_Q2, text_09_Q2_ans, text_09_Q2_corr, text_09_Q3, text_09_Q3_ans, \&amp;#10;    text_09_Q3_corr, text_10, text_10_Q1, text_10_Q1_ans, text_10_Q1_corr, text_10_Q2, text_10_Q2_ans, text_10_Q2_corr, \&amp;#10;    text_10_Q3, text_10_Q3_ans, text_10_Q3_corr, pseudo_text_01, pseudo_text_02, pseudo_text_03, pseudo_text_04, pseudo_text_05, \&amp;#10;    pseudo_text_06, pseudo_text_07, pseudo_text_08, pseudo_text_09)&amp;#10;&amp;#10;# import some additional functions I wrote for the experiment:&amp;#10;# from EXNAT3_study_components import change_bg_colour&amp;#10;from nback_colour_generator import create_nback_stimlist, draw_without_replacement, get_targets, create_0back_stimlist&amp;#10;&amp;#10;&amp;#10;# build little function to flatten nested lists:&amp;#10;def flatten_list(nested_list):&amp;#10;    flattened_list = []&amp;#10;    for item in nested_list:&amp;#10;        if isinstance(item, list):&amp;#10;            flattened_list.extend(flatten_list(item))&amp;#10;        else:&amp;#10;            flattened_list.append(item)&amp;#10;    return flattened_list&amp;#10;&amp;#10;&amp;#10;# If I try to save strings containing escaped quotes in a csv file,&amp;#10;# the format gets completely messed up. So we need to escape all&amp;#10;# weird characters like quotes and backslashes with quotes (as odd as it sounds).&amp;#10;def escape_quotes(string):&amp;#10;    # escape quotes with quotes instead of backslashes&amp;#10;    return string.replace('&quot;', '&quot;&quot;')&amp;#10;&amp;#10;&amp;#10;# make mouse invisible during experiment&amp;#10;# mouse = io.devices.mouse&amp;#10;win.setMouseVisible(False)&amp;#10;&amp;#10;# create 10 ms timer that we can use instead of core.wait()&amp;#10;my_timer = core.CountdownTimer(0.01)&amp;#10;" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="functions" valType="code" updates="None" name="name"/>
      </CodeComponent>
      <CodeComponent name="stimuli" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="### Stimulus settings&amp;#10;# import random&amp;#10;&amp;#10;# set colours you want to use for background:&amp;#10;# light_bg_col_hex = &quot;#FDFBF0&quot; # ivory instructions background&amp;#10;# dark_bg_col_hex  = &quot;#505050&quot; # dark grey background for stimuli&amp;#10;light_bg_col = [(x / 127.5) - 1 for x in (253, 251, 240)]  # ivory instructions background (use RGB -1:1)&amp;#10;dark_bg_col = [(x / 127.5) - 1 for x in (80, 80, 80)]  # dark grey background for stimuli (use RGB -1:1)&amp;#10;&amp;#10;# make background light for a start - use rgb -1:1 colour codes&amp;#10;win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;&amp;#10;# set colours you want to use for the stimuli:&amp;#10;colours = [&quot;#D292F3&quot;, &quot;#F989A2&quot;, &quot;#2AB7EF&quot;, &quot;#88BA3F&quot;]&amp;#10;print(&quot;Preparing experiment with n-back colours:&quot;, colours)&amp;#10;&amp;#10;#  #D292F3 = weird lilac with a 2000s vibe&amp;#10;#  #F989A2 = Barbie pink&amp;#10;#  #2AB7EF = Twitter blue&amp;#10;#  #88BA3F = medium grass green&amp;#10;# (#D8A244 = dark curry-ish yellow --&gt; excluded!)&amp;#10;&amp;#10;#   All colours have a luminance of 70 and a chroma of 74.&amp;#10;&amp;#10;#   The colours are selected for distinguishability (is that a word?!)&amp;#10;#   for people with &quot;normal&quot; colour vision as well as for&amp;#10;#   people with protanomaly (red olour vision deficiency (CVD)),&amp;#10;#   deuteranomaly (green CVD) and&amp;#10;#   tritanomaly (blue CVD).&amp;#10;&amp;#10;#   People with a &quot;true&quot; colour blindness&amp;#10;#   (i.e. protanopia, deuteranopia, tritanopia)&amp;#10;#   shouldn't participate in this study. */&amp;#10;&amp;#10;&amp;#10;# ----------------------------------------------&amp;#10;### Shuffle order of texts&amp;#10;print(&quot;shuffle texts&quot;)&amp;#10;# collect the text IDs in lists so I know which text was shown&amp;#10;all_main_texts_nrs_list = [&quot;text_01&quot;, &quot;text_02&quot;, &quot;text_03&quot;, &quot;text_04&quot;, &quot;text_05&quot;, &quot;text_06&quot;, &quot;text_07&quot;, &quot;text_08&quot;,&amp;#10;                           &quot;text_09&quot;, &quot;text_10&quot;]&amp;#10;all_pseudotexts_nrs_list = [&quot;pseudo_text_01&quot;, &quot;pseudo_text_02&quot;, &quot;pseudo_text_03&quot;, &quot;pseudo_text_04&quot;, &quot;pseudo_text_05&quot;,&amp;#10;                            &quot;pseudo_text_06&quot;, &quot;pseudo_text_07&quot;, &quot;pseudo_text_08&quot;, &quot;pseudo_text_09&quot;]&amp;#10;# shuffle text numbers&amp;#10;random.shuffle(all_main_texts_nrs_list)&amp;#10;random.shuffle(all_pseudotexts_nrs_list)&amp;#10;&amp;#10;# only get first 5 texts for the main blocks&amp;#10;all_main_texts_nrs_list = all_main_texts_nrs_list[0:5]&amp;#10;&amp;#10;# only get first text for pseudotext&amp;#10;all_pseudotexts_nrs_list = all_pseudotexts_nrs_list[0:1]&amp;#10;&amp;#10;# append &quot;empty&quot; text numbers to the list where we have blocks that are not main blocks.&amp;#10;all_texts_nrs_list = []&amp;#10;&amp;#10;# Loop through the range of the length of texts since it's the longer list&amp;#10;for t_idx in range(len(all_main_texts_nrs_list)):&amp;#10;    # if it's the first text, it's the reading BL main block.&amp;#10;    if t_idx == 0:&amp;#10;        # Append 1 text for baseline reading&amp;#10;        all_texts_nrs_list.append(all_main_texts_nrs_list[t_idx])&amp;#10;        # Then append 1 text for pseudotext plus 4 empty blocks for n-back single task&amp;#10;        all_texts_nrs_list.extend([all_pseudotexts_nrs_list[0], &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;])&amp;#10;    elif t_idx &gt;= 1:&amp;#10;        # Then 4 reading blocks for dual task&amp;#10;        all_texts_nrs_list.append(all_main_texts_nrs_list[t_idx])&amp;#10;&amp;#10;# This will result in a list following your described logic&amp;#10;print(all_texts_nrs_list)&amp;#10;&amp;#10;### Set order of blocks&amp;#10;print(&quot;set block order for runs&quot;)&amp;#10;&amp;#10;# RUN 1&amp;#10;# always starts with single reading (BL + PS)&amp;#10;single_reading = [&quot;Reading_Baseline_main_no_click&quot;, &quot;Reading_pseudotext_no_click&quot;]&amp;#10;&amp;#10;run1_blocks = single_reading&amp;#10;print(&quot;Blocks for run1:&quot;, run1_blocks)&amp;#10;&amp;#10;# RUN 2&amp;#10;# then you get both single n-back conditions&amp;#10;nback1 = [&quot;1back_single_main_no_click&quot;, &quot;2back_single_main_no_click&quot;]&amp;#10;random.shuffle(nback1)&amp;#10;&amp;#10;nback2 = [&quot;1back_single_main_no_click&quot;, &quot;2back_single_main_no_click&quot;]&amp;#10;random.shuffle(nback2)&amp;#10;&amp;#10;run2_blocks = nback1 + nback2&amp;#10;print(&quot;Blocks for run2:&quot;, run2_blocks)&amp;#10;&amp;#10;# RUNS 3 &amp; 4&amp;#10;# two dual-task blocks, order randomized&amp;#10;dualtask = [&quot;1back_dual_main_no_click&quot;, &quot;2back_dual_main_no_click&quot;]&amp;#10;random.shuffle(dualtask)&amp;#10;&amp;#10;run3_blocks = dualtask&amp;#10;print(&quot;Blocks for run3:&quot;, dualtask)&amp;#10;&amp;#10;random.shuffle(dualtask)&amp;#10;run4_blocks = dualtask&amp;#10;print(&quot;Blocks for run4:&quot;, dualtask)&amp;#10;&amp;#10;### Create n-back colour lists for all blocks&amp;#10;&amp;#10;print(&quot;create n-back colour lists&quot;)&amp;#10;# There are 10 blocks in total&amp;#10;# For run 1, 6 blocks (2 text blocks + 4 single n-back)&amp;#10;# Run 2 and 3 each have 2 dual-task blocks with 300 stimuli each (50 targets)&amp;#10;&amp;#10;# So for every block, build a list with colour codes containing the right amount of targets.&amp;#10;# The function is defined in another script bc it's super long,&amp;#10;# I import it at the beginning of this script.&amp;#10;&amp;#10;# RUN 1&amp;#10;# First, create list with length of all texts. The length of the blocks is&amp;#10;# always in the same order, only the conditions change.&amp;#10;blocks_textlen = [300, 100] # reading blocks&amp;#10;blocks_target_counts = [25, 25]  # reading blocks&amp;#10;&amp;#10;# Now loop this list. Check which condition we have there and then create colour list for each text.&amp;#10;run1_colour_lists = []&amp;#10;run1_target_lists = []&amp;#10;for block_idx, block_length in enumerate(blocks_textlen):&amp;#10;    # get 1st letter of block name - that tells us the condition&amp;#10;    block_cond = run1_blocks[block_idx][0]&amp;#10;&amp;#10;    # for each condition, decide which n-back level we want to assign&amp;#10;    # For all no-n-back blocks, we use 1 (just for the colour list generation)&amp;#10;    # global curr_nback_level&amp;#10;    if block_cond == &quot;R&quot;:&amp;#10;        curr_nback_level = 1&amp;#10;    elif block_cond == &quot;1&quot;:&amp;#10;        curr_nback_level = 1&amp;#10;    else:&amp;#10;        curr_nback_level = 2&amp;#10;&amp;#10;    # generate colour list for current block&amp;#10;    # global curr_colours&amp;#10;    curr_colours = create_nback_stimlist(nback_level=curr_nback_level,&amp;#10;                                         colour_codes=colours,&amp;#10;                                         story=[&quot;x&quot;] * block_length,&amp;#10;                                         target_abs_min=blocks_target_counts[block_idx],&amp;#10;                                         target_abs_max=blocks_target_counts[block_idx],&amp;#10;                                         zeroback_target=None)&amp;#10;&amp;#10;    # get list of targets / non-targets&amp;#10;    curr_targets = get_targets(stim_list=curr_colours,&amp;#10;                               nback_level=curr_nback_level)&amp;#10;&amp;#10;    # add to bigger lists&amp;#10;    run1_colour_lists.append(curr_colours)&amp;#10;    run1_target_lists.append(curr_targets)&amp;#10;&amp;#10;# RUN 2&amp;#10;blocks_textlen = [90, 90, 90, 90]  # single n-back blocks&amp;#10;blocks_target_counts = [15, 15, 15, 15]&amp;#10;&amp;#10;# Now loop this list. Check which condition we have there and then create colour list for each text.&amp;#10;run2_colour_lists = []&amp;#10;run2_target_lists = []&amp;#10;for block_idx, block_length in enumerate(blocks_textlen):&amp;#10;    # get 1st letter of block name - that tells us the condition&amp;#10;    block_cond = run2_blocks[block_idx][0]&amp;#10;&amp;#10;    # for each condition, decide which n-back level we want to assign&amp;#10;    # For all no-n-back blocks, we use 1 (just for the colour list generation)&amp;#10;    # global curr_nback_level&amp;#10;    if block_cond == &quot;R&quot;:&amp;#10;        curr_nback_level = 1&amp;#10;    elif block_cond == &quot;1&quot;:&amp;#10;        curr_nback_level = 1&amp;#10;    else:&amp;#10;        curr_nback_level = 2&amp;#10;&amp;#10;    # generate colour list for current block&amp;#10;    # global curr_colours&amp;#10;    curr_colours = create_nback_stimlist(nback_level=curr_nback_level,&amp;#10;                                         colour_codes=colours,&amp;#10;                                         story=[&quot;x&quot;] * block_length,&amp;#10;                                         target_abs_min=blocks_target_counts[block_idx],&amp;#10;                                         target_abs_max=blocks_target_counts[block_idx],&amp;#10;                                         zeroback_target=None)&amp;#10;&amp;#10;    # get list of targets / non-targets&amp;#10;    curr_targets = get_targets(stim_list=curr_colours,&amp;#10;                               nback_level=curr_nback_level)&amp;#10;&amp;#10;    # add to bigger lists&amp;#10;    run2_colour_lists.append(curr_colours)&amp;#10;    run2_target_lists.append(curr_targets)&amp;#10;&amp;#10;# RUNS 3 &amp; 4&amp;#10;blocks_textlen = [300, 300, 300, 300] # dual-task blocks&amp;#10;blocks_target_counts = [50, 50, 50, 50]  # dual-task blocks&amp;#10;&amp;#10;# Now loop this list. Check which condition we have there and then create colour list for each text.&amp;#10;dual_blocks = run3_blocks + run4_blocks&amp;#10;run3_4_colour_lists = []&amp;#10;run3_4_target_lists = []&amp;#10;for block_idx, block_length in enumerate(blocks_textlen):&amp;#10;    # get 1st letter of block name - that tells us the condition&amp;#10;    block_cond = dual_blocks[block_idx][0]&amp;#10;&amp;#10;    # for each condition, decide which n-back level we want to assign&amp;#10;    # For all no-n-back blocks, we use 1 (just for the colour list generation)&amp;#10;    # global curr_nback_level&amp;#10;    if block_cond == &quot;R&quot;:&amp;#10;        curr_nback_level = 1&amp;#10;    elif block_cond == &quot;1&quot;:&amp;#10;        curr_nback_level = 1&amp;#10;    else:&amp;#10;        curr_nback_level = 2&amp;#10;&amp;#10;    # generate colour list for current block&amp;#10;    # global curr_colours&amp;#10;    curr_colours = create_nback_stimlist(nback_level=curr_nback_level,&amp;#10;                                         colour_codes=colours,&amp;#10;                                         story=[&quot;x&quot;] * block_length,&amp;#10;                                         target_abs_min=blocks_target_counts[block_idx],&amp;#10;                                         target_abs_max=blocks_target_counts[block_idx],&amp;#10;                                         zeroback_target=None)&amp;#10;&amp;#10;    # get list of targets / non-targets&amp;#10;    curr_targets = get_targets(stim_list=curr_colours,&amp;#10;                               nback_level=curr_nback_level)&amp;#10;&amp;#10;    # add to bigger lists&amp;#10;    run3_4_colour_lists.append(curr_colours)&amp;#10;    run3_4_target_lists.append(curr_targets)&amp;#10;&amp;#10;run3_colour_lists = run3_4_colour_lists[0:2]&amp;#10;run4_colour_lists = run3_4_colour_lists[2:4]&amp;#10;&amp;#10;run3_target_lists = run3_4_target_lists[0:2]&amp;#10;run4_target_lists = run3_4_target_lists[2:4]&amp;#10;&amp;#10;print(&quot;------ finished preparing stimuli! ------&quot;)&amp;#10;&amp;#10;# ------------------------------------------&amp;#10;&amp;#10;# init block counter for the whole experiment and for each run&amp;#10;exp_block_counter = 0&amp;#10;# init block counter for run1 (two blocks in total)&amp;#10;run1_block_counter = 0&amp;#10;# init block counter for run2 (four blocks in total)&amp;#10;run2_block_counter = 0&amp;#10;# init block counter for run3 (two blocks in total)&amp;#10;run3_block_counter = 0&amp;#10;# init block counter for run4 (two blocks in total)&amp;#10;run4_block_counter = 0&amp;#10;&amp;#10;print(&quot;starting experiment now!&quot;)" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="stimuli" valType="code" updates="None" name="name"/>
      </CodeComponent>
      <TextComponent name="empty_placeholder" plugin="None">
        <Param val="white" valType="color" updates="constant" name="color"/>
        <Param val="rgb" valType="str" updates="constant" name="colorSpace"/>
        <Param val="1" valType="num" updates="constant" name="contrast"/>
        <Param val="True" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="None" valType="str" updates="constant" name="flip"/>
        <Param val="Open Sans" valType="str" updates="constant" name="font"/>
        <Param val="LTR" valType="str" updates="None" name="languageStyle"/>
        <Param val="0.05" valType="num" updates="constant" name="letterHeight"/>
        <Param val="empty_placeholder" valType="code" updates="None" name="name"/>
        <Param val="" valType="num" updates="constant" name="opacity"/>
        <Param val="0" valType="num" updates="constant" name="ori"/>
        <Param val="(0, 0)" valType="list" updates="constant" name="pos"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="None" name="startEstim"/>
        <Param val="time (s)" valType="str" updates="None" name="startType"/>
        <Param val="0.0" valType="code" updates="None" name="startVal"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="1.0" valType="code" updates="constant" name="stopVal"/>
        <Param val="True" valType="bool" updates="None" name="syncScreenRefresh"/>
        <Param val="" valType="str" updates="constant" name="text"/>
        <Param val="from exp settings" valType="str" updates="None" name="units"/>
        <Param val="" valType="code" updates="None" name="validator"/>
        <Param val="" valType="num" updates="constant" name="wrapWidth"/>
      </TextComponent>
    </Routine>
    <Routine name="text_blocks_self_paced">
      <RoutineSettingsComponent name="text_blocks_self_paced" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="True" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="text_blocks_self_paced" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <CodeComponent name="text_blocks" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="/* Syntax Error: Fix Python code */" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="#################################################&amp;#10;#           Blocks with text – self-paced       #&amp;#10;#################################################&amp;#10;# this routine is for all blocks with texts that are self-paced&amp;#10;&amp;#10;# keep background ivory&amp;#10;win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;win.flip()&amp;#10;&amp;#10;# clear buffer of all previously recorded key events:&amp;#10;event.clearEvents()&amp;#10;&amp;#10;### specify settings for the current block&amp;#10;&amp;#10;### Prepare stimuli:&amp;#10;&amp;#10;# get block kind&amp;#10;curr_block = all_blocks[exp_block_counter]&amp;#10;# print(&quot;start preparing block &quot; + curr_block)&amp;#10;&amp;#10;# Check whether it's a block that isn't self-paced&amp;#10;# If yes, skip this routine&amp;#10;if curr_block in [&quot;click_training&quot;, &quot;1back_single_training1&quot;, &quot;1back_single_training2&quot;,&amp;#10;                  &quot;2back_single_training1&quot;, &quot;2back_single_training2&quot;,&amp;#10;                  &quot;Reading_Baseline_main_no_click&quot;, &quot;1back_dual_main_no_click&quot;, &quot;2back_dual_main_no_click&quot;,&amp;#10;                  &quot;Reading_Baseline_training_no_click&quot;]:&amp;#10;    print(f&quot;this is block {curr_block}&quot;)&amp;#10;    print(&quot;\tskipping self-paced text routine&quot;)&amp;#10;    # skip questions &amp; end current routine&amp;#10;    skip_questions = True&amp;#10;    continueRoutine = False&amp;#10;    # break&amp;#10;&amp;#10;# if it's the reading bl training block, prepare training stimuli:&amp;#10;elif curr_block == &quot;Reading_Baseline_training_click&quot;:&amp;#10;    print(f&quot;this is block {curr_block}&quot;)&amp;#10;    print(f&quot;start preparing block {curr_block}&quot;)&amp;#10;&amp;#10;    # keep background ivory&amp;#10;    win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;    win.flip()&amp;#10;&amp;#10;    ### Show instructions&amp;#10;    # set instruction text&amp;#10;    instr_text = locals()[&quot;instr_&quot; + curr_block]&amp;#10;    # create text box&amp;#10;    instr_text_stim = visual.TextStim(win,&amp;#10;                                      text=instr_text,&amp;#10;                                      height=0.025,  # font height relative to height of screen&amp;#10;                                      pos=(0, 0.2),  # move up a bit&amp;#10;                                      color=&quot;black&quot;)&amp;#10;    # create ImageStim object&amp;#10;    curr_instr_pic = visual.ImageStim(win,&amp;#10;                                      size=(0.6, 0.3),&amp;#10;                                      pos=(0, -0.2),&amp;#10;                                      image=locals()[&quot;instr_pic_&quot; + curr_block])  # set path to image here&amp;#10;&amp;#10;    # show instructions on screen&amp;#10;    win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;    instr_text_stim.draw()&amp;#10;    curr_instr_pic.draw()&amp;#10;    win.flip()&amp;#10;    core.wait(3)  # wait for 3s before starting response window&amp;#10;&amp;#10;    # display the text on screen&amp;#10;    while True:&amp;#10;        # keep background ivory&amp;#10;        win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;        instr_text_stim.draw()&amp;#10;        curr_instr_pic.draw()&amp;#10;        win.flip()&amp;#10;        # end showing screen if participant presses space&amp;#10;        if 'space' in event.getKeys():&amp;#10;            break&amp;#10;&amp;#10;    ### get training text&amp;#10;    curr_text = reading_bl_tr_text&amp;#10;    curr_text_nr = &quot;reading_bl_training_text&quot;&amp;#10;    curr_nback_cond = None&amp;#10;    curr_colours = all_colour_lists[0]&amp;#10;    # show training questions&amp;#10;    skip_questions = False&amp;#10;    training_Qs = True&amp;#10;&amp;#10;    # we also need the start time (let's set it as current time&amp;#10;    # at this point in the script):&amp;#10;    start_time = core.getTime()&amp;#10;&amp;#10;    ### change background colour&amp;#10;    win.setColor(dark_bg_col, colorSpace='rgb')&amp;#10;    win.flip()&amp;#10;&amp;#10;    print(f&quot;\tcurrent text: {curr_text_nr}&quot;)&amp;#10;&amp;#10;# if it's one of the &quot;normal&quot; main blocks, prepare main block stimuli:&amp;#10;elif curr_block in [&quot;Reading_Baseline_main_click&quot;, &quot;1back_dual_main_click&quot;, &quot;2back_dual_main_click&quot;]:&amp;#10;    print(f&quot;this is block {curr_block}&quot;)&amp;#10;    print(f&quot;start preparing block {curr_block}&quot;)&amp;#10;&amp;#10;    # keep background ivory&amp;#10;    win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;    win.flip()&amp;#10;&amp;#10;    ### Show instructions&amp;#10;    # set instruction text&amp;#10;    instr_text = locals()[&quot;instr_&quot; + curr_block]&amp;#10;    # create text box&amp;#10;    instr_text_stim = visual.TextStim(win,&amp;#10;                                      text=instr_text,&amp;#10;                                      height=0.025,  # font height relative to height of screen&amp;#10;                                      pos=(0, 0.2),  # move up a bit&amp;#10;                                      color=&quot;black&quot;)&amp;#10;    if curr_block == &quot;Reading_Baseline_main_click&quot;:&amp;#10;        # create ImageStim object&amp;#10;        curr_instr_pic = visual.ImageStim(win,&amp;#10;                                          size=(0.6, 0.3),&amp;#10;                                          pos=(0, -0.2),&amp;#10;                                          image=locals()[&quot;instr_pic_&quot; + curr_block])  # set path to image here&amp;#10;    else:&amp;#10;        # create ImageStim object&amp;#10;        curr_instr_pic = visual.ImageStim(win,&amp;#10;                                          size=(0.8, 0.3),&amp;#10;                                          pos=(0, -0.2),&amp;#10;                                          image=locals()[&quot;instr_pic_&quot; + curr_block])  # set path to image here&amp;#10;&amp;#10;    # show instructions&amp;#10;    win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;    instr_text_stim.draw()&amp;#10;    curr_instr_pic.draw()&amp;#10;    win.flip()&amp;#10;    core.wait(3)  # wait for 3s before starting response window&amp;#10;&amp;#10;    # Display the text on screen&amp;#10;    while True:&amp;#10;        instr_text_stim.draw()&amp;#10;        curr_instr_pic.draw()&amp;#10;        win.flip()&amp;#10;        # end showing screen if participant presses space&amp;#10;        if 'space' in event.getKeys():&amp;#10;            break&amp;#10;&amp;#10;    ### change background colour&amp;#10;    win.setColor(dark_bg_col, colorSpace='rgb')&amp;#10;    win.flip()&amp;#10;&amp;#10;    # show main block questions&amp;#10;    skip_questions = False&amp;#10;    training_Qs = False&amp;#10;&amp;#10;    # get text nr:&amp;#10;    curr_text_nr = all_texts_nrs_list[exp_block_counter]&amp;#10;&amp;#10;    # get n-back condition:&amp;#10;    curr_nback_cond = curr_block[0]  # get first character of block name&amp;#10;&amp;#10;    # if it is a 1 or a 2, set that as current n-back level:&amp;#10;    if curr_nback_cond in ['1', '2']:&amp;#10;        curr_nback_cond == int(curr_nback_cond)&amp;#10;    # if it's neither 1 nor 2, it has to be a block without n-back,&amp;#10;    # so set curr_nback_cond to None&amp;#10;    else:&amp;#10;        curr_nback_cond = None&amp;#10;&amp;#10;    print(f&quot;\tcurrent n-back condition: {curr_nback_cond}&quot;)&amp;#10;    print(f&quot;\tcurrent text: {curr_text_nr}&quot;)&amp;#10;&amp;#10;    # get list with targets &amp; list with colours&amp;#10;    curr_targets = all_target_lists[exp_block_counter]&amp;#10;    curr_colours = all_colour_lists[exp_block_counter]&amp;#10;    # for current text nr, get text whose name = current text nr&amp;#10;    curr_text = locals()[curr_text_nr]&amp;#10;&amp;#10;### Start block loop&amp;#10;if curr_block in [&quot;Reading_Baseline_training_click&quot;, &quot;Reading_Baseline_main_click&quot;, &quot;1back_dual_main_click&quot;, &quot;2back_dual_main_click&quot;]:&amp;#10;    # depending on condition, create arrays for saving response&amp;#10;    # times &amp; words - we need that later for the paced reading tasks&amp;#10;    if curr_block == &quot;Reading_Baseline_main_click&quot;:&amp;#10;        BL_paced_durations = []&amp;#10;        BL_paced_words = []&amp;#10;    elif curr_block == &quot;1back_dual_main_click&quot;:&amp;#10;        oneback_paced_durations = []&amp;#10;        oneback_paced_words = []&amp;#10;    elif curr_block == &quot;2back_dual_main_click&quot;:&amp;#10;        twoback_paced_durations = []&amp;#10;        twoback_paced_words = []&amp;#10;&amp;#10;    # create empty text stimulus&amp;#10;    stim = visual.TextStim(win=win,&amp;#10;                           text=&quot; &quot;,&amp;#10;                           pos=(0, 0),  # center stimulus&amp;#10;                           font=&quot;Times New Roman&quot;,&amp;#10;                           height=0.07)&amp;#10;&amp;#10;    stim.draw()&amp;#10;    win.flip()&amp;#10;&amp;#10;    # clear buffer of all previously recorded key events:&amp;#10;    event.clearEvents()&amp;#10;&amp;#10;    # CREATE CLOCKS:&amp;#10;    my_block_clock = core.Clock()&amp;#10;    my_block_clock.reset()  # start block clock&amp;#10;    start_time = my_block_clock.getTime()  # get start time of block&amp;#10;    # also create trial clock&amp;#10;    my_trial_clock = core.Clock()&amp;#10;&amp;#10;    # loop words in current text&amp;#10;    for trial_idx, curr_word in enumerate(curr_text):&amp;#10;        # print(&quot;current idx: &quot; + str(trial_idx) + &quot;, curr word:&quot; + curr_word)&amp;#10;&amp;#10;        ### prepare &amp; show current word:&amp;#10;&amp;#10;        # get current colour&amp;#10;        curr_colour = curr_colours[trial_idx]&amp;#10;&amp;#10;        # if it's a block with an n-back task, prepare target list as well&amp;#10;        if curr_nback_cond != None:&amp;#10;            curr_target = curr_targets[trial_idx]&amp;#10;            saw_target = False&amp;#10;&amp;#10;        # get trial number (start counting from 1, so add 1)&amp;#10;        curr_trial_nr = trial_idx + 1&amp;#10;&amp;#10;        # set current word &amp; colour as content of text stimulus&amp;#10;        stim.color = curr_colour&amp;#10;        stim.text = curr_word&amp;#10;&amp;#10;        # show word on screen&amp;#10;        stim.draw()  # draw word on screen&amp;#10;&amp;#10;        # start trial clock&amp;#10;        my_trial_clock.reset()&amp;#10;        onset_time = my_trial_clock.getTime()&amp;#10;&amp;#10;        ### wait for 50 ms&amp;#10;        while my_trial_clock.getTime() &lt; onset_time + 0.05:&amp;#10;&amp;#10;            # draw the stimulus during the waiting period&amp;#10;            stim.draw()  # draw text&amp;#10;            win.flip()&amp;#10;&amp;#10;        ### wait for key response:&amp;#10;        # In blocks with n-back task, participants can press &quot;c&quot; to indicate they saw a target colour and &quot;space&quot; to go to the next word/stimulus.&amp;#10;        # In blocks without n-back task, participants can only press &quot;space&quot; to go to the next word/stimulus.&amp;#10;        # print(&quot;start tracking key responses&quot;)&amp;#10;&amp;#10;        ### start recording responses&amp;#10;        # start &quot;endless&quot; while loop that looks for responses&amp;#10;        continue_trial = True&amp;#10;        trial_start_time = my_trial_clock.getTime()  # Record the start time of the trial&amp;#10;        while continue_trial:&amp;#10;&amp;#10;            # in each iteration, draw word on screen&amp;#10;            stim.draw()&amp;#10;            win.flip()&amp;#10;&amp;#10;            # check for key responses:&amp;#10;            keys = event.getKeys(['space', 'c', 'escape'])&amp;#10;&amp;#10;            # if we recorded a response, check which one.&amp;#10;            # If not, we go  to the next &quot;while&quot; iteration,&amp;#10;            # so I hope this saves us a few dropped frames in the flicker.&amp;#10;            for key in keys:&amp;#10;&amp;#10;                # if participant pressed space bar on their keyboard...&amp;#10;                if key == 'space':&amp;#10;                    # get reaction time&amp;#10;                    curr_duration = my_trial_clock.getTime() * 1000&amp;#10;                    # send trigger for response:&amp;#10;                    # send_trigger(&quot;response_continue&quot;)&amp;#10;                    # break while loop&amp;#10;                    continue_trial = False&amp;#10;&amp;#10;                # if participant pressed button &quot;c&quot; for the first time and it's an n-back condition&amp;#10;                # where they're actually supposed to do that (aka not a reading baseline condition)...&amp;#10;                elif key == 'c' and curr_nback_cond != None and saw_target == False:&amp;#10;                    # get reaction time&amp;#10;                    curr_nback_RT = my_trial_clock.getTime() * 1000&amp;#10;                    # send trigger for response:&amp;#10;                    # send_trigger(&quot;response_target&quot;)&amp;#10;                    # only get first target response, we don't care if they press the button more than once:&amp;#10;                    saw_target = True&amp;#10;&amp;#10;                # If esc is pressed, end the experiment:&amp;#10;                elif key == 'escape':&amp;#10;                    # et_abort_exp()  # shut down eyetrigger and download incremental data&amp;#10;                    # close trigger &amp; close experiment&amp;#10;                    # core.wait(time_after_trigger)&amp;#10;                    # parallel.setData(0)&amp;#10;                    core.wait(0.5)&amp;#10;                    core.quit()&amp;#10;&amp;#10;            # Check for timeout - if more than 1.5, 2 or 1.5 seconds have passed, move to the next trial&amp;#10;            if my_trial_clock.getTime() - trial_start_time &gt;= 1.5 and curr_block in [&quot;Reading_Baseline_training_click&quot;, &quot;Reading_Baseline_main_click&quot;]:&amp;#10;                curr_duration = 1500&amp;#10;                continue_trial = False&amp;#10;            elif my_trial_clock.getTime() - trial_start_time &gt;= 2 and curr_block == &quot;1back_dual_main_click&quot;:&amp;#10;                curr_duration = 2000&amp;#10;                continue_trial = False&amp;#10;            elif my_trial_clock.getTime() - trial_start_time &gt;= 2.5 and curr_block == &quot;2back_dual_main_click&quot;:&amp;#10;                curr_duration = 2500&amp;#10;                continue_trial = False&amp;#10;&amp;#10;        ### end trial&amp;#10;        print(&quot;\tend self-paced trial&quot;)&amp;#10;        # stop display of current word &amp; send trial offset trigger&amp;#10;        # win.callOnFlip(send_trigger, &quot;trial_offset&quot;)&amp;#10;&amp;#10;        # check whether response was hit, miss, false alarm or correct rejection&amp;#10;        # they saw a target and there was one: hit&amp;#10;        if curr_nback_cond != None:&amp;#10;            if saw_target and curr_target:&amp;#10;                curr_nback_response = &quot;hit&quot;&amp;#10;            # they didn't see a target but there was one: miss&amp;#10;            elif saw_target == False and curr_target:&amp;#10;                curr_nback_response = &quot;miss&quot;&amp;#10;                curr_nback_RT = None&amp;#10;            # they didn't see a target and there was none: correct rejection&amp;#10;            elif saw_target == False and curr_target == False:&amp;#10;                curr_nback_response = &quot;correct rejection&quot;&amp;#10;                curr_nback_RT = None&amp;#10;            # they saw a target but there was none: false alarm&amp;#10;            elif saw_target and curr_target == False:&amp;#10;                curr_nback_response = &quot;false alarm&quot;&amp;#10;        # if it wasn't an n-back task block:&amp;#10;        else:&amp;#10;            curr_target = None&amp;#10;            curr_nback_response = None&amp;#10;            curr_nback_RT = None&amp;#10;&amp;#10;        ### save everything in output csv&amp;#10;        thisExp.addData('colour', curr_colour)&amp;#10;        thisExp.addData('target', curr_target)&amp;#10;        thisExp.addData('nback_response', curr_nback_response)&amp;#10;        thisExp.addData('nback_RT', curr_nback_RT)  # in ms&amp;#10;        thisExp.addData('duration', curr_duration)  # in ms&amp;#10;        thisExp.addData('text_nr', curr_text_nr)&amp;#10;        thisExp.addData('trial_nr', curr_trial_nr)&amp;#10;        thisExp.addData('block_nr', exp_block_counter)&amp;#10;        thisExp.addData('block_name', curr_block)&amp;#10;        thisExp.addData('block_kind', curr_nback_cond)&amp;#10;        # careful, make sure quotes in the strings are escaped using a&amp;#10;        # quote (weird, I know) so it's properly saved in the CSV:&amp;#10;        thisExp.addData('word', escape_quotes(curr_word))&amp;#10;&amp;#10;        # start a new row in the csv&amp;#10;        thisExp.nextEntry()&amp;#10;&amp;#10;        # depending on condition, save response times and words in previously created arrays&amp;#10;        # we need that later for the paced reading tasks&amp;#10;        if curr_block == &quot;Reading_Baseline_main_click&quot;:&amp;#10;            BL_paced_durations.append(curr_duration)&amp;#10;            BL_paced_words.append(curr_word)&amp;#10;        elif curr_block == &quot;1back_dual_main_click&quot;:&amp;#10;            oneback_paced_durations.append(curr_duration)&amp;#10;            oneback_paced_words.append(curr_word)&amp;#10;        elif curr_block == &quot;2back_dual_main_click&quot;:&amp;#10;            twoback_paced_durations.append(curr_duration)&amp;#10;            twoback_paced_words.append(curr_word)&amp;#10;&amp;#10;        ### IF TESTING MODE ENABLED: end loop after 4 trials&amp;#10;        if expInfo['testing_mode'] == &quot;yes&quot;:&amp;#10;            if trial_idx == 3:&amp;#10;                break&amp;#10;&amp;#10;    print(&quot;finished presenting trials&quot;)&amp;#10;&amp;#10;    # Send end of block trigger:&amp;#10;    # core.wait(time_after_trigger)  # wait 3 ms&amp;#10;    # send block offset trigger&amp;#10;    # send_trigger(&quot;block_offset&quot;)&amp;#10;&amp;#10;    # end current routine&amp;#10;    continueRoutine = False" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="text_blocks" valType="code" updates="None" name="name"/>
      </CodeComponent>
      <CodeComponent name="Q1" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="psychoJS.window.setColor(light_bg_col, {&quot;colorSpace&quot;: &quot;rgb&quot;});&amp;#10;psychoJS.window.flip();&amp;#10;psychoJS.eventManager.clearEvents();&amp;#10;if (skip_questions) {&amp;#10;    continueRoutine = false;&amp;#10;} else {&amp;#10;    if (((skip_questions === false) &amp;&amp; training_Qs)) {&amp;#10;        Q1 = reading_bl_tr_Q1;&amp;#10;        Q1_answers = reading_bl_tr_Q1_ans;&amp;#10;        Q1_corr = reading_bl_tr_Q1_corr;&amp;#10;    } else {&amp;#10;        if (((skip_questions === false) &amp;&amp; (training_Qs === false))) {&amp;#10;            Q1 = locals()[(curr_text_nr + &quot;_Q1&quot;)];&amp;#10;            Q1_answers = locals()[(curr_text_nr + &quot;_Q1_ans&quot;)];&amp;#10;            Q1_corr = locals()[(curr_text_nr + &quot;_Q1_corr&quot;)];&amp;#10;        }&amp;#10;    }&amp;#10;}&amp;#10;question_pos = [0, 3];&amp;#10;answer_xpos = (- 7);&amp;#10;answer_ypos = [0, (- 2), (- 4), (- 6)];&amp;#10;question = new visual.TextStim(psychoJS.window, {&quot;text&quot;: Q1, &quot;pos&quot;: question_pos, &quot;color&quot;: &quot;black&quot;, &quot;height&quot;: 0.5, &quot;font&quot;: &quot;Bookman Old Style&quot;, &quot;anchorHoriz&quot;: &quot;center&quot;, &quot;alignText&quot;: &quot;center&quot;, &quot;wrapWidth&quot;: 10});&amp;#10;answers = function () {&amp;#10;    var _pj_a = [], _pj_b = util.range(Q1_answers.length);&amp;#10;    for (var _pj_c = 0, _pj_d = _pj_b.length; (_pj_c &lt; _pj_d); _pj_c += 1) {&amp;#10;        var i = _pj_b[_pj_c];&amp;#10;        _pj_a.push(new visual.TextStim(psychoJS.window, {&quot;text&quot;: Q1_answers[i], &quot;pos&quot;: [answer_xpos, answer_ypos[i]], &quot;color&quot;: &quot;black&quot;, &quot;height&quot;: 0.5, &quot;font&quot;: &quot;Bookman Old Style&quot;, &quot;wrapWidth&quot;: 15, &quot;anchorHoriz&quot;: &quot;left&quot;, &quot;alignText&quot;: &quot;center&quot;}));&amp;#10;    }&amp;#10;    return _pj_a;&amp;#10;}&amp;#10;.call(this);&amp;#10;instr_text = new visual.TextStim(psychoJS.window, {&quot;text&quot;: &quot;(Bitte benutzen Sie die Tasten 1, 2, 3 und 4 um die richtige Antwort auszuw\u00e4hlen. Mit der Leertaste k\u00f6nnen Sie Ihre Auswahl best\u00e4tigen.)&quot;, &quot;color&quot;: &quot;grey&quot;, &quot;pos&quot;: [0, (- 10)], &quot;wrapWidth&quot;: 20, &quot;height&quot;: 0.4, &quot;font&quot;: &quot;Bookman Old Style&quot;});&amp;#10;question.autoDraw = true;&amp;#10;instr_text.autoDraw = true;&amp;#10;for (var answer, _pj_c = 0, _pj_a = answers, _pj_b = _pj_a.length; (_pj_c &lt; _pj_b); _pj_c += 1) {&amp;#10;    answer = _pj_a[_pj_c];&amp;#10;    answer.autoDraw = true;&amp;#10;}&amp;#10;psychoJS.window.flip();&amp;#10;Q1_chosen_ans = null;&amp;#10;while (true) {&amp;#10;    if (psychoJS.eventManager.getKeys([&quot;1&quot;])) {&amp;#10;        console.log(&quot;a&quot;);&amp;#10;        Q1_chosen_ans = &quot;a&quot;;&amp;#10;        answers[0].setColor(&quot;green&quot;);&amp;#10;        for (var answer, _pj_c = 0, _pj_a = answers.slice(1), _pj_b = _pj_a.length; (_pj_c &lt; _pj_b); _pj_c += 1) {&amp;#10;            answer = _pj_a[_pj_c];&amp;#10;            answer.setColor(&quot;black&quot;);&amp;#10;            psychoJS.window.flip();&amp;#10;        }&amp;#10;    }&amp;#10;    if (psychoJS.eventManager.getKeys([&quot;2&quot;])) {&amp;#10;        console.log(&quot;b&quot;);&amp;#10;        Q1_chosen_ans = &quot;b&quot;;&amp;#10;        answers[1].setColor(&quot;green&quot;);&amp;#10;        for (var answer, _pj_c = 0, _pj_a = ([answers[0]] + answers.slice(2)), _pj_b = _pj_a.length; (_pj_c &lt; _pj_b); _pj_c += 1) {&amp;#10;            answer = _pj_a[_pj_c];&amp;#10;            answer.setColor(&quot;black&quot;);&amp;#10;            psychoJS.window.flip();&amp;#10;        }&amp;#10;    }&amp;#10;    if (psychoJS.eventManager.getKeys([&quot;3&quot;])) {&amp;#10;        console.log(&quot;c&quot;);&amp;#10;        Q1_chosen_ans = &quot;c&quot;;&amp;#10;        answers[2].setColor(&quot;green&quot;);&amp;#10;        for (var answer, _pj_c = 0, _pj_a = (answers.slice(0, 2) + answers.slice(3)), _pj_b = _pj_a.length; (_pj_c &lt; _pj_b); _pj_c += 1) {&amp;#10;            answer = _pj_a[_pj_c];&amp;#10;            answer.setColor(&quot;black&quot;);&amp;#10;        }&amp;#10;        psychoJS.window.flip();&amp;#10;    }&amp;#10;    if (psychoJS.eventManager.getKeys([&quot;4&quot;])) {&amp;#10;        console.log(&quot;d&quot;);&amp;#10;        Q1_chosen_ans = &quot;d&quot;;&amp;#10;        answers[3].setColor(&quot;green&quot;);&amp;#10;        for (var answer, _pj_c = 0, _pj_a = answers.slice(0, (- 1)), _pj_b = _pj_a.length; (_pj_c &lt; _pj_b); _pj_c += 1) {&amp;#10;            answer = _pj_a[_pj_c];&amp;#10;            answer.setColor(&quot;black&quot;);&amp;#10;        }&amp;#10;        psychoJS.window.flip();&amp;#10;    } else {&amp;#10;        if ((psychoJS.eventManager.getKeys([&quot;space&quot;]) &amp;&amp; (Q1_chosen_ans !== null))) {&amp;#10;            break;&amp;#10;        }&amp;#10;    }&amp;#10;}&amp;#10;console.log((&quot;answer for Q1:&quot; + Q1_chosen_ans.toString()));&amp;#10;if ((Q1_chosen_ans === Q1_corr)) {&amp;#10;    console.log(&quot;answer correct!&quot;);&amp;#10;} else {&amp;#10;    console.log(&quot;answer incorrect!&quot;);&amp;#10;}&amp;#10;psychoJS.experiment.addData(&quot;question&quot;, &quot;Q1&quot;);&amp;#10;psychoJS.experiment.addData(&quot;chosen_ans&quot;, Q1_chosen_ans);&amp;#10;psychoJS.experiment.addData(&quot;ans_correct&quot;, (Q1_chosen_ans === Q1_corr));&amp;#10;psychoJS.experiment.addData(&quot;text_nr&quot;, curr_text_nr);&amp;#10;psychoJS.experiment.addData(&quot;block_nr&quot;, exp_block_counter);&amp;#10;psychoJS.experiment.addData(&quot;block_name&quot;, curr_block);&amp;#10;psychoJS.experiment.addData(&quot;block_kind&quot;, curr_nback_cond);&amp;#10;psychoJS.experiment.nextEntry();&amp;#10;question.autoDraw = false;&amp;#10;instr_text.autoDraw = false;&amp;#10;for (var answer, _pj_c = 0, _pj_a = answers, _pj_b = _pj_a.length; (_pj_c &lt; _pj_b); _pj_c += 1) {&amp;#10;    answer = _pj_a[_pj_c];&amp;#10;    answer.autoDraw = false;&amp;#10;}&amp;#10;" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="##########################################################&amp;#10;#            Text Comprehension Questions - Q1           #&amp;#10;##########################################################&amp;#10;&amp;#10;### Settings:&amp;#10;# keep background ivory&amp;#10;win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;win.flip()&amp;#10;&amp;#10;# clear buffer of all previously recorded key events:&amp;#10;event.clearEvents()&amp;#10;&amp;#10;# check which kind of block we have&amp;#10;# if there was no text before, we can skip the questions&amp;#10;if skip_questions:&amp;#10;    continueRoutine = False&amp;#10;# if we have a training text, set training questions&amp;#10;elif skip_questions == False and training_Qs:&amp;#10;    Q1 = reading_bl_tr_Q1&amp;#10;    Q1_answers = reading_bl_tr_Q1_ans&amp;#10;    Q1_corr = reading_bl_tr_Q1_corr&amp;#10;&amp;#10;# if we have a main text, set regular questions&amp;#10;elif skip_questions == False and training_Qs == False:&amp;#10;    # load first question for current text &amp; their respective answers&amp;#10;    Q1 = locals()[curr_text_nr + &quot;_Q1&quot;]&amp;#10;    Q1_answers = locals()[curr_text_nr + &quot;_Q1_ans&quot;]&amp;#10;    Q1_corr = locals()[curr_text_nr + &quot;_Q1_corr&quot;]&amp;#10;&amp;#10;if not skip_questions:&amp;#10;    # Define text positions and formatting&amp;#10;    question_pos = (0, 0.2)&amp;#10;    answer_xpos = -0.75  # move questions a bit to the left&amp;#10;    answer_ypos = [0.1, 0.05, 0, -0.05]  # set the y axis positions of all 4 answers&amp;#10;&amp;#10;    # Create text stim for the question:&amp;#10;    question = visual.TextStim(win,&amp;#10;                               text=Q1,&amp;#10;                               pos=question_pos,&amp;#10;                               color=&quot;black&quot;,&amp;#10;                               height=0.025,  # font height relative to height of screen&amp;#10;                               anchorHoriz='center',&amp;#10;                               alignText='center',&amp;#10;                               wrapWidth=1)&amp;#10;    # create 1 text stim for each answer option:&amp;#10;    answers = [visual.TextStim(win,&amp;#10;                               text=Q1_answers[i],&amp;#10;                               pos=(answer_xpos, answer_ypos[i]),&amp;#10;                               color=&quot;black&quot;,  # set all to black as a default&amp;#10;                               height=0.025,  # font height relative to height of screen&amp;#10;                               wrapWidth=1.5,&amp;#10;                               anchorHoriz='left',&amp;#10;                               alignText='center') for i in range(len(Q1_answers))]&amp;#10;    # set up instruction text&amp;#10;    instr_text = visual.TextStim(win,&amp;#10;                                 text=&quot;(Bitte benutzen Sie die Tasten 1, 2, 3 und 4, um die richtige Antwort auszuwählen. Mit der Leertaste können Sie Ihre Auswahl bestätigen.)&quot;,&amp;#10;                                 color=&quot;grey&quot;,&amp;#10;                                 pos=(0, -0.3),&amp;#10;                                 wrapWidth=2,&amp;#10;                                 height=0.018)  # font height relative to height of screen&amp;#10;&amp;#10;    ### Show all on screen until I set .autoDraw = False&amp;#10;    question.autoDraw = True&amp;#10;    instr_text.autoDraw = True&amp;#10;    for answer in answers:&amp;#10;        answer.autoDraw = True&amp;#10;    win.flip()&amp;#10;&amp;#10;    ### Record key responses:&amp;#10;    Q1_chosen_ans = None&amp;#10;&amp;#10;    while True:&amp;#10;        # if 1 was pressed...&amp;#10;        if defaultKeyboard.getKeys('1'):&amp;#10;            # if event.getKeys(['1']):&amp;#10;            # print('\ta')&amp;#10;            # save Q1 answer as a&amp;#10;            Q1_chosen_ans = &quot;a&quot;&amp;#10;            # set font colour of the first answer (answer a) to&amp;#10;            # green and the rest to black:&amp;#10;            answers[0].setColor(&quot;green&quot;)&amp;#10;            for answer in answers[1:]:&amp;#10;                answer.setColor(&quot;black&quot;)&amp;#10;                # draw updated stimulus:&amp;#10;                win.flip()&amp;#10;        # same procedure for all other answer options:&amp;#10;        if defaultKeyboard.getKeys('2'):&amp;#10;            # if event.getKeys(['2']):&amp;#10;            # print('\tb')&amp;#10;            Q1_chosen_ans = &quot;b&quot;&amp;#10;            # set font colour of the second answer (answer b) to&amp;#10;            # green and the rest to black:&amp;#10;            answers[1].setColor(&quot;green&quot;)&amp;#10;            for answer in [answers[0]] + answers[2:]:&amp;#10;                answer.setColor(&quot;black&quot;)&amp;#10;                # draw updated stimulus:&amp;#10;                win.flip()&amp;#10;        if defaultKeyboard.getKeys('3'):&amp;#10;            # if event.getKeys(['3']):&amp;#10;            # print('\tc')&amp;#10;            Q1_chosen_ans = &quot;c&quot;&amp;#10;            # set font colour of the third answer (answer c) to&amp;#10;            # green and the rest to black:&amp;#10;            answers[2].setColor(&quot;green&quot;)&amp;#10;            for answer in answers[:2] + answers[3:]:&amp;#10;                answer.setColor(&quot;black&quot;)&amp;#10;            # draw updated stimulus:&amp;#10;            win.flip()&amp;#10;        if defaultKeyboard.getKeys('4'):&amp;#10;            # if event.getKeys(['4']):&amp;#10;            # print('\td')&amp;#10;            Q1_chosen_ans = &quot;d&quot;&amp;#10;            # set font colour of the fourth answer (answer d) to&amp;#10;            # green and the rest to black:&amp;#10;            answers[3].setColor(&quot;green&quot;)&amp;#10;            for answer in answers[:-1]:&amp;#10;                answer.setColor(&quot;black&quot;)&amp;#10;            # draw updated stimulus&amp;#10;            win.flip()&amp;#10;        # if participant pressed &quot;space&quot;, check whether they chose an answer.&amp;#10;        # if yes, end this routine and go to next question, if not, wait for valid answer.&amp;#10;        elif defaultKeyboard.getKeys(['space']) and Q1_chosen_ans != None:&amp;#10;            break&amp;#10;&amp;#10;    # print chosen answer for Q1&amp;#10;    print(&quot;answer for Q1 self-paced:&quot; + str(Q1_chosen_ans))&amp;#10;&amp;#10;    # check if answer was correct:&amp;#10;    if Q1_chosen_ans == Q1_corr:&amp;#10;        print(&quot;\tanswer correct!&quot;)&amp;#10;    else:&amp;#10;        print(&quot;\tanswer incorrect!&quot;)&amp;#10;&amp;#10;    # save data:&amp;#10;    thisExp.addData('question', 'Q1')&amp;#10;    thisExp.addData('chosen_ans', Q1_chosen_ans)&amp;#10;    thisExp.addData('ans_correct', Q1_chosen_ans == Q1_corr)&amp;#10;    thisExp.addData('text_nr', curr_text_nr)&amp;#10;    thisExp.addData('block_nr', exp_block_counter)&amp;#10;    thisExp.addData('block_name', curr_block)&amp;#10;    thisExp.addData('block_kind', curr_nback_cond)&amp;#10;&amp;#10;    # start a new row in the csv&amp;#10;    thisExp.nextEntry()&amp;#10;&amp;#10;    ### End Q1: Set .autoDraw = False to stop showing question &amp; answers&amp;#10;    question.autoDraw = False&amp;#10;    instr_text.autoDraw = False&amp;#10;    for answer in answers:&amp;#10;        answer.autoDraw = False&amp;#10;&amp;#10;    # end current routine&amp;#10;    # continueRoutine = False" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="Q1" valType="code" updates="None" name="name"/>
      </CodeComponent>
      <CodeComponent name="Q2" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="##########################################################&amp;#10;#            Text Comprehension Questions - Q2           #&amp;#10;##########################################################&amp;#10;&amp;#10;### Settings:&amp;#10;# keep background ivory&amp;#10;win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;win.flip()&amp;#10;&amp;#10;# clear buffer of all previously recorded key events:&amp;#10;event.clearEvents()&amp;#10;&amp;#10;# check which kind of block we have&amp;#10;# if there was no text before, we can skip the questions&amp;#10;if skip_questions:&amp;#10;    continueRoutine = False&amp;#10;# if we have a training text, set training questions&amp;#10;elif skip_questions == False and training_Qs:&amp;#10;    Q2 = reading_bl_tr_Q2&amp;#10;    Q2_answers = reading_bl_tr_Q2_ans&amp;#10;    Q2_corr = reading_bl_tr_Q2_corr&amp;#10;&amp;#10;# if we have a main text, set regular questions&amp;#10;elif skip_questions == False and training_Qs == False:&amp;#10;    # load first question for current text &amp; their respective answers&amp;#10;    Q2 = locals()[curr_text_nr + &quot;_Q2&quot;]&amp;#10;    Q2_answers = locals()[curr_text_nr + &quot;_Q2_ans&quot;]&amp;#10;    Q2_corr = locals()[curr_text_nr + &quot;_Q2_corr&quot;]&amp;#10;&amp;#10;if not skip_questions:&amp;#10;    # Define text positions and formatting&amp;#10;    question_pos = (0, 0.2)&amp;#10;    answer_xpos = -0.75  # move questions a bit to the left &amp;#10;    answer_ypos = [0.1, 0.05, 0, -0.05]  # set the y axis positions of all 4 answers&amp;#10;&amp;#10;    # Create text stim for the question:&amp;#10;    question = visual.TextStim(win,&amp;#10;                               text=Q2,&amp;#10;                               pos=question_pos,&amp;#10;                               color=&quot;black&quot;,&amp;#10;                               height=0.025,  # font height relative to height of screen&amp;#10;                               anchorHoriz='center',&amp;#10;                               alignText='center',&amp;#10;                               wrapWidth=1)&amp;#10;    # create 1 text stim for each answer option:&amp;#10;    answers = [visual.TextStim(win,&amp;#10;                               text=Q2_answers[i],&amp;#10;                               pos=(answer_xpos, answer_ypos[i]),&amp;#10;                               color=&quot;black&quot;,  # set all to black as a default&amp;#10;                               height=0.025,  # font height relative to height of screen&amp;#10;                               wrapWidth=1.5,&amp;#10;                               anchorHoriz='left',&amp;#10;                               alignText='center') for i in range(len(Q1_answers))]&amp;#10;    # set up instruction text&amp;#10;    instr_text = visual.TextStim(win,&amp;#10;                                 text=&quot;(Bitte benutzen Sie die Tasten 1, 2, 3 und 4, um die richtige Antwort auszuwählen. Mit der Leertaste können Sie Ihre Auswahl bestätigen.)&quot;,&amp;#10;                                 color=&quot;grey&quot;,&amp;#10;                                 pos=(0, -0.3),&amp;#10;                                 wrapWidth=2,&amp;#10;                                 height=0.018)  # font height relative to height of screen&amp;#10;&amp;#10;    ### Show all on screen until I set .autoDraw = False&amp;#10;    question.autoDraw = True&amp;#10;    instr_text.autoDraw = True&amp;#10;    for answer in answers:&amp;#10;        answer.autoDraw = True&amp;#10;    win.flip()&amp;#10;&amp;#10;    ### Record key responses:&amp;#10;    Q2_chosen_ans = None&amp;#10;&amp;#10;    while True:&amp;#10;        # if 1 was pressed...&amp;#10;        if defaultKeyboard.getKeys('1'):&amp;#10;            # if event.getKeys(['1']):&amp;#10;            # print('\ta')&amp;#10;            # save Q1 answer as a &amp;#10;            Q2_chosen_ans = &quot;a&quot;&amp;#10;            # set font colour of the first answer (answer a) to &amp;#10;            # green and the rest to black:&amp;#10;            answers[0].setColor(&quot;green&quot;)&amp;#10;            for answer in answers[1:]:&amp;#10;                answer.setColor(&quot;black&quot;)&amp;#10;                # draw updated stimulus:&amp;#10;                win.flip()&amp;#10;        # same procedure for all other answer options:&amp;#10;        if defaultKeyboard.getKeys('2'):&amp;#10;            # if event.getKeys(['2']):&amp;#10;            # print('\tb')&amp;#10;            Q2_chosen_ans = &quot;b&quot;&amp;#10;            # set font colour of the second answer (answer b) to &amp;#10;            # green and the rest to black:&amp;#10;            answers[1].setColor(&quot;green&quot;)&amp;#10;            for answer in [answers[0]] + answers[2:]:&amp;#10;                answer.setColor(&quot;black&quot;)&amp;#10;                # draw updated stimulus:&amp;#10;                win.flip()&amp;#10;        if defaultKeyboard.getKeys('3'):&amp;#10;            # if event.getKeys(['3']):&amp;#10;            # print('\tc')&amp;#10;            Q2_chosen_ans = &quot;c&quot;&amp;#10;            # set font colour of the third answer (answer c) to &amp;#10;            # green and the rest to black:&amp;#10;            answers[2].setColor(&quot;green&quot;)&amp;#10;            for answer in answers[:2] + answers[3:]:&amp;#10;                answer.setColor(&quot;black&quot;)&amp;#10;            # draw updated stimulus:&amp;#10;            win.flip()&amp;#10;        if defaultKeyboard.getKeys('4'):&amp;#10;            # if event.getKeys(['4']):&amp;#10;            # print('\td')&amp;#10;            Q2_chosen_ans = &quot;d&quot;&amp;#10;            # set font colour of the fourth answer (answer d) to &amp;#10;            # green and the rest to black:&amp;#10;            answers[3].setColor(&quot;green&quot;)&amp;#10;            for answer in answers[:-1]:&amp;#10;                answer.setColor(&quot;black&quot;)&amp;#10;            # draw updated stimulus &amp;#10;            win.flip()&amp;#10;        # if participant pressed &quot;space&quot;, check whether they chose an answer.&amp;#10;        # if yes, end this routine and go to next question, if not, wait for valid answer.&amp;#10;        elif defaultKeyboard.getKeys(['space']) and Q2_chosen_ans != None:&amp;#10;            break&amp;#10;&amp;#10;    # print chosen answer for Q2&amp;#10;    print(&quot;answer for Q2 self-paced:&quot; + str(Q2_chosen_ans))&amp;#10;&amp;#10;    # check if answer was correct:&amp;#10;    if Q2_chosen_ans == Q2_corr:&amp;#10;        print(&quot;\tanswer correct!&quot;)&amp;#10;    else:&amp;#10;        print(&quot;\tanswer incorrect!&quot;)&amp;#10;&amp;#10;    # save data:&amp;#10;    thisExp.addData('question', 'Q2')&amp;#10;    thisExp.addData('chosen_ans', Q2_chosen_ans)&amp;#10;    thisExp.addData('ans_correct', Q2_chosen_ans == Q2_corr)&amp;#10;    thisExp.addData('text_nr', curr_text_nr)&amp;#10;    thisExp.addData('block_nr', exp_block_counter)&amp;#10;    thisExp.addData('block_name', curr_block)&amp;#10;    thisExp.addData('block_kind', curr_nback_cond)&amp;#10;&amp;#10;    # start a new row in the csv&amp;#10;    thisExp.nextEntry()&amp;#10;&amp;#10;    ### End Q2: Set .autoDraw = False to stop showing question &amp; answers&amp;#10;    question.autoDraw = False&amp;#10;    instr_text.autoDraw = False&amp;#10;    for answer in answers:&amp;#10;        answer.autoDraw = False&amp;#10;&amp;#10;    # end current routine&amp;#10;    # continueRoutine = False" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="Q2" valType="code" updates="None" name="name"/>
      </CodeComponent>
      <CodeComponent name="Q3" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="##########################################################&amp;#10;#            Text Comprehension Questions - Q3           #&amp;#10;##########################################################&amp;#10;&amp;#10;### Settings:&amp;#10;# keep background ivory&amp;#10;win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;win.flip()&amp;#10;&amp;#10;# clear buffer of all previously recorded key events:&amp;#10;event.clearEvents()&amp;#10;&amp;#10;# check which kind of block we have&amp;#10;# if there was no text before, we can skip the questions&amp;#10;if skip_questions:&amp;#10;    continueRoutine = False&amp;#10;# if we have a training text, set training questions&amp;#10;elif skip_questions == False and training_Qs:&amp;#10;    Q3 = reading_bl_tr_Q3&amp;#10;    Q3_answers = reading_bl_tr_Q3_ans&amp;#10;    Q3_corr = reading_bl_tr_Q3_corr&amp;#10;    &amp;#10;# if we have a main text, set regular questions&amp;#10;elif skip_questions == False and training_Qs == False:&amp;#10;    # load first question for current text &amp; their respective answers&amp;#10;    Q3 = locals()[curr_text_nr + &quot;_Q3&quot;]&amp;#10;    Q3_answers = locals()[curr_text_nr + &quot;_Q3_ans&quot;]&amp;#10;    Q3_corr = locals()[curr_text_nr + &quot;_Q3_corr&quot;]&amp;#10;&amp;#10;# Define text positions and formatting&amp;#10;question_pos = (0, 3)&amp;#10;answer_xpos = -7 # move questions a bit to the left &amp;#10;answer_ypos = [ 0, -2, -4, -6] # set the y axis positions of all 4 answers&amp;#10;&amp;#10;# Create text stim for the question:&amp;#10;question = visual.TextStim(win, &amp;#10;                           text = Q3, &amp;#10;                           pos = question_pos,&amp;#10;                           color = &quot;black&quot;,&amp;#10;                           height = 0.5,&amp;#10;                           font = &quot;Bookman Old Style&quot;,&amp;#10;                           anchorHoriz = 'center',&amp;#10;                           alignText = 'center', &amp;#10;                           wrapWidth = 10)&amp;#10;# create 1 text stim for each answer option:&amp;#10;answers = [visual.TextStim(win, &amp;#10;                           text = Q3_answers[i], &amp;#10;                           pos = (answer_xpos, answer_ypos[i]), &amp;#10;                           color = &quot;black&quot;, # set all to black as a default&amp;#10;                           height = 0.5, &amp;#10;                           font = &quot;Bookman Old Style&quot;,&amp;#10;                           wrapWidth = 15,&amp;#10;                           anchorHoriz = 'left', &amp;#10;                           alignText = 'center') for i in range(len(Q3_answers))]&amp;#10;# set up instruction text&amp;#10;instr_text = visual.TextStim(win, &amp;#10;                             text = &quot;(Bitte benutzen Sie die Tasten 1, 2, 3 und 4 um die richtige Antwort auszuwählen. Mit der Leertaste können Sie Ihre Auswahl bestätigen.)&quot;,&amp;#10;                             color = &quot;grey&quot;,&amp;#10;                             pos = (0, -10),&amp;#10;                             wrapWidth = 20,&amp;#10;                             height = 0.4,&amp;#10;                             font = &quot;Bookman Old Style&quot;)&amp;#10;                             &amp;#10;### Show all on screen until I set .autoDraw = False&amp;#10;question.autoDraw = True&amp;#10;instr_text.autoDraw = True&amp;#10;for answer in answers:&amp;#10;    answer.autoDraw = True&amp;#10;win.flip()&amp;#10;&amp;#10;&amp;#10;### Record key responses:&amp;#10;Q3_chosen_ans = None&amp;#10;&amp;#10;while True:        &amp;#10;    # if 1 was pressed...&amp;#10;    if event.getKeys(['1']):&amp;#10;        print('a')&amp;#10;        # save Q3 answer as a &amp;#10;        Q3_chosen_ans = &quot;a&quot;&amp;#10;        # set font colour of the first answer (answer a) to &amp;#10;        # green and the rest to black:&amp;#10;        answers[0].setColor(&quot;green&quot;)&amp;#10;        for answer in answers[1:]:&amp;#10;            answer.setColor(&quot;black&quot;)&amp;#10;            # draw updated stimulus:&amp;#10;            win.flip()&amp;#10;    # same procedure for all other answer options:&amp;#10;    if event.getKeys(['2']):&amp;#10;        print('b')&amp;#10;        Q3_chosen_ans = &quot;b&quot;&amp;#10;        # set font colour of the second answer (answer b) to &amp;#10;        # green and the rest to black:&amp;#10;        answers[1].setColor(&quot;green&quot;)&amp;#10;        for answer in [answers[0]] + answers[2:]:&amp;#10;            answer.setColor(&quot;black&quot;)&amp;#10;            # draw updated stimulus:&amp;#10;            win.flip()&amp;#10;    if event.getKeys(['3']):&amp;#10;        print('c')&amp;#10;        Q3_chosen_ans = &quot;c&quot;&amp;#10;        # set font colour of the third answer (answer c) to &amp;#10;        # green and the rest to black:&amp;#10;        answers[2].setColor(&quot;green&quot;)&amp;#10;        for answer in answers[:2] + answers[3:]:&amp;#10;            answer.setColor(&quot;black&quot;)&amp;#10;        # draw updated stimulus:&amp;#10;        win.flip()&amp;#10;    if event.getKeys(['4']):&amp;#10;        print('d')&amp;#10;        Q3_chosen_ans = &quot;d&quot;&amp;#10;        # set font colour of the fourth answer (answer d) to &amp;#10;        # green and the rest to black:&amp;#10;        answers[3].setColor(&quot;green&quot;)&amp;#10;        for answer in answers[:-1]:&amp;#10;            answer.setColor(&quot;black&quot;)&amp;#10;        # draw updated stimulus &amp;#10;        win.flip()&amp;#10;    # if participant pressed &quot;space&quot;, check whether they chose an answer.&amp;#10;    # if yes, end this routine and go to next question, if not, wait for valid answer.&amp;#10;    elif event.getKeys(['space']) and Q3_chosen_ans != None:&amp;#10;        break&amp;#10;&amp;#10;# print chosen answer for Q3&amp;#10;print(&quot;answer for Q3:&quot; + str(Q3_chosen_ans))&amp;#10;&amp;#10;# check if answer was correct:&amp;#10;if Q3_chosen_ans == Q3_corr: &amp;#10;    print(&quot;answer correct!&quot;)&amp;#10;else: &amp;#10;    print(&quot;answer incorrect!&quot;)&amp;#10;    &amp;#10;# save data:&amp;#10;thisExp.addData('question', 'Q3')&amp;#10;thisExp.addData('chosen_ans', Q3_chosen_ans)&amp;#10;thisExp.addData('ans_correct', Q3_chosen_ans == Q3_corr)&amp;#10;thisExp.addData('text_nr', curr_text_nr)&amp;#10;thisExp.addData('block_nr', exp_block_counter)&amp;#10;thisExp.addData('block_name', curr_block)&amp;#10;thisExp.addData('block_kind', curr_nback_cond)&amp;#10;&amp;#10;# start a new row in the csv&amp;#10;thisExp.nextEntry()&amp;#10;&amp;#10;### End Q3: Set .autoDraw = False to stop showing question &amp; answers&amp;#10;question.autoDraw = False&amp;#10;instr_text.autoDraw = False&amp;#10;for answer in answers:&amp;#10;    answer.autoDraw = False&amp;#10;&amp;#10;# go to next block!&amp;#10;exp_block_counter += 1&amp;#10;print(&quot;Going to block &quot; + str(exp_block_counter + 1) + &quot;/17 now!&quot;)&amp;#10;continueRoutine = False&amp;#10;&amp;#10;# If there are still blocks left, go to next one.&amp;#10;# If not, end loop here:&amp;#10;if exp_block_counter == 17:&amp;#10;    blocks.finished = True&amp;#10;&amp;#10;# when text rating is included, only use this instead of &quot;go to next block&quot;:&amp;#10;# end current routine&amp;#10;#continueRoutine = False" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="##########################################################&amp;#10;#            Text Comprehension Questions - Q3           #&amp;#10;##########################################################&amp;#10;&amp;#10;### Settings:&amp;#10;# keep background ivory&amp;#10;win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;win.flip()&amp;#10;&amp;#10;# clear buffer of all previously recorded key events:&amp;#10;event.clearEvents()&amp;#10;&amp;#10;# check which kind of block we have&amp;#10;# if there was no text before, we can skip the questions&amp;#10;if skip_questions:&amp;#10;    continueRoutine = False&amp;#10;# if we have a training text, set training questions&amp;#10;elif skip_questions == False and training_Qs:&amp;#10;    Q3 = reading_bl_tr_Q3&amp;#10;    Q3_answers = reading_bl_tr_Q3_ans&amp;#10;    Q3_corr = reading_bl_tr_Q3_corr&amp;#10;&amp;#10;# if we have a main text, set regular questions&amp;#10;elif skip_questions == False and training_Qs == False:&amp;#10;    # load first question for current text &amp; their respective answers&amp;#10;    Q3 = locals()[curr_text_nr + &quot;_Q3&quot;]&amp;#10;    Q3_answers = locals()[curr_text_nr + &quot;_Q3_ans&quot;]&amp;#10;    Q3_corr = locals()[curr_text_nr + &quot;_Q3_corr&quot;]&amp;#10;&amp;#10;if not skip_questions:&amp;#10;    # Define text positions and formatting&amp;#10;    question_pos = (0, 0.2)&amp;#10;    answer_xpos = -0.75  # move questions a bit to the left &amp;#10;    answer_ypos = [0.1, 0.05, 0, -0.05]  # set the y axis positions of all 4 answers&amp;#10;&amp;#10;    # Create text stim for the question:&amp;#10;    question = visual.TextStim(win,&amp;#10;                               text=Q3,&amp;#10;                               pos=question_pos,&amp;#10;                               color=&quot;black&quot;,&amp;#10;                               height=0.025,  # font height relative to height of screen&amp;#10;                               anchorHoriz='center',&amp;#10;                               alignText='center',&amp;#10;                               wrapWidth=1)&amp;#10;    # create 1 text stim for each answer option:&amp;#10;    answers = [visual.TextStim(win,&amp;#10;                               text=Q3_answers[i],&amp;#10;                               pos=(answer_xpos, answer_ypos[i]),&amp;#10;                               color=&quot;black&quot;,  # set all to black as a default&amp;#10;                               height=0.025,  # font height relative to height of screen&amp;#10;                               wrapWidth=1.5,&amp;#10;                               anchorHoriz='left',&amp;#10;                               alignText='center') for i in range(len(Q1_answers))]&amp;#10;    # set up instruction text&amp;#10;    instr_text = visual.TextStim(win,&amp;#10;                                 text=&quot;(Bitte benutzen Sie die Tasten 1, 2, 3 und 4, um die richtige Antwort auszuwählen. Mit der Leertaste können Sie Ihre Auswahl bestätigen.)&quot;,&amp;#10;                                 color=&quot;grey&quot;,&amp;#10;                                 pos=(0, -0.3),&amp;#10;                                 wrapWidth=2,&amp;#10;                                 height=0.018)  # font height relative to height of screen&amp;#10;&amp;#10;    ### Show all on screen until I set .autoDraw = False&amp;#10;    question.autoDraw = True&amp;#10;    instr_text.autoDraw = True&amp;#10;    for answer in answers:&amp;#10;        answer.autoDraw = True&amp;#10;    win.flip()&amp;#10;&amp;#10;    ### Record key responses:&amp;#10;    Q3_chosen_ans = None&amp;#10;&amp;#10;    while True:&amp;#10;        # if 1 was pressed...&amp;#10;        if defaultKeyboard.getKeys('1'):&amp;#10;            # if event.getKeys(['1']):&amp;#10;            # print('\ta')&amp;#10;            # save Q1 answer as a &amp;#10;            Q3_chosen_ans = &quot;a&quot;&amp;#10;            # set font colour of the first answer (answer a) to &amp;#10;            # green and the rest to black:&amp;#10;            answers[0].setColor(&quot;green&quot;)&amp;#10;            for answer in answers[1:]:&amp;#10;                answer.setColor(&quot;black&quot;)&amp;#10;                # draw updated stimulus:&amp;#10;                win.flip()&amp;#10;        # same procedure for all other answer options:&amp;#10;        if defaultKeyboard.getKeys('2'):&amp;#10;            # if event.getKeys(['2']):&amp;#10;            # print('\tb')&amp;#10;            Q3_chosen_ans = &quot;b&quot;&amp;#10;            # set font colour of the second answer (answer b) to &amp;#10;            # green and the rest to black:&amp;#10;            answers[1].setColor(&quot;green&quot;)&amp;#10;            for answer in [answers[0]] + answers[2:]:&amp;#10;                answer.setColor(&quot;black&quot;)&amp;#10;                # draw updated stimulus:&amp;#10;                win.flip()&amp;#10;        if defaultKeyboard.getKeys('3'):&amp;#10;            # if event.getKeys(['3']):&amp;#10;            # print('\tc')&amp;#10;            Q3_chosen_ans = &quot;c&quot;&amp;#10;            # set font colour of the third answer (answer c) to &amp;#10;            # green and the rest to black:&amp;#10;            answers[2].setColor(&quot;green&quot;)&amp;#10;            for answer in answers[:2] + answers[3:]:&amp;#10;                answer.setColor(&quot;black&quot;)&amp;#10;            # draw updated stimulus:&amp;#10;            win.flip()&amp;#10;        if defaultKeyboard.getKeys('4'):&amp;#10;            # if event.getKeys(['4']):&amp;#10;            # print('\td')&amp;#10;            Q3_chosen_ans = &quot;d&quot;&amp;#10;            # set font colour of the fourth answer (answer d) to &amp;#10;            # green and the rest to black:&amp;#10;            answers[3].setColor(&quot;green&quot;)&amp;#10;            for answer in answers[:-1]:&amp;#10;                answer.setColor(&quot;black&quot;)&amp;#10;            # draw updated stimulus &amp;#10;            win.flip()&amp;#10;        # if participant pressed &quot;space&quot;, check whether they chose an answer.&amp;#10;        # if yes, end this routine and go to next question, if not, wait for valid answer.&amp;#10;        elif defaultKeyboard.getKeys(['space']) and Q3_chosen_ans != None:&amp;#10;            break&amp;#10;&amp;#10;    # print chosen answer for Q3&amp;#10;    print(&quot;answer for Q3 self-paced:&quot; + str(Q3_chosen_ans))&amp;#10;&amp;#10;    # check if answer was correct:&amp;#10;    if Q3_chosen_ans == Q3_corr:&amp;#10;        print(&quot;\tanswer correct!&quot;)&amp;#10;    else:&amp;#10;        print(&quot;\tanswer incorrect!&quot;)&amp;#10;&amp;#10;    # save data:&amp;#10;    thisExp.addData('question', 'Q3')&amp;#10;    thisExp.addData('chosen_ans', Q3_chosen_ans)&amp;#10;    thisExp.addData('ans_correct', Q3_chosen_ans == Q3_corr)&amp;#10;    thisExp.addData('text_nr', curr_text_nr)&amp;#10;    thisExp.addData('block_nr', exp_block_counter)&amp;#10;    thisExp.addData('block_name', curr_block)&amp;#10;    thisExp.addData('block_kind', curr_nback_cond)&amp;#10;&amp;#10;    # start a new row in the csv&amp;#10;    thisExp.nextEntry()&amp;#10;&amp;#10;    ### End Q3: Set .autoDraw = False to stop showing question &amp; answers&amp;#10;    question.autoDraw = False&amp;#10;    instr_text.autoDraw = False&amp;#10;    for answer in answers:&amp;#10;        answer.autoDraw = False&amp;#10;&amp;#10;    # go to next block!&amp;#10;    exp_block_counter += 1&amp;#10;    print(f&quot;Going to block {exp_block_counter + 1}/15 now!&quot;)&amp;#10;    continueRoutine = False&amp;#10;&amp;#10;    # If there are still blocks left, go to next one.&amp;#10;    # If not, end loop here:&amp;#10;    if exp_block_counter == 15:&amp;#10;        blocks.finished = True&amp;#10;&amp;#10;    # when text rating is included, only use this instead of &quot;go to next block&quot;:&amp;#10;    # end current routine&amp;#10;    # continueRoutine = False" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="Q3" valType="code" updates="None" name="name"/>
      </CodeComponent>
    </Routine>
    <Routine name="no_text_training">
      <RoutineSettingsComponent name="no_text_training" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="True" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="no_text_training" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <CodeComponent name="no_text_and_training_2" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="/* Syntax Error: Fix Python code */" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="#################################################&amp;#10;#                Blocks w/o text                #&amp;#10;#################################################&amp;#10;# this routine is for all blocks where there are&amp;#10;# coloured rectangles instead of words&amp;#10;&amp;#10;# the non-text blocks all come in succession, there's just 1 main block in between them.&amp;#10;# So use loop here that runs the non-text blocks&amp;#10;# until we have to display a main text block (in this case we exit the routine).&amp;#10;&amp;#10;while True:&amp;#10;    event. Mouse(visible=False)&amp;#10;    # keep background ivory&amp;#10;    win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;    win.flip()&amp;#10;&amp;#10;    # clear buffer of all previously recorded key events:&amp;#10;    event.clearEvents()&amp;#10;&amp;#10;    ### specify settings for the current block&amp;#10;&amp;#10;    ### Prepare stimuli:&amp;#10;&amp;#10;    # get block kind&amp;#10;    curr_block = all_blocks[exp_block_counter]&amp;#10;    # print(&quot;start preparing block &quot; + curr_block)&amp;#10;&amp;#10;    # Check whether it's one of the non-text tasks.&amp;#10;    # If current block is a text block, skip this routine and go to the next.&amp;#10;    if curr_block not in [&quot;click_training&quot;, &quot;1back_single_training1&quot;, &quot;1back_single_training2&quot;,&amp;#10;                          &quot;2back_single_training1&quot;, &quot;2back_single_training2&quot;]:&amp;#10;        print(f&quot;this is block {curr_block}&quot;)&amp;#10;        print(f&quot;\tskipping n-back routine&quot;)&amp;#10;        break&amp;#10;&amp;#10;    # if it's one of the non-text blocks, though, prepare stimuli:&amp;#10;    else:&amp;#10;        print(f&quot;this is block {curr_block}&quot;)&amp;#10;        print(f&quot;\tstart preparing block {curr_block}&quot;)&amp;#10;        # print(&quot;\t&quot; + curr_block + &quot; is not a text block - preparing rect as stim now&quot;)&amp;#10;&amp;#10;        # keep background ivory&amp;#10;        win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;        win.flip()&amp;#10;&amp;#10;        ### Show instructions&amp;#10;        # set instruction text&amp;#10;        instr_text = locals()[&quot;instr_&quot; + curr_block]&amp;#10;        # create text box&amp;#10;        instr_text_stim = visual.TextStim(win,&amp;#10;                                          text=instr_text,&amp;#10;                                          height=0.025,  # font height relative to height of screen&amp;#10;                                          pos=(0, 0.2),  # move up a bit&amp;#10;                                          color=&quot;black&quot;)&amp;#10;        # create ImageStim object&amp;#10;        curr_instr_pic = visual.ImageStim(win,&amp;#10;                                          size=(0.8, 0.3),&amp;#10;                                          pos=(0, -0.2),&amp;#10;                                          image=locals()[&quot;instr_pic_&quot; + curr_block])  # set path to image here&amp;#10;&amp;#10;        # display the text &amp; image on screen&amp;#10;        if curr_block in [&quot;1back_single_training2&quot;, &quot;2back_single_training2&quot;]:&amp;#10;&amp;#10;            # draw instructions on screen&amp;#10;            instr_text_stim.draw()&amp;#10;            curr_instr_pic.draw()&amp;#10;            win.flip()&amp;#10;            core.wait(3)  # wait for 3 s before starting response window&amp;#10;&amp;#10;            while True:&amp;#10;                instr_text_stim.draw()&amp;#10;                curr_instr_pic.draw()&amp;#10;                win.flip()&amp;#10;                # skip current block (aka the second training block))&amp;#10;                if event.getKeys(['space']):&amp;#10;                    print(&quot;\t\tstart next block - skip second training block&quot;)&amp;#10;                    skip_curr_block = True&amp;#10;                    break&amp;#10;                # repeat training (aka run current block, which is the second training block)&amp;#10;                elif event.getKeys(['w']):&amp;#10;                    print(&quot;\t\trepeat training block&quot;)&amp;#10;                    skip_curr_block = False&amp;#10;                    break&amp;#10;        # for regular blocks that can't be repeated:&amp;#10;        else:&amp;#10;            while True:&amp;#10;                instr_text_stim.draw()&amp;#10;                curr_instr_pic.draw()&amp;#10;                win.flip()&amp;#10;                # start current block&amp;#10;                if event.getKeys(['space']):&amp;#10;                    print(&quot;\t\tstart current block&quot;)&amp;#10;                    skip_curr_block = False&amp;#10;                    break&amp;#10;&amp;#10;        # only run this if the current block shall not be skipped:&amp;#10;        if skip_curr_block == False:&amp;#10;            ### change background colour&amp;#10;            win.setColor(dark_bg_col, colorSpace='rgb')&amp;#10;            win.flip()&amp;#10;&amp;#10;            # don't show questions&amp;#10;            skip_questions = True&amp;#10;            training_Qs = False&amp;#10;&amp;#10;            # get n-back condition:&amp;#10;            curr_nback_cond = curr_block[0]  # get first character of block name&amp;#10;&amp;#10;            # if it is a 1 or a 2, set that as current n-back level:&amp;#10;            if curr_nback_cond in ['1', '2']:&amp;#10;                curr_nback_cond == int(curr_nback_cond)&amp;#10;            # if it's neither 1 nor 2, it has to be a block without n-back,&amp;#10;            # so set curr_nback_cond to None&amp;#10;            else:&amp;#10;                curr_nback_cond = None&amp;#10;&amp;#10;            print(f&quot;\tcurrent n-back condition: {curr_nback_cond}&quot;)&amp;#10;&amp;#10;            # get list with targets &amp; list with colours&amp;#10;            curr_targets = all_target_lists[exp_block_counter]&amp;#10;            curr_colours = all_colour_lists[exp_block_counter]&amp;#10;            # for current text nr, get text whose name = current text nr&amp;#10;            curr_text = locals()[curr_text_nr]&amp;#10;&amp;#10;            ### Start block loop&amp;#10;&amp;#10;            # CREATE CLOCKS:&amp;#10;            my_block_clock = core.Clock()&amp;#10;            my_block_clock.reset()  # start block clock&amp;#10;            start_time = my_block_clock.getTime()  # get start time of block&amp;#10;            # also create trial clock&amp;#10;            my_trial_clock = core.Clock()&amp;#10;&amp;#10;            # create empty stimulus&amp;#10;            stim = visual.Rect(win=win,&amp;#10;                               width=0.4,  # width = 3 * 1° visual angle (to make it look rectangle-ish)&amp;#10;                               height=0.15,  # height = 1° visual angle (just like words)&amp;#10;                               # colorSpace = &quot;hex&quot;,&amp;#10;                               pos=(0, 0))  # center stimulus&amp;#10;&amp;#10;            stim.draw()&amp;#10;            win.flip()&amp;#10;&amp;#10;            # clear buffer of all previously recorded key events:&amp;#10;            event.clearEvents()&amp;#10;&amp;#10;            # loop colours in current text&amp;#10;            for trial_idx, curr_col in enumerate(curr_colours):&amp;#10;                # print(&quot;current idx: &quot; + str(trial_idx) + &quot;, curr colour:&quot; + curr_col)&amp;#10;&amp;#10;                ### prepare &amp; show current word:&amp;#10;                my_trial_clock.reset()  # start trial clock&amp;#10;                onset_time = my_trial_clock.getTime()&amp;#10;&amp;#10;                # if it's a block with an n-back task, prepare target list&amp;#10;                if curr_nback_cond != None:&amp;#10;                    curr_target = curr_targets[trial_idx]&amp;#10;                    saw_target = False&amp;#10;&amp;#10;                # get trial number (start counting from 1, so add 1)&amp;#10;                curr_trial_nr = trial_idx + 1&amp;#10;&amp;#10;                ### ISI: wait for 200 ms&amp;#10;                while my_trial_clock.getTime() &lt; 0.2:&amp;#10;                    win.flip()  # don't draw anything&amp;#10;                    core.wait(0.005)  # wait 5 ms before next iteration&amp;#10;&amp;#10;                # set current colour as colour of rectangle&amp;#10;                stim.fillColor = curr_col&amp;#10;&amp;#10;                # draw stimulus on screen&amp;#10;                stim.draw()&amp;#10;                win.flip()&amp;#10;&amp;#10;                # show stimulus on screen &amp; send trigger:&amp;#10;                stim.draw()  # draw stimulus on screen&amp;#10;                # update the window to clear the screen and display&amp;#10;                # the stimulus&amp;#10;&amp;#10;                # start trial clock for measuring RTs from stimulus onset&amp;#10;                my_trial_clock.reset()&amp;#10;&amp;#10;                # onset_time = my_trial_clock.getTime()&amp;#10;&amp;#10;                ### wait for key response:&amp;#10;                # In blocks with n-back task, participants can press &quot;c&quot; to indicate they saw a target colour and &quot;space&quot; to go to the next word/stimulus.&amp;#10;                # In blocks without n-back task, participants can only press &quot;space&quot; to go to the next stimulus.&amp;#10;                # print(&quot;start tracking key responses&quot;)&amp;#10;&amp;#10;                ### start recording responses&amp;#10;                # start &quot;endless&quot; while loop that looks for responses&amp;#10;                # in each iteration, draw word on screen&amp;#10;                continue_trial = True&amp;#10;                while continue_trial:&amp;#10;&amp;#10;                    # draw stimulus on screen&amp;#10;                    stim.draw()&amp;#10;                    win.flip()&amp;#10;&amp;#10;                    # check for responses:&amp;#10;                    keys = event.getKeys(['space', 'c', 'escape'])&amp;#10;&amp;#10;                    # check if there was a response. If there wasn't, we can go straight&amp;#10;                    # to the next iteration which will hopefully save us some dropped&amp;#10;                    # frames in the flicker.&amp;#10;                    for key in keys:&amp;#10;&amp;#10;                        # if participant pressed the space bar on their keyboard...&amp;#10;                        if key == 'space':&amp;#10;                            # get reaction time&amp;#10;                            curr_duration = my_trial_clock.getTime() * 1000&amp;#10;                            # send trigger for response:&amp;#10;                            # send_trigger(&quot;response_continue&quot;)&amp;#10;&amp;#10;                            # break while loop to go to next trial&amp;#10;                            continue_trial = False&amp;#10;&amp;#10;                        # if participant pressed button &quot;c&quot; for the first time and it's an n-back condition&amp;#10;                        # where they're actually supposed to do that (aka not a reading baseline condition)...&amp;#10;                        elif key == 'c' and curr_nback_cond != None and saw_target == False:&amp;#10;                            # get reaction time&amp;#10;                            curr_nback_RT = my_trial_clock.getTime() * 1000&amp;#10;&amp;#10;                            # send trigger for response:&amp;#10;                            # send_trigger(&quot;response_target&quot;)&amp;#10;&amp;#10;                            # only get first target response, we don't care if they press the button more than once:&amp;#10;                            saw_target = True&amp;#10;&amp;#10;                        # If esc is pressed, end the experiment:&amp;#10;                        elif key == 'escape':&amp;#10;                            # et_abort_exp()  # shut down eyetrigger and download incremental data&amp;#10;                            # make sure parallel port line is cleared&amp;#10;                            # core.wait(time_after_trigger)&amp;#10;                            # parallel.setData(0)&amp;#10;                            core.wait(0.5)&amp;#10;                            # end experiment&amp;#10;                            core.quit()&amp;#10;&amp;#10;                ### end trial&amp;#10;                # print(&quot;end trial&quot;)&amp;#10;&amp;#10;                # check whether response was hit, miss, false alarm or correct rejection&amp;#10;                # they saw a target and there was one: hit&amp;#10;                if curr_nback_cond != None:&amp;#10;                    if saw_target and curr_target:&amp;#10;                        curr_nback_response = &quot;hit&quot;&amp;#10;                    # they didn't see a target but there was one: miss&amp;#10;                    elif saw_target == False and curr_target:&amp;#10;                        curr_nback_response = &quot;miss&quot;&amp;#10;                        curr_nback_RT = None&amp;#10;                    # they didn't see a target and there was none: correct rejection&amp;#10;                    elif saw_target == False and curr_target == False:&amp;#10;                        curr_nback_response = &quot;correct rejection&quot;&amp;#10;                        curr_nback_RT = None&amp;#10;                    # they saw a target but there was none: false alarm&amp;#10;                    elif saw_target and curr_target == False:&amp;#10;                        curr_nback_response = &quot;false alarm&quot;&amp;#10;                # if it wasn't an n-back task block:&amp;#10;                else:&amp;#10;                    curr_target = None&amp;#10;                    curr_nback_response = None&amp;#10;                    curr_nback_RT = None&amp;#10;&amp;#10;                ### save everything in output csv&amp;#10;                thisExp.addData('colour', curr_colour)&amp;#10;                thisExp.addData('target', curr_target)&amp;#10;                thisExp.addData('nback_response', curr_nback_response)&amp;#10;                thisExp.addData('nback_RT', curr_nback_RT)  # in ms&amp;#10;                thisExp.addData('duration', curr_duration)  # in ms&amp;#10;                thisExp.addData('trial_nr', curr_trial_nr)&amp;#10;                thisExp.addData('block_nr', exp_block_counter)&amp;#10;                thisExp.addData('block_name', curr_block)&amp;#10;                thisExp.addData('block_kind', curr_nback_cond)&amp;#10;&amp;#10;                # start a new row in the csv&amp;#10;                thisExp.nextEntry()&amp;#10;&amp;#10;                ### IF TESTING MODE ENABLED: end loop after 4 trials&amp;#10;                if expInfo['testing_mode'] == &quot;yes&quot;:&amp;#10;                    if trial_idx == 3:&amp;#10;                        break&amp;#10;&amp;#10;            print(&quot;\t\tfinished presenting trials&quot;)&amp;#10;&amp;#10;            # change background colour from grey (RGB: 10, 10, 10)&amp;#10;            # to ivory (RGB: 240, 223, 204)&amp;#10;            win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;            win.flip()&amp;#10;&amp;#10;        # add 1 to the block counter to go load the next block&amp;#10;        exp_block_counter = exp_block_counter + 1&amp;#10;        print(f&quot;\tGoing to block {exp_block_counter + 1}/13 now!&quot;)&amp;#10;&amp;#10;# go to next routine&amp;#10;# print(&quot;going to next routine&quot;)&amp;#10;continueRoutine = False" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="no_text_and_training_2" valType="code" updates="None" name="name"/>
      </CodeComponent>
    </Routine>
    <Routine name="Questions">
      <RoutineSettingsComponent name="Questions" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="Questions" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <CodeComponent name="Q1_self_paced" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="##########################################################&amp;#10;#            Text Comprehension Questions - Q3           #&amp;#10;##########################################################&amp;#10;&amp;#10;### Settings:&amp;#10;# keep background ivory&amp;#10;win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;win.flip()&amp;#10;&amp;#10;# clear buffer of all previously recorded key events:&amp;#10;event.clearEvents()&amp;#10;&amp;#10;# check which kind of block we have&amp;#10;# if there was no text before, we can skip the questions&amp;#10;if skip_questions:&amp;#10;    continueRoutine = False&amp;#10;# if we have a training text, set training questions&amp;#10;elif skip_questions == False and training_Qs:&amp;#10;    Q3 = reading_bl_tr_Q3&amp;#10;    Q3_answers = reading_bl_tr_Q3_ans&amp;#10;    Q3_corr = reading_bl_tr_Q3_corr&amp;#10;    &amp;#10;# if we have a main text, set regular questions&amp;#10;elif skip_questions == False and training_Qs == False:&amp;#10;    # load first question for current text &amp; their respective answers&amp;#10;    Q3 = locals()[curr_text_nr + &quot;_Q3&quot;]&amp;#10;    Q3_answers = locals()[curr_text_nr + &quot;_Q3_ans&quot;]&amp;#10;    Q3_corr = locals()[curr_text_nr + &quot;_Q3_corr&quot;]&amp;#10;&amp;#10;# Define text positions and formatting&amp;#10;question_pos = (0, 3)&amp;#10;answer_xpos = -7 # move questions a bit to the left &amp;#10;answer_ypos = [ 0, -2, -4, -6] # set the y axis positions of all 4 answers&amp;#10;&amp;#10;# Create text stim for the question:&amp;#10;question = visual.TextStim(win, &amp;#10;                           text = Q3, &amp;#10;                           pos = question_pos,&amp;#10;                           color = &quot;black&quot;,&amp;#10;                           height = 0.5,&amp;#10;                           font = &quot;Bookman Old Style&quot;,&amp;#10;                           anchorHoriz = 'center',&amp;#10;                           alignText = 'center', &amp;#10;                           wrapWidth = 10)&amp;#10;# create 1 text stim for each answer option:&amp;#10;answers = [visual.TextStim(win, &amp;#10;                           text = Q3_answers[i], &amp;#10;                           pos = (answer_xpos, answer_ypos[i]), &amp;#10;                           color = &quot;black&quot;, # set all to black as a default&amp;#10;                           height = 0.5, &amp;#10;                           font = &quot;Bookman Old Style&quot;,&amp;#10;                           wrapWidth = 15,&amp;#10;                           anchorHoriz = 'left', &amp;#10;                           alignText = 'center') for i in range(len(Q3_answers))]&amp;#10;# set up instruction text&amp;#10;instr_text = visual.TextStim(win, &amp;#10;                             text = &quot;(Bitte benutzen Sie die Tasten 1, 2, 3 und 4 um die richtige Antwort auszuwählen. Mit der Leertaste können Sie Ihre Auswahl bestätigen.)&quot;,&amp;#10;                             color = &quot;grey&quot;,&amp;#10;                             pos = (0, -10),&amp;#10;                             wrapWidth = 20,&amp;#10;                             height = 0.4,&amp;#10;                             font = &quot;Bookman Old Style&quot;)&amp;#10;                             &amp;#10;### Show all on screen until I set .autoDraw = False&amp;#10;question.autoDraw = True&amp;#10;instr_text.autoDraw = True&amp;#10;for answer in answers:&amp;#10;    answer.autoDraw = True&amp;#10;win.flip()&amp;#10;&amp;#10;&amp;#10;### Record key responses:&amp;#10;Q3_chosen_ans = None&amp;#10;&amp;#10;while True:        &amp;#10;    # if 1 was pressed...&amp;#10;    if event.getKeys(['1']):&amp;#10;        print('\ta')&amp;#10;        # save Q3 answer as a &amp;#10;        Q3_chosen_ans = &quot;a&quot;&amp;#10;        # set font colour of the first answer (answer a) to &amp;#10;        # green and the rest to black:&amp;#10;        answers[0].setColor(&quot;green&quot;)&amp;#10;        for answer in answers[1:]:&amp;#10;            answer.setColor(&quot;black&quot;)&amp;#10;            # draw updated stimulus:&amp;#10;            win.flip()&amp;#10;    # same procedure for all other answer options:&amp;#10;    if event.getKeys(['2']):&amp;#10;        print('\tb')&amp;#10;        Q3_chosen_ans = &quot;b&quot;&amp;#10;        # set font colour of the second answer (answer b) to &amp;#10;        # green and the rest to black:&amp;#10;        answers[1].setColor(&quot;green&quot;)&amp;#10;        for answer in [answers[0]] + answers[2:]:&amp;#10;            answer.setColor(&quot;black&quot;)&amp;#10;            # draw updated stimulus:&amp;#10;            win.flip()&amp;#10;    if event.getKeys(['3']):&amp;#10;        print('\tc')&amp;#10;        Q3_chosen_ans = &quot;c&quot;&amp;#10;        # set font colour of the third answer (answer c) to &amp;#10;        # green and the rest to black:&amp;#10;        answers[2].setColor(&quot;green&quot;)&amp;#10;        for answer in answers[:2] + answers[3:]:&amp;#10;            answer.setColor(&quot;black&quot;)&amp;#10;        # draw updated stimulus:&amp;#10;        win.flip()&amp;#10;    if event.getKeys(['4']):&amp;#10;        print('\td')&amp;#10;        Q3_chosen_ans = &quot;d&quot;&amp;#10;        # set font colour of the fourth answer (answer d) to &amp;#10;        # green and the rest to black:&amp;#10;        answers[3].setColor(&quot;green&quot;)&amp;#10;        for answer in answers[:-1]:&amp;#10;            answer.setColor(&quot;black&quot;)&amp;#10;        # draw updated stimulus &amp;#10;        win.flip()&amp;#10;    # if participant pressed &quot;space&quot;, check whether they chose an answer.&amp;#10;    # if yes, end this routine and go to next question, if not, wait for valid answer.&amp;#10;    elif event.getKeys(['space']) and Q3_chosen_ans != None:&amp;#10;        break&amp;#10;&amp;#10;# print chosen answer for Q3&amp;#10;print(&quot;answer for Q3:&quot; + str(Q3_chosen_ans))&amp;#10;&amp;#10;# check if answer was correct:&amp;#10;if Q3_chosen_ans == Q3_corr: &amp;#10;    print(&quot;\tanswer correct!&quot;)&amp;#10;else: &amp;#10;    print(&quot;\tanswer incorrect!&quot;)&amp;#10;    &amp;#10;# save data:&amp;#10;thisExp.addData('question', 'Q3')&amp;#10;thisExp.addData('chosen_ans', Q3_chosen_ans)&amp;#10;thisExp.addData('ans_correct', Q3_chosen_ans == Q3_corr)&amp;#10;thisExp.addData('text_nr', curr_text_nr)&amp;#10;thisExp.addData('block_nr', exp_block_counter)&amp;#10;thisExp.addData('block_name', curr_block)&amp;#10;thisExp.addData('block_kind', curr_nback_cond)&amp;#10;&amp;#10;# start a new row in the csv&amp;#10;thisExp.nextEntry()&amp;#10;&amp;#10;### End Q3: Set .autoDraw = False to stop showing question &amp; answers&amp;#10;question.autoDraw = False&amp;#10;instr_text.autoDraw = False&amp;#10;for answer in answers:&amp;#10;    answer.autoDraw = False&amp;#10;&amp;#10;# go to next block!&amp;#10;exp_block_counter += 1&amp;#10;print(&quot;Going to block &quot; + str(exp_block_counter + 1) + &quot;/16 now!&quot;)&amp;#10;continueRoutine = False&amp;#10;&amp;#10;# If there are still blocks left, go to next one.&amp;#10;# If not, end loop here:&amp;#10;if exp_block_counter == 16:&amp;#10;    blocks.finished = True&amp;#10;&amp;#10;# when text rating is included, only use this instead of &quot;go to next block&quot;:&amp;#10;# end current routine&amp;#10;#continueRoutine = False" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="##########################################################&amp;#10;#            Text Comprehension Questions - Q3           #&amp;#10;##########################################################&amp;#10;&amp;#10;### Settings:&amp;#10;# keep background ivory&amp;#10;win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;win.flip()&amp;#10;&amp;#10;# clear buffer of all previously recorded key events:&amp;#10;event.clearEvents()&amp;#10;&amp;#10;# check which kind of block we have&amp;#10;# if there was no text before, we can skip the questions&amp;#10;if skip_questions:&amp;#10;    continueRoutine = False&amp;#10;# if we have a training text, set training questions&amp;#10;elif skip_questions == False and training_Qs:&amp;#10;    Q3 = reading_bl_tr_Q3&amp;#10;    Q3_answers = reading_bl_tr_Q3_ans&amp;#10;    Q3_corr = reading_bl_tr_Q3_corr&amp;#10;    &amp;#10;# if we have a main text, set regular questions&amp;#10;elif skip_questions == False and training_Qs == False:&amp;#10;    # load first question for current text &amp; their respective answers&amp;#10;    Q3 = locals()[curr_text_nr + &quot;_Q3&quot;]&amp;#10;    Q3_answers = locals()[curr_text_nr + &quot;_Q3_ans&quot;]&amp;#10;    Q3_corr = locals()[curr_text_nr + &quot;_Q3_corr&quot;]&amp;#10;&amp;#10;if not skip_questions:&amp;#10;    # Define text positions and formatting&amp;#10;    question_pos = (0, 3)&amp;#10;    answer_xpos = -7 # move questions a bit to the left &amp;#10;    answer_ypos = [ 0, -2, -4, -6] # set the y axis positions of all 4 answers&amp;#10;&amp;#10;    # Create text stim for the question:&amp;#10;    question = visual.TextStim(win, &amp;#10;                               text = Q3, &amp;#10;                               pos = question_pos,&amp;#10;                               color = &quot;black&quot;,&amp;#10;                               height = 0.5,&amp;#10;                               font = &quot;Bookman Old Style&quot;,&amp;#10;                               anchorHoriz = 'center',&amp;#10;                               alignText = 'center', &amp;#10;                               wrapWidth = 10)&amp;#10;    # create 1 text stim for each answer option:&amp;#10;    answers = [visual.TextStim(win, &amp;#10;                               text = Q3_answers[i], &amp;#10;                               pos = (answer_xpos, answer_ypos[i]), &amp;#10;                               color = &quot;black&quot;, # set all to black as a default&amp;#10;                               height = 0.5, &amp;#10;                               font = &quot;Bookman Old Style&quot;,&amp;#10;                               wrapWidth = 15,&amp;#10;                               anchorHoriz = 'left', &amp;#10;                               alignText = 'center') for i in range(len(Q3_answers))]&amp;#10;    # set up instruction text&amp;#10;    instr_text = visual.TextStim(win, &amp;#10;                                 text = &quot;(Bitte benutzen Sie die Tasten 1, 2, 3 und 4 um die richtige Antwort auszuwählen. Mit der Leertaste können Sie Ihre Auswahl bestätigen.)&quot;,&amp;#10;                                 color = &quot;grey&quot;,&amp;#10;                                 pos = (0, -10),&amp;#10;                                 wrapWidth = 20,&amp;#10;                                 height = 0.4,&amp;#10;                                 font = &quot;Bookman Old Style&quot;)&amp;#10;                                 &amp;#10;    ### Show all on screen until I set .autoDraw = False&amp;#10;    question.autoDraw = True&amp;#10;    instr_text.autoDraw = True&amp;#10;    for answer in answers:&amp;#10;        answer.autoDraw = True&amp;#10;    win.flip()&amp;#10;&amp;#10;&amp;#10;    ### Record key responses:&amp;#10;    Q3_chosen_ans = None&amp;#10;&amp;#10;    while True:        &amp;#10;        # if 1 was pressed...&amp;#10;        if event.getKeys(['1']):&amp;#10;            print('\ta')&amp;#10;            # save Q3 answer as a &amp;#10;            Q3_chosen_ans = &quot;a&quot;&amp;#10;            # set font colour of the first answer (answer a) to &amp;#10;            # green and the rest to black:&amp;#10;            answers[0].setColor(&quot;green&quot;)&amp;#10;            for answer in answers[1:]:&amp;#10;                answer.setColor(&quot;black&quot;)&amp;#10;                # draw updated stimulus:&amp;#10;                win.flip()&amp;#10;        # same procedure for all other answer options:&amp;#10;        if event.getKeys(['2']):&amp;#10;            print('\tb')&amp;#10;            Q3_chosen_ans = &quot;b&quot;&amp;#10;            # set font colour of the second answer (answer b) to &amp;#10;            # green and the rest to black:&amp;#10;            answers[1].setColor(&quot;green&quot;)&amp;#10;            for answer in [answers[0]] + answers[2:]:&amp;#10;                answer.setColor(&quot;black&quot;)&amp;#10;                # draw updated stimulus:&amp;#10;                win.flip()&amp;#10;        if event.getKeys(['3']):&amp;#10;            print('\tc')&amp;#10;            Q3_chosen_ans = &quot;c&quot;&amp;#10;            # set font colour of the third answer (answer c) to &amp;#10;            # green and the rest to black:&amp;#10;            answers[2].setColor(&quot;green&quot;)&amp;#10;            for answer in answers[:2] + answers[3:]:&amp;#10;                answer.setColor(&quot;black&quot;)&amp;#10;            # draw updated stimulus:&amp;#10;            win.flip()&amp;#10;        if event.getKeys(['4']):&amp;#10;            print('\td')&amp;#10;            Q3_chosen_ans = &quot;d&quot;&amp;#10;            # set font colour of the fourth answer (answer d) to &amp;#10;            # green and the rest to black:&amp;#10;            answers[3].setColor(&quot;green&quot;)&amp;#10;            for answer in answers[:-1]:&amp;#10;                answer.setColor(&quot;black&quot;)&amp;#10;            # draw updated stimulus &amp;#10;            win.flip()&amp;#10;        # if participant pressed &quot;space&quot;, check whether they chose an answer.&amp;#10;        # if yes, end this routine and go to next question, if not, wait for valid answer.&amp;#10;        elif event.getKeys(['space']) and Q3_chosen_ans != None:&amp;#10;            break&amp;#10;&amp;#10;    # print chosen answer for Q3&amp;#10;    print(&quot;answer for Q3:&quot; + str(Q3_chosen_ans))&amp;#10;&amp;#10;    # check if answer was correct:&amp;#10;    if Q3_chosen_ans == Q3_corr: &amp;#10;        print(&quot;\tanswer correct!&quot;)&amp;#10;    else: &amp;#10;        print(&quot;\tanswer incorrect!&quot;)&amp;#10;        &amp;#10;    # save data:&amp;#10;    thisExp.addData('question', 'Q3')&amp;#10;    thisExp.addData('chosen_ans', Q3_chosen_ans)&amp;#10;    thisExp.addData('ans_correct', Q3_chosen_ans == Q3_corr)&amp;#10;    thisExp.addData('text_nr', curr_text_nr)&amp;#10;    thisExp.addData('block_nr', exp_block_counter)&amp;#10;    thisExp.addData('block_name', curr_block)&amp;#10;    thisExp.addData('block_kind', curr_nback_cond)&amp;#10;&amp;#10;    # start a new row in the csv&amp;#10;    thisExp.nextEntry()&amp;#10;&amp;#10;    ### End Q3: Set .autoDraw = False to stop showing question &amp; answers&amp;#10;    question.autoDraw = False&amp;#10;    instr_text.autoDraw = False&amp;#10;    for answer in answers:&amp;#10;        answer.autoDraw = False&amp;#10;&amp;#10;    # go to next block!&amp;#10;    exp_block_counter += 1&amp;#10;    print(&quot;Going to block &quot; + str(exp_block_counter + 1) + &quot;/16 now!&quot;)&amp;#10;    continueRoutine = False&amp;#10;&amp;#10;    # If there are still blocks left, go to next one.&amp;#10;    # If not, end loop here:&amp;#10;    if exp_block_counter == 16:&amp;#10;        blocks.finished = True&amp;#10;&amp;#10;# when text rating is included, only use this instead of &quot;go to next block&quot;:&amp;#10;# end current routine&amp;#10;#continueRoutine = False" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="True" valType="bool" updates="None" name="disabled"/>
        <Param val="Q1_self_paced" valType="code" updates="None" name="name"/>
      </CodeComponent>
    </Routine>
    <Routine name="warning_task_change">
      <RoutineSettingsComponent name="warning_task_change" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="warning_task_change" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <CodeComponent name="warning_sign" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="### Show warning sign if task changes&amp;#10;&amp;#10;# If task in last block (curr_block) is not the same as the next one, show warning.&amp;#10;&amp;#10;# To check this, we compare the first letter in the block names.&amp;#10;# I won't show a warning if it switches from rectangles to words,&amp;#10;# I think people will notice it's different.&amp;#10;&amp;#10;if exp_block_counter &lt; 16: # if there are still blocks left&amp;#10;    if curr_block[0] != all_blocks[exp_block_counter][0]:&amp;#10;&amp;#10;        # create ImageStim object&amp;#10;        curr_instr_pic = visual.ImageStim(win, &amp;#10;                                      size = (10, 10),&amp;#10;                                      pos = (0, 0),&amp;#10;                                      image = warning_sign) # set path to image here&amp;#10;&amp;#10;        # draw image on screen&amp;#10;        curr_instr_pic.draw()&amp;#10;        win.flip()&amp;#10;&amp;#10;        # Wait for 4 seconds&amp;#10;        core.wait(4)&amp;#10;        win.flip()&amp;#10;else: print(&quot;task in current block&quot;, curr_block, &quot;is the same as in next block - skipping warning sign!&quot;)&amp;#10;&amp;#10;# go to next slide&amp;#10;continueRoutine = False" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="True" valType="bool" updates="None" name="disabled"/>
        <Param val="warning_sign" valType="code" updates="None" name="name"/>
      </CodeComponent>
    </Routine>
    <Routine name="text_blocks_paced">
      <RoutineSettingsComponent name="text_blocks_paced" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="True" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="text_blocks_paced" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <CodeComponent name="paced_blocks" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="#################################################&amp;#10;#            Blocks with text – paced           #&amp;#10;#################################################&amp;#10;# this routine is for all blocks with texts that are paced, i.e., visually presented without space bar&amp;#10;&amp;#10;#---------- Calculate duration of words based on previous block ----------&amp;#10;# We collected RTs &amp; words from the self-paced block of each condition&amp;#10;# for the training, we only use data from the reading BL since there is no separate training for 1- and 2-back&amp;#10;&amp;#10;# we calculate letter duration based on condition since participants need more time for n-back tasks than for baseline reading&amp;#10;# BL reading blocks are based on duration during self-paced BL reading&amp;#10;# 1- and 2-back blocks are based on their respective self-paced version&amp;#10;&amp;#10;# get block kind&amp;#10;curr_block = all_blocks[exp_block_counter]&amp;#10;&amp;#10;if curr_block in [&quot;Reading_Baseline_main_no_click&quot;, &quot;Reading_Baseline_training_no_click&quot;]:&amp;#10;&amp;#10;    # exclude all RTs where participant was way too fast (&lt; 50 ms) or&amp;#10;    # way too slow (&gt; 2s), also remove the corresponding words from vis_task_words&amp;#10;    print(&quot;\tBL_paced_durations:&quot;, BL_paced_durations)&amp;#10;    print(&quot;\tBL_paced_words:&quot;, BL_paced_words)&amp;#10;&amp;#10;    filtered_durations_BL = []&amp;#10;    filtered_words_BL = []&amp;#10;    for duration, word in zip(BL_paced_durations, BL_paced_words):&amp;#10;        if 50 &lt;= duration &lt;= 1500:&amp;#10;            filtered_durations_BL.append(duration)&amp;#10;            filtered_words_BL.append(word)&amp;#10;    # print(&quot;\tfiltered_durations_BL:&quot;, filtered_durations_BL)&amp;#10;    # print(&quot;\tfiltered_words_BL:&quot;, filtered_words_BL)&amp;#10;&amp;#10;    # Now get number of letters (not words, I want to know how fast they read 1 letter on average!):&amp;#10;    letters_total_BL = sum(len(word) for word in filtered_words_BL)&amp;#10;    print(&quot;\tletters_total_BL:&quot;, letters_total_BL)&amp;#10;    # also get time it took in total to read them all:&amp;#10;    reading_time_total_BL = sum(filtered_durations_BL)  # in ms&amp;#10;&amp;#10;    # Now check how many words / min they read on average.&amp;#10;    # reading_speed_wpm = words_total / (reading_time_total/60000)&amp;#10;    # print(&quot;reading speed in words / min:&quot; + str(reading_speed_wpm))&amp;#10;&amp;#10;    # Check average RT / letter&amp;#10;    RT_per_letter_baseline = reading_time_total_BL / letters_total_BL&amp;#10;    print(&quot;\taverage RT per letter in ms:&quot;, RT_per_letter_baseline)&amp;#10;&amp;#10;    # save this in the output csv:&amp;#10;    thisExp.addData('RT_per_letter_baseline', RT_per_letter_baseline)&amp;#10;&amp;#10;elif curr_block in [&quot;1back_dual_main_no_click&quot;]:&amp;#10;&amp;#10;    # exclude all RTs where participant was way too fast (&lt; 50 ms) or&amp;#10;    # way too slow (&gt; 2s), also remove the corresponding words from vis_task_words&amp;#10;    print(&quot;\t1back_paced_durations:&quot;, oneback_paced_durations)&amp;#10;    print(&quot;\t1back_paced_words:&quot;, oneback_paced_words)&amp;#10;&amp;#10;    filtered_durations_1bck = []&amp;#10;    filtered_words_1bck = []&amp;#10;    for duration, word in zip(oneback_paced_durations, oneback_paced_words):&amp;#10;        if 50 &lt;= duration &lt;= 2000:&amp;#10;            filtered_durations_1bck.append(duration)&amp;#10;            filtered_words_1bck.append(word)&amp;#10;    # print(&quot;\tfiltered_durations_1bck:&quot;, filtered_durations_1bck)&amp;#10;    # print(&quot;\tfiltered_words_1bck:&quot;, filtered_words_1bck)&amp;#10;&amp;#10;    # Now get number of letters (not words, I want to know how fast they read 1 letter on average!):&amp;#10;    letters_total_1bck = sum(len(word) for word in filtered_words_1bck)&amp;#10;    print(&quot;\tletters_total_1bck:&quot;, letters_total_1bck)&amp;#10;    # also get time it took in total to read them all:&amp;#10;    reading_time_total_1bck = sum(filtered_durations_1bck)  # in ms&amp;#10;&amp;#10;    # Now check how many words / min they read on average.&amp;#10;    # reading_speed_wpm = words_total / (reading_time_total/60000)&amp;#10;    # print(&quot;reading speed in words / min:&quot; + str(reading_speed_wpm))&amp;#10;&amp;#10;    # Check average RT / letter&amp;#10;    RT_per_letter_1bck = reading_time_total_1bck / letters_total_1bck&amp;#10;    print(&quot;\taverage RT per letter in ms:&quot;, RT_per_letter_1bck)&amp;#10;&amp;#10;    # save this in the output csv:&amp;#10;    thisExp.addData('RT_per_letter_1bck', RT_per_letter_1bck)&amp;#10;&amp;#10;elif curr_block in [&quot;2back_dual_main_no_click&quot;]:&amp;#10;&amp;#10;    # exclude all RTs where participant was way too fast (&lt; 50 ms) or&amp;#10;    # way too slow (&gt; 2s), also remove the corresponding words from vis_task_words&amp;#10;    print(&quot;\t2back_paced_durations:&quot;, twoback_paced_durations)&amp;#10;    print(&quot;\t2back_paced_words:&quot;, twoback_paced_words)&amp;#10;&amp;#10;    filtered_durations_2bck = []&amp;#10;    filtered_words_2bck = []&amp;#10;    for duration, word in zip(twoback_paced_durations, twoback_paced_words):&amp;#10;        if 50 &lt;= duration &lt;= 2500:&amp;#10;            filtered_durations_2bck.append(duration)&amp;#10;            filtered_words_2bck.append(word)&amp;#10;    # print(&quot;\tfiltered_durations_2bck:&quot;, filtered_durations_2bck)&amp;#10;    # print(&quot;\tfiltered_words_2bck:&quot;, filtered_words_2bck)&amp;#10;&amp;#10;    # Now get number of letters (not words, I want to know how fast they read 1 letter on average!):&amp;#10;    letters_total_2bck = sum(len(word) for word in filtered_words_2bck)&amp;#10;    print(&quot;\tletters_total_2bck:&quot;, letters_total_2bck)&amp;#10;    # also get time it took in total to read them all:&amp;#10;    reading_time_total_2bck = sum(filtered_durations_2bck)  # in ms&amp;#10;&amp;#10;    # Now check how many words / min they read on average.&amp;#10;    # reading_speed_wpm = words_total / (reading_time_total/60000)&amp;#10;    # print(&quot;reading speed in words / min:&quot; + str(reading_speed_wpm))&amp;#10;&amp;#10;    # Check average RT / letter&amp;#10;    RT_per_letter_2bck = reading_time_total_2bck / letters_total_2bck&amp;#10;    print(&quot;\taverage RT per letter in ms:&quot;, RT_per_letter_2bck)&amp;#10;&amp;#10;    # save this in the output csv:&amp;#10;    thisExp.addData('RT_per_letter_2bck', RT_per_letter_2bck)&amp;#10;&amp;#10;# keep background ivory&amp;#10;win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;win.flip()&amp;#10;&amp;#10;# ----------------------------------&amp;#10;&amp;#10;# clear buffer of all previously recorded key events:&amp;#10;event.clearEvents()&amp;#10;&amp;#10;### specify settings for the current block&amp;#10;&amp;#10;### Prepare stimuli:&amp;#10;&amp;#10;# get block kind&amp;#10;curr_block = all_blocks[exp_block_counter]&amp;#10;# print(&quot;start preparing block &quot; + curr_block)&amp;#10;&amp;#10;# Check whether it's a block that is self-paced&amp;#10;# Also, if current block is a non-text block, skip this routine.&amp;#10;if curr_block in [&quot;click_training&quot;, &quot;1back_single_training1&quot;, &quot;1back_single_training2&quot;,&amp;#10;                  &quot;2back_single_training1&quot;, &quot;2back_single_training2&quot;,&amp;#10;                  &quot;Reading_Baseline_main_click&quot;, &quot;1back_dual_main_click&quot;, &quot;2back_dual_main_click&quot;, &quot;Reading_Baseline_training_click&quot;]:&amp;#10;    print(f&quot;this is block {curr_block}&quot;)&amp;#10;    print(&quot;\tskipping paced routine&quot;)&amp;#10;    # skip questions &amp; end current routine&amp;#10;    skip_questions_paced = True&amp;#10;    continueRoutine = False&amp;#10;    # break&amp;#10;&amp;#10;# if it's the paced reading training block, prepare training stimuli:&amp;#10;elif curr_block == &quot;Reading_Baseline_training_no_click&quot;:&amp;#10;    print(f&quot;start preparing block {curr_block}&quot;)&amp;#10;&amp;#10;    # keep background ivory&amp;#10;    win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;    win.flip()&amp;#10;&amp;#10;    ### Show instructions&amp;#10;    # set instruction text&amp;#10;    instr_text = locals()[&quot;instr_&quot; + curr_block]&amp;#10;    # create text box&amp;#10;    instr_text_stim = visual.TextStim(win,&amp;#10;                                      text=instr_text,&amp;#10;                                      height=0.025,  # font height relative to height of screen&amp;#10;                                      pos=(0, 0),  # move up a bit&amp;#10;                                      color=&quot;black&quot;)&amp;#10;&amp;#10;    # show instructions on screen&amp;#10;    win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;    instr_text_stim.draw()&amp;#10;    win.flip()&amp;#10;    core.wait(3)  # wait for 3s before starting response window&amp;#10;&amp;#10;    # display the text on screen&amp;#10;    while True:&amp;#10;        # keep background ivory&amp;#10;        win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;        instr_text_stim.draw()&amp;#10;        win.flip()&amp;#10;        # end showing screen if participant presses space&amp;#10;        if 'space' in event.getKeys():&amp;#10;            break&amp;#10;&amp;#10;    # clear buffer of all previously recorded key events:&amp;#10;    event.clearEvents()&amp;#10;&amp;#10;    ### get training text&amp;#10;    curr_text_training = reading_bl_tr_text_no_click&amp;#10;    curr_text_nr = &quot;Reading_Baseline_training_no_click&quot;&amp;#10;    curr_text = curr_text_training&amp;#10;    curr_nback_cond = None&amp;#10;    # show training questions&amp;#10;    skip_questions_paced = False&amp;#10;    training_Qs_paced = True&amp;#10;&amp;#10;    # get list with targets &amp; list with colours&amp;#10;    curr_targets = all_target_lists[exp_block_counter]&amp;#10;    curr_colours = all_colour_lists[exp_block_counter]&amp;#10;&amp;#10;    # compute RTs using participant's average reading speed / letter – old, based on linear increase of RTs,&amp;#10;    # feels very unnatural however&amp;#10;    # curr_durations = [len(word) * RT_per_letter_baseline for word in curr_text]  # in ms&amp;#10;&amp;#10;    # compute RTs using participant's average reading speed / letter&amp;#10;    # we define a minimum and a maximum duration for each word&amp;#10;    # the minimum is based on 5 x RT per letter in the respective condition&amp;#10;    # the max duration is based on a time-out of 1.5 s in the reading baseline condition&amp;#10;    minimum_duration = 5 * RT_per_letter_baseline&amp;#10;    maximum_duration = 1500&amp;#10;    curr_durations = []&amp;#10;    for word in curr_text:&amp;#10;        # this is an absolute value based on estimates of how long you need to feel comfortable reading a word on&amp;#10;        # screen in a paced task&amp;#10;        # duration = RT_per_letter_baseline * math.log((len(word))) + 300&amp;#10;        # more flexible solution:&amp;#10;        duration = RT_per_letter_baseline * math.log((len(word))) + 4 * RT_per_letter_baseline&amp;#10;        if duration &lt; maximum_duration:&amp;#10;            curr_durations.append(max(duration, minimum_duration))&amp;#10;        else:&amp;#10;            curr_durations.append(maximum_duration)&amp;#10;&amp;#10;    print(f&quot;\tdurations for paced task training block: {curr_durations}&quot;)&amp;#10;&amp;#10;    # we also need the start time (let's set it as current time&amp;#10;    # at this point in the script):&amp;#10;    start_time = core.getTime()&amp;#10;&amp;#10;    ### change background colour&amp;#10;    win.setColor(dark_bg_col, colorSpace='rgb')&amp;#10;    win.flip()&amp;#10;&amp;#10;# if it's one of the &quot;normal&quot; main blocks, prepare main block stimuli:&amp;#10;elif curr_block in [&quot;Reading_Baseline_main_no_click&quot;, &quot;1back_dual_main_no_click&quot;, &quot;2back_dual_main_no_click&quot;]:&amp;#10;    print(f&quot;start preparing block {curr_block}&quot;)&amp;#10;&amp;#10;    # keep background ivory&amp;#10;    win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;    win.flip()&amp;#10;&amp;#10;    ### Show instructions&amp;#10;    # only add image, if it's a 1- or 2-back block where participants have to press &quot;c&quot;&amp;#10;    if curr_block == &quot;Reading_Baseline_main_no_click&quot;:&amp;#10;&amp;#10;        # set instruction text&amp;#10;        instr_text = locals()[&quot;instr_&quot; + curr_block]&amp;#10;        # create text box&amp;#10;        instr_text_stim = visual.TextStim(win,&amp;#10;                                          text=instr_text,&amp;#10;                                          height=0.025,  # font height relative to height of screen&amp;#10;                                          pos=(0, 0),  # move up a bit&amp;#10;                                          color=&quot;black&quot;)&amp;#10;&amp;#10;        # show instructions on screen&amp;#10;        win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;        instr_text_stim.draw()&amp;#10;        win.flip()&amp;#10;        core.wait(3)  # wait for 3s before starting response window&amp;#10;&amp;#10;        # Display the text on screen&amp;#10;        while True:&amp;#10;            instr_text_stim.draw()&amp;#10;            win.flip()&amp;#10;            # end showing screen if participant presses space&amp;#10;            if 'space' in event.getKeys():&amp;#10;                break&amp;#10;&amp;#10;        # get text nr:&amp;#10;        curr_text_nr = all_texts_nrs_list[exp_block_counter]&amp;#10;        curr_text = locals()[curr_text_nr]&amp;#10;&amp;#10;        # compute RTs using participant's average reading speed / letter – old, based on linear increase of RTs,&amp;#10;        # feels very unnatural however&amp;#10;        # curr_durations = [len(word) * RT_per_letter_baseline for word in curr_text]  # in ms&amp;#10;&amp;#10;        # compute RTs using participant's average reading speed / letter&amp;#10;        # we define a minimum and a maximum duration for each word&amp;#10;        # the minimum is based on 5 x RT per letter in the respective condition&amp;#10;        # the max duration is based on a time-out of 1.5 s in the reading baseline condition&amp;#10;        minimum_duration = 5 * RT_per_letter_baseline&amp;#10;        maximum_duration = 1500&amp;#10;        curr_durations = []&amp;#10;        for word in curr_text:&amp;#10;            # this is an absolute value based on estimates of how long you need to feel comfortable reading a word on&amp;#10;            # screen in a paced task&amp;#10;            # duration = RT_per_letter_baseline * math.log((len(word))) + 300&amp;#10;            # more flexible solution:&amp;#10;            duration = RT_per_letter_baseline * math.log((len(word))) + 4 * RT_per_letter_baseline&amp;#10;            if duration &lt; maximum_duration:&amp;#10;                curr_durations.append(max(duration, minimum_duration))&amp;#10;            else:&amp;#10;                curr_durations.append(maximum_duration)&amp;#10;&amp;#10;        print(f&quot;\tdurations for paced baseline block: {curr_durations}&quot;)&amp;#10;&amp;#10;        ### change background colour&amp;#10;        win.setColor(dark_bg_col, colorSpace='rgb')&amp;#10;        win.flip()&amp;#10;&amp;#10;    elif curr_block in [&quot;1back_dual_main_no_click&quot;, &quot;2back_dual_main_no_click&quot;]:&amp;#10;&amp;#10;        # set instruction text&amp;#10;        instr_text = locals()[&quot;instr_&quot; + curr_block]&amp;#10;        # create text box&amp;#10;        instr_text_stim = visual.TextStim(win,&amp;#10;                                          text=instr_text,&amp;#10;                                          height=0.025,  # font height relative to height of screen&amp;#10;                                          pos=(0, 0.2),  # move up a bit&amp;#10;                                          color=&quot;black&quot;)&amp;#10;        # create ImageStim object&amp;#10;        curr_instr_pic = visual.ImageStim(win,&amp;#10;                                          size=(0.8, 0.3),&amp;#10;                                          pos=(0, -0.2),&amp;#10;                                          image=locals()[&quot;instr_pic_&quot; + curr_block])  # set path to image here&amp;#10;&amp;#10;        # show instructions on screen&amp;#10;        win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;        instr_text_stim.draw()&amp;#10;        curr_instr_pic.draw()&amp;#10;        win.flip()&amp;#10;        core.wait(3)  # wait for 3s before starting response window&amp;#10;&amp;#10;        # Display the text on screen&amp;#10;        while True:&amp;#10;            instr_text_stim.draw()&amp;#10;            curr_instr_pic.draw()&amp;#10;            win.flip()&amp;#10;            # end showing screen if participant presses space&amp;#10;            if 'space' in event.getKeys():&amp;#10;                break&amp;#10;&amp;#10;        # get text nr:&amp;#10;        curr_text_nr = all_texts_nrs_list[exp_block_counter]&amp;#10;        curr_text = locals()[curr_text_nr]&amp;#10;        # compute RTs using participant's average reading speed / letter&amp;#10;        if curr_block == &quot;1back_dual_main_no_click&quot;:&amp;#10;            # curr_durations = [len(word) * RT_per_letter_1bck for word in curr_text]  # in ms&amp;#10;&amp;#10;            # compute RTs using participant's average reading speed / letter&amp;#10;            # we define a minimum and a maximum duration for each word&amp;#10;            # the minimum is based on 5 x RT per letter in the respective condition&amp;#10;            # the max duration is based on a time-out of 2 s in the 1-back condition&amp;#10;            minimum_duration = 5 * RT_per_letter_1bck&amp;#10;            maximum_duration = 2000&amp;#10;            curr_durations = []&amp;#10;            for word in curr_text:&amp;#10;                # this is an absolute value based on estimates of how long you need to feel comfortable reading a&amp;#10;                # word on screen in a paced task&amp;#10;                # duration = RT_per_letter_baseline * math.log((len(word))) + 300 more&amp;#10;                # more flexible solution:&amp;#10;                duration = RT_per_letter_1bck * math.log((len(word))) + 4 * RT_per_letter_1bck&amp;#10;                if duration &lt; maximum_duration:&amp;#10;                    curr_durations.append(max(duration, minimum_duration))&amp;#10;                else:&amp;#10;                    curr_durations.append(maximum_duration)&amp;#10;&amp;#10;            # Latency factor of an incremental increase (increment per trial = 3 ms) added over duration of entire&amp;#10;            # block assuming that participants get tired of the course of a 300 words block and thus need a bit more&amp;#10;            # time:&amp;#10;            # Increment of 3 ms per trial&amp;#10;            increment_per_trial = 3&amp;#10;            for i in range(len(curr_durations)):&amp;#10;                # Calculate incremental increase for current trial&amp;#10;                increment = i * increment_per_trial&amp;#10;                # Add incremental increase to current trial's duration&amp;#10;                curr_durations[i] += increment&amp;#10;&amp;#10;        elif curr_block == &quot;2back_dual_main_no_click&quot;:&amp;#10;            minimum_duration = 5 * RT_per_letter_2bck&amp;#10;            maximum_duration = 2000&amp;#10;            curr_durations = []&amp;#10;            for word in curr_text:&amp;#10;                # this is an absolute value based on estimates of how long you need to feel comfortable reading a word on&amp;#10;                # screen in a paced task&amp;#10;                # duration = RT_per_letter_baseline * math.log((len(word))) + 300&amp;#10;                # more flexible solution:&amp;#10;                duration = RT_per_letter_2bck * math.log((len(word))) + 4 * RT_per_letter_2bck&amp;#10;                if duration &lt; maximum_duration:&amp;#10;                    curr_durations.append(max(duration, minimum_duration))&amp;#10;                else:&amp;#10;                    curr_durations.append(maximum_duration)&amp;#10;&amp;#10;            # Add increment of 3 ms per trial&amp;#10;            increment_per_trial = 3&amp;#10;            for i in range(len(curr_durations)):&amp;#10;                # Calculate incremental increase for current trial&amp;#10;                increment = i * increment_per_trial&amp;#10;                # Add incremental increase to current trial's duration&amp;#10;                curr_durations[i] += increment&amp;#10;&amp;#10;        print(f&quot;\tdurations for paced n-back block: {curr_durations}&quot;)&amp;#10;&amp;#10;        ### change background colour&amp;#10;        win.setColor(dark_bg_col, colorSpace='rgb')&amp;#10;        win.flip()&amp;#10;&amp;#10;    # show main block questions&amp;#10;    skip_questions_paced = False&amp;#10;    training_Qs_paced = False&amp;#10;&amp;#10;    # get n-back condition:&amp;#10;    curr_nback_cond = curr_block[0]  # get first character of block name&amp;#10;&amp;#10;    # if it is a 1 or a 2, set that as current n-back level:&amp;#10;    if curr_nback_cond in ['1', '2']:&amp;#10;        curr_nback_cond == int(curr_nback_cond)&amp;#10;    # if it's neither 1 nor 2, it has to be a block without n-back,&amp;#10;    # so set curr_nback_cond to None&amp;#10;    else:&amp;#10;        curr_nback_cond = None&amp;#10;&amp;#10;    print(f&quot;\tcurrent n-back condition: {curr_nback_cond}&quot;)&amp;#10;    print(f&quot;\tcurrent text: {curr_text_nr}&quot;)&amp;#10;&amp;#10;    # get list with targets &amp; list with colours&amp;#10;    curr_targets = all_target_lists[exp_block_counter]&amp;#10;    curr_colours = all_colour_lists[exp_block_counter]&amp;#10;    # for current text nr, get text whose name = current text nr&amp;#10;    # curr_text = locals()[curr_text_nr]&amp;#10;&amp;#10;### Start block loop&amp;#10;if curr_block in [&quot;Reading_Baseline_training_no_click&quot;, &quot;Reading_Baseline_main_no_click&quot;, &quot;1back_dual_main_no_click&quot;,&amp;#10;                  &quot;2back_dual_main_no_click&quot;]:&amp;#10;&amp;#10;    # create empty text stimulus&amp;#10;    stim = visual.TextStim(win=win,&amp;#10;                           text=&quot; &quot;,&amp;#10;                           pos=(0, 0),  # center stimulus&amp;#10;                           font=&quot;Times New Roman&quot;,&amp;#10;                           height=0.07)&amp;#10;&amp;#10;    stim.draw()&amp;#10;    win.flip()&amp;#10;&amp;#10;    # clear buffer of all previously recorded key events:&amp;#10;    event.clearEvents()&amp;#10;&amp;#10;    # CREATE CLOCKS:&amp;#10;    my_block_clock = core.Clock()&amp;#10;    my_block_clock.reset()  # start block clock&amp;#10;    start_time = my_block_clock.getTime()  # get start time of block&amp;#10;    # also create trial clock&amp;#10;    my_trial_clock = core.Clock()&amp;#10;&amp;#10;    # loop words in current text&amp;#10;    for trial_idx, curr_word in enumerate(curr_text):&amp;#10;        # print(&quot;current idx: &quot; + str(trial_idx) + &quot;, curr word:&quot; + curr_word)&amp;#10;&amp;#10;        ### prepare &amp; show current word:&amp;#10;&amp;#10;        # get current colour&amp;#10;        curr_colour = curr_colours[trial_idx]&amp;#10;&amp;#10;        # if it's a block with an n-back task, prepare target list as well&amp;#10;        if curr_nback_cond != None:&amp;#10;            curr_target = curr_targets[trial_idx]&amp;#10;            saw_target = False&amp;#10;&amp;#10;        # get duration for current word&amp;#10;        curr_duration = curr_durations[trial_idx] / 1000  # convert ms to seconds&amp;#10;        # print(&quot;duration for current word (in s):&quot;, curr_duration)&amp;#10;&amp;#10;        # get trial number (start counting from 1, so add 1)&amp;#10;        curr_trial_nr = trial_idx + 1&amp;#10;&amp;#10;        # set current word &amp; colour as content of text stimulus&amp;#10;        stim.color = curr_colour&amp;#10;        stim.text = curr_word&amp;#10;&amp;#10;        # show word on screen&amp;#10;        stim.draw()  # draw word on screen&amp;#10;&amp;#10;        # start trial clock &amp; record trial onset time&amp;#10;        my_trial_clock.reset()&amp;#10;        onset_time = my_trial_clock.getTime()&amp;#10;&amp;#10;        ### wait for key response:&amp;#10;        # In blocks with n-back task, participants can press &quot;c&quot; to indicate they saw a target colour.&amp;#10;&amp;#10;        ### start recording responses&amp;#10;        # start while loop that looks for responses&amp;#10;        # --&gt; end while loop only if duration for current word is over&amp;#10;        while my_trial_clock.getTime() &lt; (onset_time + curr_duration):&amp;#10;&amp;#10;            stim.draw()&amp;#10;            win.flip()&amp;#10;&amp;#10;            # check for key responses:&amp;#10;            keys = event.getKeys(['c', 'escape'])&amp;#10;&amp;#10;            # if there were, check responses:&amp;#10;            for key in keys:&amp;#10;&amp;#10;                # if participant pressed button &quot;c&quot; for the first time and it's an n-back condition&amp;#10;                # where they're actually supposed to do that (aka not a reading baseline condition)...&amp;#10;                if key == 'c' and curr_nback_cond != None and saw_target == False:&amp;#10;                    # get reaction time&amp;#10;                    curr_nback_RT = my_trial_clock.getTime() * 1000&amp;#10;                    # send trigger for response:&amp;#10;                    # send_trigger(&quot;response_target&quot;)&amp;#10;                    # only get first target response, we don't care if they press the button more than once:&amp;#10;                    saw_target = True&amp;#10;&amp;#10;                # If esc is pressed, end the experiment:&amp;#10;                elif key == 'escape':&amp;#10;                    # et_abort_exp()  # shut down eyetrigger and download incremental data&amp;#10;                    # close trigger &amp; close experiment&amp;#10;                    # core.wait(time_after_trigger)&amp;#10;                    # parallel.setData(0)&amp;#10;                    core.wait(0.5)&amp;#10;                    core.quit()&amp;#10;&amp;#10;        ### end trial&amp;#10;        print(&quot;\tend paced trial&quot;)&amp;#10;        # stop display of current word &amp; send trial offset trigger&amp;#10;        # win.callOnFlip(send_trigger, &quot;trial_offset&quot;)&amp;#10;&amp;#10;        # check whether response was hit, miss, false alarm or correct rejection&amp;#10;        # they saw a target and there was one: hit&amp;#10;        if curr_nback_cond != None:&amp;#10;            if saw_target and curr_target:&amp;#10;                curr_nback_response = &quot;hit&quot;&amp;#10;            # they didn't see a target but there was one: miss&amp;#10;            elif saw_target == False and curr_target:&amp;#10;                curr_nback_response = &quot;miss&quot;&amp;#10;                curr_nback_RT = None&amp;#10;            # they didn't see a target and there was none: correct rejection&amp;#10;            elif saw_target == False and curr_target == False:&amp;#10;                curr_nback_response = &quot;correct rejection&quot;&amp;#10;                curr_nback_RT = None&amp;#10;            # they saw a target but there was none: false alarm&amp;#10;            elif saw_target and curr_target == False:&amp;#10;                curr_nback_response = &quot;false alarm&quot;&amp;#10;        # if it wasn't an n-back task block:&amp;#10;        else:&amp;#10;            curr_target = None&amp;#10;            curr_nback_response = None&amp;#10;            curr_nback_RT = None&amp;#10;&amp;#10;        ### save everything in output csv&amp;#10;        thisExp.addData('colour', curr_colour)&amp;#10;        thisExp.addData('target', curr_target)&amp;#10;        thisExp.addData('nback_response', curr_nback_response)&amp;#10;        thisExp.addData('nback_RT', curr_nback_RT)  # in ms&amp;#10;        thisExp.addData('duration', curr_duration * 1000)  # in ms&amp;#10;        thisExp.addData('text_nr', curr_text_nr)&amp;#10;        thisExp.addData('trial_nr', curr_trial_nr)&amp;#10;        thisExp.addData('block_nr', exp_block_counter)&amp;#10;        thisExp.addData('block_name', curr_block)&amp;#10;        thisExp.addData('block_kind', curr_nback_cond)&amp;#10;        # careful, make sure quotes in the strings are escaped using a&amp;#10;        # quote (weird, I know) so it's properly saved in the CSV:&amp;#10;        thisExp.addData('word', escape_quotes(curr_word))&amp;#10;&amp;#10;        # start a new row in the csv&amp;#10;        thisExp.nextEntry()&amp;#10;&amp;#10;        ### IF TESTING MODE ENABLED: end loop after 4 trials&amp;#10;        if expInfo['testing_mode'] == &quot;yes&quot;:&amp;#10;            if trial_idx == 3:&amp;#10;                break&amp;#10;&amp;#10;    print(&quot;finished presenting trials&quot;)&amp;#10;&amp;#10;    # Send end of block trigger:&amp;#10;    # core.wait(time_after_trigger)  # wait 3 ms&amp;#10;    # send block offset trigger&amp;#10;    # send_trigger(&quot;block_offset&quot;)&amp;#10;&amp;#10;# end current routine&amp;#10;# continueRoutine = False" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="paced_blocks" valType="code" updates="None" name="name"/>
      </CodeComponent>
      <CodeComponent name="Q1_paced" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="psychoJS.window.setColor(light_bg_col, {&quot;colorSpace&quot;: &quot;rgb&quot;});&amp;#10;psychoJS.window.flip();&amp;#10;psychoJS.eventManager.clearEvents();&amp;#10;if (skip_questions) {&amp;#10;    continueRoutine = false;&amp;#10;} else {&amp;#10;    if (((skip_questions === false) &amp;&amp; training_Qs)) {&amp;#10;        Q1 = reading_bl_tr_Q1;&amp;#10;        Q1_answers = reading_bl_tr_Q1_ans;&amp;#10;        Q1_corr = reading_bl_tr_Q1_corr;&amp;#10;    } else {&amp;#10;        if (((skip_questions === false) &amp;&amp; (training_Qs === false))) {&amp;#10;            Q1 = locals()[(curr_text_nr + &quot;_Q1&quot;)];&amp;#10;            Q1_answers = locals()[(curr_text_nr + &quot;_Q1_ans&quot;)];&amp;#10;            Q1_corr = locals()[(curr_text_nr + &quot;_Q1_corr&quot;)];&amp;#10;        }&amp;#10;    }&amp;#10;}&amp;#10;question_pos = [0, 3];&amp;#10;answer_xpos = (- 7);&amp;#10;answer_ypos = [0, (- 2), (- 4), (- 6)];&amp;#10;question = new visual.TextStim(psychoJS.window, {&quot;text&quot;: Q1, &quot;pos&quot;: question_pos, &quot;color&quot;: &quot;black&quot;, &quot;height&quot;: 0.5, &quot;font&quot;: &quot;Bookman Old Style&quot;, &quot;anchorHoriz&quot;: &quot;center&quot;, &quot;alignText&quot;: &quot;center&quot;, &quot;wrapWidth&quot;: 10});&amp;#10;answers = function () {&amp;#10;    var _pj_a = [], _pj_b = util.range(Q1_answers.length);&amp;#10;    for (var _pj_c = 0, _pj_d = _pj_b.length; (_pj_c &lt; _pj_d); _pj_c += 1) {&amp;#10;        var i = _pj_b[_pj_c];&amp;#10;        _pj_a.push(new visual.TextStim(psychoJS.window, {&quot;text&quot;: Q1_answers[i], &quot;pos&quot;: [answer_xpos, answer_ypos[i]], &quot;color&quot;: &quot;black&quot;, &quot;height&quot;: 0.5, &quot;font&quot;: &quot;Bookman Old Style&quot;, &quot;wrapWidth&quot;: 15, &quot;anchorHoriz&quot;: &quot;left&quot;, &quot;alignText&quot;: &quot;center&quot;}));&amp;#10;    }&amp;#10;    return _pj_a;&amp;#10;}&amp;#10;.call(this);&amp;#10;instr_text = new visual.TextStim(psychoJS.window, {&quot;text&quot;: &quot;(Bitte benutzen Sie die Tasten 1, 2, 3 und 4 um die richtige Antwort auszuw\u00e4hlen. Mit der Leertaste k\u00f6nnen Sie Ihre Auswahl best\u00e4tigen.)&quot;, &quot;color&quot;: &quot;grey&quot;, &quot;pos&quot;: [0, (- 10)], &quot;wrapWidth&quot;: 20, &quot;height&quot;: 0.4, &quot;font&quot;: &quot;Bookman Old Style&quot;});&amp;#10;question.autoDraw = true;&amp;#10;instr_text.autoDraw = true;&amp;#10;for (var answer, _pj_c = 0, _pj_a = answers, _pj_b = _pj_a.length; (_pj_c &lt; _pj_b); _pj_c += 1) {&amp;#10;    answer = _pj_a[_pj_c];&amp;#10;    answer.autoDraw = true;&amp;#10;}&amp;#10;psychoJS.window.flip();&amp;#10;Q1_chosen_ans = null;&amp;#10;while (true) {&amp;#10;    if (psychoJS.eventManager.getKeys([&quot;1&quot;])) {&amp;#10;        console.log(&quot;\ta&quot;);&amp;#10;        Q1_chosen_ans = &quot;a&quot;;&amp;#10;        answers[0].setColor(&quot;green&quot;);&amp;#10;        for (var answer, _pj_c = 0, _pj_a = answers.slice(1), _pj_b = _pj_a.length; (_pj_c &lt; _pj_b); _pj_c += 1) {&amp;#10;            answer = _pj_a[_pj_c];&amp;#10;            answer.setColor(&quot;black&quot;);&amp;#10;            psychoJS.window.flip();&amp;#10;        }&amp;#10;    }&amp;#10;    if (psychoJS.eventManager.getKeys([&quot;2&quot;])) {&amp;#10;        console.log(&quot;\tb&quot;);&amp;#10;        Q1_chosen_ans = &quot;b&quot;;&amp;#10;        answers[1].setColor(&quot;green&quot;);&amp;#10;        for (var answer, _pj_c = 0, _pj_a = ([answers[0]] + answers.slice(2)), _pj_b = _pj_a.length; (_pj_c &lt; _pj_b); _pj_c += 1) {&amp;#10;            answer = _pj_a[_pj_c];&amp;#10;            answer.setColor(&quot;black&quot;);&amp;#10;            psychoJS.window.flip();&amp;#10;        }&amp;#10;    }&amp;#10;    if (psychoJS.eventManager.getKeys([&quot;3&quot;])) {&amp;#10;        console.log(&quot;\tc&quot;);&amp;#10;        Q1_chosen_ans = &quot;c&quot;;&amp;#10;        answers[2].setColor(&quot;green&quot;);&amp;#10;        for (var answer, _pj_c = 0, _pj_a = (answers.slice(0, 2) + answers.slice(3)), _pj_b = _pj_a.length; (_pj_c &lt; _pj_b); _pj_c += 1) {&amp;#10;            answer = _pj_a[_pj_c];&amp;#10;            answer.setColor(&quot;black&quot;);&amp;#10;        }&amp;#10;        psychoJS.window.flip();&amp;#10;    }&amp;#10;    if (psychoJS.eventManager.getKeys([&quot;4&quot;])) {&amp;#10;        console.log(&quot;\td&quot;);&amp;#10;        Q1_chosen_ans = &quot;d&quot;;&amp;#10;        answers[3].setColor(&quot;green&quot;);&amp;#10;        for (var answer, _pj_c = 0, _pj_a = answers.slice(0, (- 1)), _pj_b = _pj_a.length; (_pj_c &lt; _pj_b); _pj_c += 1) {&amp;#10;            answer = _pj_a[_pj_c];&amp;#10;            answer.setColor(&quot;black&quot;);&amp;#10;        }&amp;#10;        psychoJS.window.flip();&amp;#10;    } else {&amp;#10;        if ((psychoJS.eventManager.getKeys([&quot;space&quot;]) &amp;&amp; (Q1_chosen_ans !== null))) {&amp;#10;            break;&amp;#10;        }&amp;#10;    }&amp;#10;}&amp;#10;console.log((&quot;answer for Q1:&quot; + Q1_chosen_ans.toString()));&amp;#10;if ((Q1_chosen_ans === Q1_corr)) {&amp;#10;    console.log(&quot;\tanswer correct!&quot;);&amp;#10;} else {&amp;#10;    console.log(&quot;\tanswer incorrect!&quot;);&amp;#10;}&amp;#10;psychoJS.experiment.addData(&quot;question&quot;, &quot;Q1&quot;);&amp;#10;psychoJS.experiment.addData(&quot;chosen_ans&quot;, Q1_chosen_ans);&amp;#10;psychoJS.experiment.addData(&quot;ans_correct&quot;, (Q1_chosen_ans === Q1_corr));&amp;#10;psychoJS.experiment.addData(&quot;text_nr&quot;, curr_text_nr);&amp;#10;psychoJS.experiment.addData(&quot;block_nr&quot;, exp_block_counter);&amp;#10;psychoJS.experiment.addData(&quot;block_name&quot;, curr_block);&amp;#10;psychoJS.experiment.addData(&quot;block_kind&quot;, curr_nback_cond);&amp;#10;psychoJS.experiment.nextEntry();&amp;#10;question.autoDraw = false;&amp;#10;instr_text.autoDraw = false;&amp;#10;for (var answer, _pj_c = 0, _pj_a = answers, _pj_b = _pj_a.length; (_pj_c &lt; _pj_b); _pj_c += 1) {&amp;#10;    answer = _pj_a[_pj_c];&amp;#10;    answer.autoDraw = false;&amp;#10;}&amp;#10;" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="##########################################################&amp;#10;#            Text Comprehension Questions - Q1           #&amp;#10;##########################################################&amp;#10;&amp;#10;### Settings:&amp;#10;# keep background ivory&amp;#10;win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;win.flip()&amp;#10;&amp;#10;# clear buffer of all previously recorded key events:&amp;#10;event.clearEvents()&amp;#10;&amp;#10;# check which kind of block we have&amp;#10;# if there was no text before, we can skip the questions&amp;#10;if skip_questions_paced:&amp;#10;    continueRoutine = False&amp;#10;# if we have a training text, set training questions&amp;#10;elif skip_questions_paced == False and training_Qs_paced:&amp;#10;    Q1 = reading_bl_tr_no_click_Q1&amp;#10;    Q1_answers = reading_bl_tr_no_click_Q1_ans&amp;#10;    Q1_corr = reading_bl_tr_no_click_Q1_corr&amp;#10;&amp;#10;# if we have a main text, set regular questions&amp;#10;elif skip_questions_paced == False and training_Qs_paced == False:&amp;#10;    # load first question for current text &amp; their respective answers&amp;#10;    Q1 = locals()[curr_text_nr + &quot;_Q1&quot;]&amp;#10;    Q1_answers = locals()[curr_text_nr + &quot;_Q1_ans&quot;]&amp;#10;    Q1_corr = locals()[curr_text_nr + &quot;_Q1_corr&quot;]&amp;#10;&amp;#10;if not skip_questions_paced:&amp;#10;    # Define text positions and formatting&amp;#10;    question_pos = (0, 0.2)&amp;#10;    answer_xpos = -0.75  # move questions a bit to the left &amp;#10;    answer_ypos = [0.1, 0.05, 0, -0.05]  # set the y axis positions of all 4 answers&amp;#10;&amp;#10;    # Create text stim for the question:&amp;#10;    question = visual.TextStim(win,&amp;#10;                               text=Q1,&amp;#10;                               pos=question_pos,&amp;#10;                               color=&quot;black&quot;,&amp;#10;                               height=0.025,  # font height relative to height of screen&amp;#10;                               anchorHoriz='center',&amp;#10;                               alignText='center',&amp;#10;                               wrapWidth=1)&amp;#10;    # create 1 text stim for each answer option:&amp;#10;    answers = [visual.TextStim(win,&amp;#10;                               text=Q1_answers[i],&amp;#10;                               pos=(answer_xpos, answer_ypos[i]),&amp;#10;                               color=&quot;black&quot;,  # set all to black as a default&amp;#10;                               height=0.025,  # font height relative to height of screen&amp;#10;                               wrapWidth=1.5,&amp;#10;                               anchorHoriz='left',&amp;#10;                               alignText='center') for i in range(len(Q1_answers))]&amp;#10;    # set up instruction text&amp;#10;    instr_text = visual.TextStim(win,&amp;#10;                                 text=&quot;(Bitte benutzen Sie die Tasten 1, 2, 3 und 4, um die richtige Antwort auszuwählen. Mit der Leertaste können Sie Ihre Auswahl bestätigen.)&quot;,&amp;#10;                                 color=&quot;grey&quot;,&amp;#10;                                 pos=(0, -0.3),&amp;#10;                                 wrapWidth=2,&amp;#10;                                 height=0.018)  # font height relative to height of screen&amp;#10;&amp;#10;    ### Show all on screen until I set .autoDraw = False&amp;#10;    question.autoDraw = True&amp;#10;    instr_text.autoDraw = True&amp;#10;    for answer in answers:&amp;#10;        answer.autoDraw = True&amp;#10;    win.flip()&amp;#10;&amp;#10;    ### Record key responses:&amp;#10;    Q1_chosen_ans = None&amp;#10;&amp;#10;    while True:&amp;#10;        # if 1 was pressed...&amp;#10;        if defaultKeyboard.getKeys('1'):&amp;#10;            # if event.getKeys(['1']):&amp;#10;            # print('\ta')&amp;#10;            # save Q1 answer as a &amp;#10;            Q1_chosen_ans = &quot;a&quot;&amp;#10;            # set font colour of the first answer (answer a) to &amp;#10;            # green and the rest to black:&amp;#10;            answers[0].setColor(&quot;green&quot;)&amp;#10;            for answer in answers[1:]:&amp;#10;                answer.setColor(&quot;black&quot;)&amp;#10;                # draw updated stimulus:&amp;#10;                win.flip()&amp;#10;        # same procedure for all other answer options:&amp;#10;        if defaultKeyboard.getKeys('2'):&amp;#10;            # if event.getKeys(['2']):&amp;#10;            # print('\tb')&amp;#10;            Q1_chosen_ans = &quot;b&quot;&amp;#10;            # set font colour of the second answer (answer b) to &amp;#10;            # green and the rest to black:&amp;#10;            answers[1].setColor(&quot;green&quot;)&amp;#10;            for answer in [answers[0]] + answers[2:]:&amp;#10;                answer.setColor(&quot;black&quot;)&amp;#10;                # draw updated stimulus:&amp;#10;                win.flip()&amp;#10;        if defaultKeyboard.getKeys('3'):&amp;#10;            # if event.getKeys(['3']):&amp;#10;            # print('\tc')&amp;#10;            Q1_chosen_ans = &quot;c&quot;&amp;#10;            # set font colour of the third answer (answer c) to &amp;#10;            # green and the rest to black:&amp;#10;            answers[2].setColor(&quot;green&quot;)&amp;#10;            for answer in answers[:2] + answers[3:]:&amp;#10;                answer.setColor(&quot;black&quot;)&amp;#10;            # draw updated stimulus:&amp;#10;            win.flip()&amp;#10;        if defaultKeyboard.getKeys('4'):&amp;#10;            # if event.getKeys(['4']):&amp;#10;            # print('\td')&amp;#10;            Q1_chosen_ans = &quot;d&quot;&amp;#10;            # set font colour of the fourth answer (answer d) to &amp;#10;            # green and the rest to black:&amp;#10;            answers[3].setColor(&quot;green&quot;)&amp;#10;            for answer in answers[:-1]:&amp;#10;                answer.setColor(&quot;black&quot;)&amp;#10;            # draw updated stimulus &amp;#10;            win.flip()&amp;#10;        # if participant pressed &quot;space&quot;, check whether they chose an answer.&amp;#10;        # if yes, end this routine and go to next question, if not, wait for valid answer.&amp;#10;        elif defaultKeyboard.getKeys(['space']) and Q1_chosen_ans != None:&amp;#10;            break&amp;#10;&amp;#10;    # print chosen answer for Q1&amp;#10;    print(&quot;answer for Q1 paced:&quot; + str(Q1_chosen_ans))&amp;#10;&amp;#10;    # check if answer was correct:&amp;#10;    if Q1_chosen_ans == Q1_corr:&amp;#10;        print(&quot;\tanswer correct!&quot;)&amp;#10;    else:&amp;#10;        print(&quot;\tanswer incorrect!&quot;)&amp;#10;&amp;#10;    # save data:&amp;#10;    thisExp.addData('question', 'Q1')&amp;#10;    thisExp.addData('chosen_ans', Q1_chosen_ans)&amp;#10;    thisExp.addData('ans_correct', Q1_chosen_ans == Q1_corr)&amp;#10;    thisExp.addData('text_nr', curr_text_nr)&amp;#10;    thisExp.addData('block_nr', exp_block_counter)&amp;#10;    thisExp.addData('block_name', curr_block)&amp;#10;    thisExp.addData('block_kind', curr_nback_cond)&amp;#10;&amp;#10;    # start a new row in the csv&amp;#10;    thisExp.nextEntry()&amp;#10;&amp;#10;    ### End Q1: Set .autoDraw = False to stop showing question &amp; answers&amp;#10;    question.autoDraw = False&amp;#10;    instr_text.autoDraw = False&amp;#10;    for answer in answers:&amp;#10;        answer.autoDraw = False&amp;#10;&amp;#10;    # end current routine&amp;#10;    # continueRoutine = False" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="Q1_paced" valType="code" updates="None" name="name"/>
      </CodeComponent>
      <CodeComponent name="Q2_paced" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="##########################################################&amp;#10;#            Text Comprehension Questions - Q2           #&amp;#10;##########################################################&amp;#10;&amp;#10;### Settings:&amp;#10;# keep background ivory&amp;#10;win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;win.flip()&amp;#10;&amp;#10;# clear buffer of all previously recorded key events:&amp;#10;event.clearEvents()&amp;#10;&amp;#10;# check which kind of block we have&amp;#10;# if there was no text before, we can skip the questions&amp;#10;if skip_questions_paced:&amp;#10;    continueRoutine = False&amp;#10;# if we have a training text, set training questions&amp;#10;elif skip_questions_paced == False and training_Qs_paced:&amp;#10;    Q2 = reading_bl_tr_no_click_Q2&amp;#10;    Q2_answers = reading_bl_tr_no_click_Q2_ans&amp;#10;    Q2_corr = reading_bl_tr_no_click_Q2_corr&amp;#10;&amp;#10;# if we have a main text, set regular questions&amp;#10;elif skip_questions_paced == False and training_Qs_paced == False:&amp;#10;    # load first question for current text &amp; their respective answers&amp;#10;    Q2 = locals()[curr_text_nr + &quot;_Q2&quot;]&amp;#10;    Q2_answers = locals()[curr_text_nr + &quot;_Q2_ans&quot;]&amp;#10;    Q2_corr = locals()[curr_text_nr + &quot;_Q2_corr&quot;]&amp;#10;&amp;#10;if not skip_questions_paced:&amp;#10;    # Define text positions and formatting&amp;#10;    question_pos = (0, 0.2)&amp;#10;    answer_xpos = -0.75  # move questions a bit to the left &amp;#10;    answer_ypos = [0.1, 0.05, 0, -0.05]  # set the y axis positions of all 4 answers&amp;#10;&amp;#10;    # Create text stim for the question:&amp;#10;    question = visual.TextStim(win,&amp;#10;                               text=Q2,&amp;#10;                               pos=question_pos,&amp;#10;                               color=&quot;black&quot;,&amp;#10;                               height=0.025,  # font height relative to height of screen&amp;#10;                               anchorHoriz='center',&amp;#10;                               alignText='center',&amp;#10;                               wrapWidth=1)&amp;#10;    # create 1 text stim for each answer option:&amp;#10;    answers = [visual.TextStim(win,&amp;#10;                               text=Q2_answers[i],&amp;#10;                               pos=(answer_xpos, answer_ypos[i]),&amp;#10;                               color=&quot;black&quot;,  # set all to black as a default&amp;#10;                               height=0.025,  # font height relative to height of screen&amp;#10;                               wrapWidth=1.5,&amp;#10;                               anchorHoriz='left',&amp;#10;                               alignText='center') for i in range(len(Q1_answers))]&amp;#10;    # set up instruction text&amp;#10;    instr_text = visual.TextStim(win,&amp;#10;                                 text=&quot;(Bitte benutzen Sie die Tasten 1, 2, 3 und 4, um die richtige Antwort auszuwählen. Mit der Leertaste können Sie Ihre Auswahl bestätigen.)&quot;,&amp;#10;                                 color=&quot;grey&quot;,&amp;#10;                                 pos=(0, -0.3),&amp;#10;                                 wrapWidth=2,&amp;#10;                                 height=0.018)  # font height relative to height of screen&amp;#10;&amp;#10;    ### Show all on screen until I set .autoDraw = False&amp;#10;    question.autoDraw = True&amp;#10;    instr_text.autoDraw = True&amp;#10;    for answer in answers:&amp;#10;        answer.autoDraw = True&amp;#10;    win.flip()&amp;#10;&amp;#10;    ### Record key responses:&amp;#10;    Q2_chosen_ans = None&amp;#10;&amp;#10;    while True:&amp;#10;        # if 1 was pressed...&amp;#10;        if defaultKeyboard.getKeys('1'):&amp;#10;            # if event.getKeys(['1']):&amp;#10;            # print('\ta')&amp;#10;            # save Q1 answer as a &amp;#10;            Q2_chosen_ans = &quot;a&quot;&amp;#10;            # set font colour of the first answer (answer a) to &amp;#10;            # green and the rest to black:&amp;#10;            answers[0].setColor(&quot;green&quot;)&amp;#10;            for answer in answers[1:]:&amp;#10;                answer.setColor(&quot;black&quot;)&amp;#10;                # draw updated stimulus:&amp;#10;                win.flip()&amp;#10;        # same procedure for all other answer options:&amp;#10;        if defaultKeyboard.getKeys('2'):&amp;#10;            # if event.getKeys(['2']):&amp;#10;            # print('\tb')&amp;#10;            Q2_chosen_ans = &quot;b&quot;&amp;#10;            # set font colour of the second answer (answer b) to &amp;#10;            # green and the rest to black:&amp;#10;            answers[1].setColor(&quot;green&quot;)&amp;#10;            for answer in [answers[0]] + answers[2:]:&amp;#10;                answer.setColor(&quot;black&quot;)&amp;#10;                # draw updated stimulus:&amp;#10;                win.flip()&amp;#10;        if defaultKeyboard.getKeys('3'):&amp;#10;            # if event.getKeys(['3']):&amp;#10;            # print('\tc')&amp;#10;            Q2_chosen_ans = &quot;c&quot;&amp;#10;            # set font colour of the third answer (answer c) to &amp;#10;            # green and the rest to black:&amp;#10;            answers[2].setColor(&quot;green&quot;)&amp;#10;            for answer in answers[:2] + answers[3:]:&amp;#10;                answer.setColor(&quot;black&quot;)&amp;#10;            # draw updated stimulus:&amp;#10;            win.flip()&amp;#10;        if defaultKeyboard.getKeys('4'):&amp;#10;            # if event.getKeys(['4']):&amp;#10;            # print('\td')&amp;#10;            Q2_chosen_ans = &quot;d&quot;&amp;#10;            # set font colour of the fourth answer (answer d) to &amp;#10;            # green and the rest to black:&amp;#10;            answers[3].setColor(&quot;green&quot;)&amp;#10;            for answer in answers[:-1]:&amp;#10;                answer.setColor(&quot;black&quot;)&amp;#10;            # draw updated stimulus &amp;#10;            win.flip()&amp;#10;        # if participant pressed &quot;space&quot;, check whether they chose an answer.&amp;#10;        # if yes, end this routine and go to next question, if not, wait for valid answer.&amp;#10;        elif defaultKeyboard.getKeys(['space']) and Q2_chosen_ans != None:&amp;#10;            break&amp;#10;    # print chosen answer for Q2&amp;#10;    print(&quot;answer for Q2 paced:&quot; + str(Q2_chosen_ans))&amp;#10;&amp;#10;    # check if answer was correct:&amp;#10;    if Q2_chosen_ans == Q2_corr:&amp;#10;        print(&quot;\tanswer correct!&quot;)&amp;#10;    else:&amp;#10;        print(&quot;\tanswer incorrect!&quot;)&amp;#10;&amp;#10;    # save data:&amp;#10;    thisExp.addData('question', 'Q2')&amp;#10;    thisExp.addData('chosen_ans', Q2_chosen_ans)&amp;#10;    thisExp.addData('ans_correct', Q2_chosen_ans == Q2_corr)&amp;#10;    thisExp.addData('text_nr', curr_text_nr)&amp;#10;    thisExp.addData('block_nr', exp_block_counter)&amp;#10;    thisExp.addData('block_name', curr_block)&amp;#10;    thisExp.addData('block_kind', curr_nback_cond)&amp;#10;&amp;#10;    # start a new row in the csv&amp;#10;    thisExp.nextEntry()&amp;#10;&amp;#10;    ### End Q2: Set .autoDraw = False to stop showing question &amp; answers&amp;#10;    question.autoDraw = False&amp;#10;    instr_text.autoDraw = False&amp;#10;    for answer in answers:&amp;#10;        answer.autoDraw = False&amp;#10;&amp;#10;    # end current routine&amp;#10;    # continueRoutine = False" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="Q2_paced" valType="code" updates="None" name="name"/>
      </CodeComponent>
      <CodeComponent name="Q3_paced" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="##########################################################&amp;#10;#            Text Comprehension Questions - Q3           #&amp;#10;##########################################################&amp;#10;&amp;#10;### Settings:&amp;#10;# keep background ivory&amp;#10;win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;win.flip()&amp;#10;&amp;#10;# clear buffer of all previously recorded key events:&amp;#10;event.clearEvents()&amp;#10;&amp;#10;# check which kind of block we have&amp;#10;# if there was no text before, we can skip the questions&amp;#10;if skip_questions_paced:&amp;#10;    continueRoutine = False&amp;#10;# if we have a training text, set training questions&amp;#10;elif skip_questions_paced == False and training_Qs_paced:&amp;#10;    Q3 = reading_bl_tr_no_click_Q3&amp;#10;    Q3_answers = reading_bl_tr_no_click_Q3_ans&amp;#10;    Q3_corr = reading_bl_tr_no_click_Q3_corr&amp;#10;&amp;#10;# if we have a main text, set regular questions&amp;#10;elif skip_questions_paced == False and training_Qs_paced == False:&amp;#10;    # load first question for current text &amp; their respective answers&amp;#10;    Q3 = locals()[curr_text_nr + &quot;_Q3&quot;]&amp;#10;    Q3_answers = locals()[curr_text_nr + &quot;_Q3_ans&quot;]&amp;#10;    Q3_corr = locals()[curr_text_nr + &quot;_Q3_corr&quot;]&amp;#10;&amp;#10;if not skip_questions_paced:&amp;#10;    # Define text positions and formatting&amp;#10;    question_pos = (0, 0.2)&amp;#10;    answer_xpos = -0.75  # move questions a bit to the left &amp;#10;    answer_ypos = [0.1, 0.05, 0, -0.05]  # set the y axis positions of all 4 answers&amp;#10;&amp;#10;    # Create text stim for the question:&amp;#10;    question = visual.TextStim(win,&amp;#10;                               text=Q3,&amp;#10;                               pos=question_pos,&amp;#10;                               color=&quot;black&quot;,&amp;#10;                               height=0.025,  # font height relative to height of screen&amp;#10;                               anchorHoriz='center',&amp;#10;                               alignText='center',&amp;#10;                               wrapWidth=1)&amp;#10;    # create 1 text stim for each answer option:&amp;#10;    answers = [visual.TextStim(win,&amp;#10;                               text=Q3_answers[i],&amp;#10;                               pos=(answer_xpos, answer_ypos[i]),&amp;#10;                               color=&quot;black&quot;,  # set all to black as a default&amp;#10;                               height=0.025,  # font height relative to height of screen&amp;#10;                               wrapWidth=1.5,&amp;#10;                               anchorHoriz='left',&amp;#10;                               alignText='center') for i in range(len(Q1_answers))]&amp;#10;    # set up instruction text&amp;#10;    instr_text = visual.TextStim(win,&amp;#10;                                 text=&quot;(Bitte benutzen Sie die Tasten 1, 2, 3 und 4, um die richtige Antwort auszuwählen. Mit der Leertaste können Sie Ihre Auswahl bestätigen.)&quot;,&amp;#10;                                 color=&quot;grey&quot;,&amp;#10;                                 pos=(0, -0.3),&amp;#10;                                 wrapWidth=2,&amp;#10;                                 height=0.018)  # font height relative to height of screen&amp;#10;&amp;#10;    ### Show all on screen until I set .autoDraw = False&amp;#10;    question.autoDraw = True&amp;#10;    instr_text.autoDraw = True&amp;#10;    for answer in answers:&amp;#10;        answer.autoDraw = True&amp;#10;    win.flip()&amp;#10;&amp;#10;    ### Record key responses:&amp;#10;    Q3_chosen_ans = None&amp;#10;&amp;#10;    while True:&amp;#10;        # if 1 was pressed...&amp;#10;        if defaultKeyboard.getKeys('1'):&amp;#10;            # if event.getKeys(['1']):&amp;#10;            # print('\ta')&amp;#10;            # save Q1 answer as a &amp;#10;            Q3_chosen_ans = &quot;a&quot;&amp;#10;            # set font colour of the first answer (answer a) to &amp;#10;            # green and the rest to black:&amp;#10;            answers[0].setColor(&quot;green&quot;)&amp;#10;            for answer in answers[1:]:&amp;#10;                answer.setColor(&quot;black&quot;)&amp;#10;                # draw updated stimulus:&amp;#10;                win.flip()&amp;#10;        # same procedure for all other answer options:&amp;#10;        if defaultKeyboard.getKeys('2'):&amp;#10;            # if event.getKeys(['2']):&amp;#10;            # print('\tb')&amp;#10;            Q3_chosen_ans = &quot;b&quot;&amp;#10;            # set font colour of the second answer (answer b) to &amp;#10;            # green and the rest to black:&amp;#10;            answers[1].setColor(&quot;green&quot;)&amp;#10;            for answer in [answers[0]] + answers[2:]:&amp;#10;                answer.setColor(&quot;black&quot;)&amp;#10;                # draw updated stimulus:&amp;#10;                win.flip()&amp;#10;        if defaultKeyboard.getKeys('3'):&amp;#10;            # if event.getKeys(['3']):&amp;#10;            # print('\tc')&amp;#10;            Q3_chosen_ans = &quot;c&quot;&amp;#10;            # set font colour of the third answer (answer c) to &amp;#10;            # green and the rest to black:&amp;#10;            answers[2].setColor(&quot;green&quot;)&amp;#10;            for answer in answers[:2] + answers[3:]:&amp;#10;                answer.setColor(&quot;black&quot;)&amp;#10;            # draw updated stimulus:&amp;#10;            win.flip()&amp;#10;        if defaultKeyboard.getKeys('4'):&amp;#10;            # if event.getKeys(['4']):&amp;#10;            # print('\td')&amp;#10;            Q3_chosen_ans = &quot;d&quot;&amp;#10;            # set font colour of the fourth answer (answer d) to &amp;#10;            # green and the rest to black:&amp;#10;            answers[3].setColor(&quot;green&quot;)&amp;#10;            for answer in answers[:-1]:&amp;#10;                answer.setColor(&quot;black&quot;)&amp;#10;            # draw updated stimulus &amp;#10;            win.flip()&amp;#10;        # if participant pressed &quot;space&quot;, check whether they chose an answer.&amp;#10;        # if yes, end this routine and go to next question, if not, wait for valid answer.&amp;#10;        elif defaultKeyboard.getKeys(['space']) and Q3_chosen_ans != None:&amp;#10;            break&amp;#10;&amp;#10;    # print chosen answer for Q3&amp;#10;    print(&quot;answer for Q3 paced:&quot; + str(Q3_chosen_ans))&amp;#10;&amp;#10;    # check if answer was correct:&amp;#10;    if Q3_chosen_ans == Q3_corr:&amp;#10;        print(&quot;\tanswer correct!&quot;)&amp;#10;    else:&amp;#10;        print(&quot;\tanswer incorrect!&quot;)&amp;#10;&amp;#10;    # save data:&amp;#10;    thisExp.addData('question', 'Q3')&amp;#10;    thisExp.addData('chosen_ans', Q3_chosen_ans)&amp;#10;    thisExp.addData('ans_correct', Q3_chosen_ans == Q3_corr)&amp;#10;    thisExp.addData('text_nr', curr_text_nr)&amp;#10;    thisExp.addData('block_nr', exp_block_counter)&amp;#10;    thisExp.addData('block_name', curr_block)&amp;#10;    thisExp.addData('block_kind', curr_nback_cond)&amp;#10;&amp;#10;    # start a new row in the csv&amp;#10;    thisExp.nextEntry()&amp;#10;&amp;#10;    ### End Q3: Set .autoDraw = False to stop showing question &amp; answers&amp;#10;    question.autoDraw = False&amp;#10;    instr_text.autoDraw = False&amp;#10;    for answer in answers:&amp;#10;        answer.autoDraw = False&amp;#10;&amp;#10;    # go to next block!&amp;#10;    exp_block_counter += 1&amp;#10;    print(f&quot;Going to block {exp_block_counter + 1}/13 now!&quot;)&amp;#10;    continueRoutine = False&amp;#10;&amp;#10;    # If there are still blocks left, go to next one.&amp;#10;    # If not, end loop here:&amp;#10;    if exp_block_counter == 13:&amp;#10;        blocks.finished = True&amp;#10;&amp;#10;# when text rating is included, only use this instead of &quot;go to next block&quot;:&amp;#10;# end current routine&amp;#10;# continueRoutine = False" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="Q3_paced" valType="code" updates="None" name="name"/>
      </CodeComponent>
    </Routine>
    <Routine name="text_blocks_paced_training">
      <RoutineSettingsComponent name="text_blocks_paced_training" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="text_blocks_paced_training" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <CodeComponent name="paced_training" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="##########################################################&amp;#10;#                 VISUAL TASK: TRAINING BLOCK            #&amp;#10;##########################################################&amp;#10;&amp;#10;# In this task, we present a new text, but the text proceeds&amp;#10;# automatically without the participant having to press the Space bar.&amp;#10;# To make sure the words are not presented too fast,&amp;#10;# we compute the average reading speed per letter and compute &quot;reading speeds&quot;&amp;#10;# for each word in the new text.&amp;#10;&amp;#10;# Put differently: We take the words &amp; the measured reading times for each&amp;#10;# word all BL main blocks and compute an average reading time / letter.&amp;#10;# Then we show a new text, using the reading time / letter to generate&amp;#10;# durations so the text can proceed automatically.&amp;#10;&amp;#10;# First things first: Compute average reading time / letter:&amp;#10;&amp;#10;# For testing purposes, I created the option to skip all main blocks.&amp;#10;# In this case we don't have any data from previous BL blocks,&amp;#10;# so we have to invent some reading times in order to test this part of the script.&amp;#10;if expInfo[&quot;testing_mode&quot;] == &quot;yes&quot;:&amp;#10;    BL_paced_durations = [332, 10, 104.778, 98.9, 3000,&amp;#10;                          440]  # in ms - I included a longer break and a very short RT as a test case for the data cleaning part later&amp;#10;    BL_paced_words = [&quot;Hallo,&quot;, &quot;das&quot;, &quot;ist&quot;, &quot;nur&quot;, &quot;ein&quot;, &quot;Beispiel.&quot;]&amp;#10;&amp;#10;# We collected RTs &amp; words from the self-paced block of each condition&amp;#10;# for the training, we only use data from the reading BL since there is no separate training for 1- and 2-back&amp;#10;&amp;#10;# exclude all RTs where participant was way too fast (&lt; 50 ms) or&amp;#10;# way too slow (&gt; 2s), also remove the corresponding words from vis_task_words&amp;#10;print(&quot;BL_paced_durations:&quot;, BL_paced_durations)&amp;#10;print(&quot;BL_paced_words:&quot;, BL_paced_words)&amp;#10;&amp;#10;filtered_durations = []&amp;#10;filtered_words = []&amp;#10;for duration, word in zip(BL_paced_durations, BL_paced_words):&amp;#10;    if 50 &lt;= duration &lt;= 2000:&amp;#10;        filtered_durations.append(duration)&amp;#10;        filtered_words.append(word)&amp;#10;print(&quot;filtered_durations:&quot;, filtered_durations)&amp;#10;print(&quot;filtered_words:&quot;, filtered_words)&amp;#10;&amp;#10;# Now get number of letters (not words, I want to know how fast they read 1 letter on average!):&amp;#10;letters_total = sum(len(word) for word in filtered_words)&amp;#10;print(&quot;letters_total:&quot;, letters_total)&amp;#10;# also get time it took in total to read them all:&amp;#10;reading_time_total = sum(filtered_durations)  # in ms&amp;#10;&amp;#10;# Now check how many words / min they read on average.&amp;#10;# reading_speed_wpm = words_total / (reading_time_total/60000)&amp;#10;# print(&quot;reading speed in words / min:&quot; + str(reading_speed_wpm))&amp;#10;&amp;#10;# Check average RT / letter&amp;#10;RT_per_letter = reading_time_total / letters_total&amp;#10;print(&quot;average RT per letter in ms:&quot;, RT_per_letter)&amp;#10;&amp;#10;# choose 1 target colour &amp; generate 0-back colour list&amp;#10;target_colour = random.choice(colours)&amp;#10;&amp;#10;# save this in the output csv:&amp;#10;thisExp.addData('vistask_RT_per_letter', RT_per_letter)&amp;#10;thisExp.addData('vistask_target', target_colour)&amp;#10;thisExp.addData('block_cond', 'None')&amp;#10;thisExp.addData('block_name', 'visual_task_training')&amp;#10;&amp;#10;# keep background ivory&amp;#10;win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;win.flip()&amp;#10;&amp;#10;# ----------------------------------&amp;#10;&amp;#10;### VISUAL TASK TRAINING&amp;#10;&amp;#10;# Show instructions&amp;#10;&amp;#10;# clear buffer of all previously recorded key events:&amp;#10;event.clearEvents()&amp;#10;&amp;#10;# create text boxes&amp;#10;instr_text_stim1 = visual.TextStim(win,&amp;#10;                                   text=locals()[&quot;instr_vis_task_1&quot;],&amp;#10;                                   height=0.5,  # font height: 5° visual angle&amp;#10;                                   #font=&quot;Bookman Old Style&quot;,&amp;#10;                                   pos=(0, 4),  # move instructions up a bit&amp;#10;                                   color=&quot;black&quot;)&amp;#10;instr_text_stim2 = visual.TextStim(win,&amp;#10;                                   text=locals()[&quot;instr_vis_task_2&quot;],&amp;#10;                                   height=0.5,  # font height: 5° visual angle&amp;#10;                                   #font=&quot;Bookman Old Style&quot;,&amp;#10;                                   pos=(0, 0),  # move instructions down a bit&amp;#10;                                   color=&quot;black&quot;)&amp;#10;&amp;#10;# show instructions on screen&amp;#10;win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;instr_text_stim1.draw()&amp;#10;instr_text_stim2.draw()&amp;#10;win.flip()&amp;#10;core.wait(3)  # wait for 3s before starting response window&amp;#10;&amp;#10;# display the text &amp; the circle on screen until Space is pressed&amp;#10;while True:&amp;#10;    # keep background ivory&amp;#10;    win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;    instr_text_stim1.draw()&amp;#10;    instr_text_stim2.draw()&amp;#10;    win.flip()&amp;#10;    # end screen if participant presses space&amp;#10;    if 'space' in event.getKeys():&amp;#10;        break&amp;#10;&amp;#10;### START VISUAL TASK TRAINING&amp;#10;&amp;#10;# change background colour:&amp;#10;win.setColor(dark_bg_col, colorSpace='rgb')&amp;#10;win.flip()&amp;#10;&amp;#10;# clear buffer of all previously recorded key events:&amp;#10;event.clearEvents()&amp;#10;&amp;#10;# prepare stimuli:&amp;#10;curr_text_training = ['Einen', 'Augenblick', 'herrschte', 'totale', 'Stille.', 'Man', 'hörte', 'plötzlich', 'die',&amp;#10;                      'Wellen', 'rauschen', 'und', 'das', 'Radio', 'aus', 'dem', 'Salon', 'herüberjazzen,', 'man',&amp;#10;                      'vernahm', 'jeden', 'Schritt', 'vom', 'Promenadendeck', 'und', 'das', 'leise,', 'feine', 'Sausen',&amp;#10;                      'des', 'Winds,', 'der', 'durch', 'die', 'Fugen', 'der', 'Fenster', 'fuhr.', 'Keiner', 'von',&amp;#10;                      'uns', 'atmete,', 'es', 'war', 'zu', 'plötzlich', 'gekommen', 'und', 'wir', 'alle', 'noch',&amp;#10;                      'geradezu', 'erschrocken', 'über', 'das', 'Unwahrscheinliche,', 'dass', 'dieser', 'Unbekannte',&amp;#10;                      'dem', 'Weltmeister', 'in', 'einer', 'schon', 'halb', 'verlorenen', 'Partie', 'seinen', 'Willen',&amp;#10;                      'aufgezwungen', 'haben', 'sollte.', 'McConnor', 'lehnte', 'sich', 'mit', 'einem', 'Ruck',&amp;#10;                      'zurück,', 'der', 'zurückgehaltene', 'Atem', 'fuhr', 'ihm', 'hörbar', 'in', 'einem', 'beglückten',&amp;#10;                      &quot;\&quot;Ah!\&quot;&quot;, 'von', 'den', 'Lippen.', 'Ich', 'wiederum', 'beobachtete', 'Czentovic.', 'Schon',&amp;#10;                      'bei', 'den', 'letzten', 'Zügen', 'hatte', 'mir', 'geschienen,', 'als', 'ob', 'er', 'blässer',&amp;#10;                      'geworden', 'sei.', 'Aber', 'er', 'verstand', 'sich', 'gut', 'zusammenzuhalten.', 'Er',&amp;#10;                      'verharrte', 'in', 'seiner', 'scheinbar', 'gleichmütigen', 'Starre', 'und', 'fragte', 'nur', 'in',&amp;#10;                      'lässigster', 'Weise,', 'während', 'er', 'die', 'Figuren', 'mit', 'ruhiger', 'Hand', 'vom',&amp;#10;                      'Brette', 'schob:', &quot;\&quot;Wünschen&quot;, 'die', 'Herren', 'noch', 'eine', 'dritte', 'Partie?\&quot;']&amp;#10;&amp;#10;# compute RTs using participant's average reading speed / letter&amp;#10;curr_durations_training = [len(word) * RT_per_letter for word in curr_text_training]  # in secs&amp;#10;print(&quot;durations for vis task training block:&quot;, curr_durations_training)&amp;#10;&amp;#10;# generate random colour list:&amp;#10;curr_colours_training = create_0back_stimlist(target_colour=target_colour, nr_targets=25, colour_codes=colours,&amp;#10;                                              nr_words=len(curr_text_training))&amp;#10;&amp;#10;# save position of targets as True/False list:&amp;#10;curr_targets_training = [colour == target_colour for colour in curr_colours_training]&amp;#10;&amp;#10;# CREATE CLOCKS:&amp;#10;my_block_clock = core.Clock()&amp;#10;my_block_clock.reset()  # start block clock&amp;#10;start_time = my_block_clock.getTime()  # get start time of block&amp;#10;# also create trial clock&amp;#10;my_trial_clock = core.Clock()&amp;#10;&amp;#10;### start block loop&amp;#10;&amp;#10;# create empty text stimulus&amp;#10;stim = visual.TextStim(win=win,&amp;#10;                       text=&quot; &quot;,&amp;#10;                       pos=(0, 0),  # center stimulus&amp;#10;                       font=&quot;Times New Roman&quot;,&amp;#10;                       height=1)  # font height = 1° visual angle&amp;#10;&amp;#10;&amp;#10;stim.draw()&amp;#10;win.flip()&amp;#10;&amp;#10;# loop words in current text&amp;#10;for trial_idx, curr_word in enumerate(curr_text_training):&amp;#10;    print(&quot;current idx: &quot; + str(trial_idx) + &quot;, curr word:&quot; + curr_word)&amp;#10;&amp;#10;    ### prepare &amp; show current word:&amp;#10;&amp;#10;    # get current colour&amp;#10;    curr_colour = curr_colours_training[trial_idx]&amp;#10;    # check if it's a target&amp;#10;    curr_target = curr_targets_training[trial_idx]&amp;#10;&amp;#10;    # get duration for current word&amp;#10;    curr_duration = curr_durations_training[trial_idx] / 1000  # convert ms to seconds&amp;#10;    print(&quot;duration for current word (in ms):&quot;, curr_duration)&amp;#10;&amp;#10;    # get trial number (start counting from 1, so add 1)&amp;#10;    curr_trial_nr = trial_idx + 1&amp;#10;&amp;#10;    # set current word &amp; colour as content of text stimulus&amp;#10;    stim.color = curr_colour&amp;#10;    stim.text = curr_word&amp;#10;&amp;#10;    # show word on screen&amp;#10;    stim.draw()  # draw word on screen&amp;#10;&amp;#10;    # start trial clock&amp;#10;    my_trial_clock.reset()&amp;#10;    onset_time = my_trial_clock.getTime()&amp;#10;&amp;#10;    ### wait for key response until curr_duration is over:&amp;#10;&amp;#10;    ### start recording responses&amp;#10;    # start while loop that looks for responses&amp;#10;    # --&gt; end while loop only if duration for current word is over&amp;#10;    while my_trial_clock.getTime() &lt; (onset_time + curr_duration):&amp;#10;&amp;#10;        # print(&quot;curr time stamp:&quot;, my_trial_clock.getTime(), &quot;waiting for time stamp:&quot;, onset_time + curr_duration)&amp;#10;        stim.draw()&amp;#10;        win.flip()&amp;#10;&amp;#10;        # check if there were responses:&amp;#10;        keys = event.getKeys(['escape'])&amp;#10;&amp;#10;        # if there were, check responses:&amp;#10;        for key in keys:&amp;#10;            # If esc is pressed, end the experiment:&amp;#10;            if key == 'escape':&amp;#10;                # close parallel port&amp;#10;                parallel.setData(0)&amp;#10;                core.wait(0.5)&amp;#10;                core.quit()&amp;#10;&amp;#10;    ### end trial&amp;#10;&amp;#10;    ### save everything in output csv&amp;#10;    thisExp.addData('colour', curr_colour)&amp;#10;    thisExp.addData('target', curr_target)&amp;#10;    thisExp.addData('duration', curr_duration * 1000)  # convert sec back to ms&amp;#10;    thisExp.addData('text_nr', None)&amp;#10;    thisExp.addData('trial_nr', curr_trial_nr)&amp;#10;    thisExp.addData('block_cond', 'None')&amp;#10;    thisExp.addData('block_nr', exp_block_counter)&amp;#10;    thisExp.addData('block_name', 'BL_paced_training')&amp;#10;    # careful, make sure to escape quotes in the string&amp;#10;    # differently before saving in csv file:&amp;#10;    thisExp.addData('word', escape_quotes(curr_word))&amp;#10;&amp;#10;    # start a new row in the csv&amp;#10;    thisExp.nextEntry()&amp;#10;&amp;#10;    ### IF TESTING MODE ENABLED: end loop after 4 trials&amp;#10;    if expInfo['testing_mode'] == &quot;yes&quot;:&amp;#10;        if trial_idx == 20:&amp;#10;            break&amp;#10;&amp;#10;print(&quot;finished paced task training block&quot;)&amp;#10;&amp;#10;# change background colour from grey to ivory&amp;#10;win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;win.flip()" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="paced_training" valType="code" updates="None" name="name"/>
      </CodeComponent>
    </Routine>
    <Routine name="end">
      <RoutineSettingsComponent name="end" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="end" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <CodeComponent name="end" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="### END OF EXPERIMENT:&amp;#10;# keep background ivory&amp;#10;win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;win.flip()&amp;#10;&amp;#10;### Show message&amp;#10;# set text&amp;#10;instr_text = &quot;Hervorragend!\n\n\nVielen Dank,\ndas Experiment ist nun zu Ende!&quot; &amp;#10;&amp;#10;# create text box&amp;#10;instr_text_stim = visual.TextStim(win, &amp;#10;                                  text = instr_text, &amp;#10;                                  height = 0.05, &amp;#10;                                  pos = (0, 0),&amp;#10;                                  color = &quot;black&quot;)&amp;#10;&amp;#10;# display the text on screen until Space is pressed&amp;#10;while True:&amp;#10;    # keep background ivory&amp;#10;    win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;    instr_text_stim.draw()&amp;#10;    win.flip()&amp;#10;    # end screen if participant presses space&amp;#10;    if 'space' in event.getKeys():        &amp;#10;        print(&quot;ending experiment now!&quot;)&amp;#10;        # end experiment&amp;#10;        break " valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="end" valType="code" updates="None" name="name"/>
      </CodeComponent>
    </Routine>
    <Routine name="demographics">
      <RoutineSettingsComponent name="demographics" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="demographics" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <FormComponent name="demographic_form" plugin="None">
        <Param val="rows" valType="str" updates="constant" name="Data Format"/>
        <Param val="Open Sans" valType="str" updates="constant" name="Font"/>
        <Param val="0.03" valType="num" updates="constant" name="Item Padding"/>
        <Param val="demographics_form.csv" valType="file" updates="constant" name="Items"/>
        <Param val="False" valType="bool" updates="constant" name="Randomize"/>
        <Param val="custom..." valType="str" updates="constant" name="Style"/>
        <Param val="0.03" valType="num" updates="constant" name="Text Height"/>
        <Param val="1.0000, 1.0000, 1.0000" valType="color" updates="constant" name="borderColor"/>
        <Param val="rgb" valType="str" updates="constant" name="colorSpace"/>
        <Param val="1" valType="num" updates="constant" name="contrast"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="1.0000, 1.0000, 1.0000" valType="color" updates="constant" name="fillColor"/>
        <Param val="-1.0000, -1.0000, -1.0000" valType="color" updates="constant" name="itemColor"/>
        <Param val="0.9608, 0.8431, 0.6863" valType="color" updates="constant" name="markerColor"/>
        <Param val="demographic_form" valType="code" updates="None" name="name"/>
        <Param val="" valType="num" updates="constant" name="opacity"/>
        <Param val="(0, 0)" valType="list" updates="constant" name="pos"/>
        <Param val="-1.0000, -1.0000, -1.0000" valType="color" updates="constant" name="responseColor"/>
        <Param val="False" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="(1.3, 0.9)" valType="list" updates="constant" name="size"/>
        <Param val="" valType="code" updates="None" name="startEstim"/>
        <Param val="time (s)" valType="str" updates="None" name="startType"/>
        <Param val="0" valType="code" updates="None" name="startVal"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="True" valType="bool" updates="None" name="syncScreenRefresh"/>
        <Param val="" valType="code" updates="None" name="validator"/>
      </FormComponent>
      <ButtonComponent name="demographic_button" plugin="None">
        <Param val="center" valType="str" updates="constant" name="anchor"/>
        <Param val="True" valType="bool" updates="constant" name="bold"/>
        <Param val="None" valType="color" updates="constant" name="borderColor"/>
        <Param val="0" valType="num" updates="constant" name="borderWidth"/>
        <Param val="" valType="extendedCode" updates="constant" name="callback"/>
        <Param val="white" valType="color" updates="constant" name="color"/>
        <Param val="rgb" valType="str" updates="constant" name="colorSpace"/>
        <Param val="1" valType="num" updates="constant" name="contrast"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="darkgrey" valType="color" updates="constant" name="fillColor"/>
        <Param val="Open Sans" valType="str" updates="constant" name="font"/>
        <Param val="True" valType="bool" updates="constant" name="forceEndRoutine"/>
        <Param val="False" valType="bool" updates="constant" name="italic"/>
        <Param val="0.06" valType="num" updates="constant" name="letterHeight"/>
        <Param val="demographic_button" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="constant" name="oncePerClick"/>
        <Param val="" valType="num" updates="constant" name="opacity"/>
        <Param val="0" valType="num" updates="constant" name="ori"/>
        <Param val="" valType="num" updates="constant" name="padding"/>
        <Param val="(0.3, -0.35)" valType="list" updates="constant" name="pos"/>
        <Param val="none" valType="str" updates="None" name="save"/>
        <Param val="False" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="(0.3, 0.12)" valType="list" updates="constant" name="size"/>
        <Param val="" valType="code" updates="None" name="startEstim"/>
        <Param val="condition" valType="str" updates="None" name="startType"/>
        <Param val="$demographic_form.complete==True" valType="code" updates="None" name="startVal"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="True" valType="bool" updates="None" name="syncScreenRefresh"/>
        <Param val="Weiter" valType="str" updates="constant" name="text"/>
        <Param val="button onset" valType="str" updates="constant" name="timeRelativeTo"/>
        <Param val="from exp settings" valType="str" updates="None" name="units"/>
        <Param val="" valType="code" updates="None" name="validator"/>
      </ButtonComponent>
    </Routine>
    <Routine name="welcome_Ishihara">
      <RoutineSettingsComponent name="welcome_Ishihara" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="welcome_Ishihara" valType="code" updates="None" name="name"/>
        <Param val="False" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <TextComponent name="instructions" plugin="None">
        <Param val="black" valType="color" updates="constant" name="color"/>
        <Param val="rgb" valType="str" updates="constant" name="colorSpace"/>
        <Param val="1" valType="num" updates="constant" name="contrast"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="None" valType="str" updates="constant" name="flip"/>
        <Param val="Open Sans" valType="str" updates="constant" name="font"/>
        <Param val="LTR" valType="str" updates="None" name="languageStyle"/>
        <Param val="0.035" valType="num" updates="constant" name="letterHeight"/>
        <Param val="instructions" valType="code" updates="None" name="name"/>
        <Param val="" valType="num" updates="constant" name="opacity"/>
        <Param val="0" valType="num" updates="constant" name="ori"/>
        <Param val="(0, 0)" valType="list" updates="constant" name="pos"/>
        <Param val="False" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="None" name="startEstim"/>
        <Param val="time (s)" valType="str" updates="None" name="startType"/>
        <Param val="0.0" valType="code" updates="None" name="startVal"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="True" valType="bool" updates="None" name="syncScreenRefresh"/>
        <Param val="Farbsehtest&amp;#10;&amp;#10;Im Folgenden werden Ihnen nun einige Bilder gezeigt, auf denen jeweils eine Zahl zu sehen ist.&amp;#10;&amp;#10;Bitte geben Sie unter jedem Bild an, welche Zahl Sie sehen. " valType="str" updates="constant" name="text"/>
        <Param val="from exp settings" valType="str" updates="None" name="units"/>
        <Param val="" valType="code" updates="None" name="validator"/>
        <Param val="" valType="num" updates="constant" name="wrapWidth"/>
      </TextComponent>
      <ButtonComponent name="instr_button" plugin="None">
        <Param val="center" valType="str" updates="constant" name="anchor"/>
        <Param val="True" valType="bool" updates="constant" name="bold"/>
        <Param val="None" valType="color" updates="constant" name="borderColor"/>
        <Param val="0" valType="num" updates="constant" name="borderWidth"/>
        <Param val="" valType="extendedCode" updates="constant" name="callback"/>
        <Param val="white" valType="color" updates="constant" name="color"/>
        <Param val="rgb" valType="str" updates="constant" name="colorSpace"/>
        <Param val="1" valType="num" updates="constant" name="contrast"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="darkgrey" valType="color" updates="constant" name="fillColor"/>
        <Param val="Open Sans" valType="str" updates="constant" name="font"/>
        <Param val="True" valType="bool" updates="constant" name="forceEndRoutine"/>
        <Param val="False" valType="bool" updates="constant" name="italic"/>
        <Param val="0.035" valType="num" updates="constant" name="letterHeight"/>
        <Param val="instr_button" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="constant" name="oncePerClick"/>
        <Param val="" valType="num" updates="constant" name="opacity"/>
        <Param val="0" valType="num" updates="constant" name="ori"/>
        <Param val="" valType="num" updates="constant" name="padding"/>
        <Param val="(0.3, -0.35)" valType="list" updates="constant" name="pos"/>
        <Param val="none" valType="str" updates="None" name="save"/>
        <Param val="False" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="(0.3, 0.12)" valType="list" updates="constant" name="size"/>
        <Param val="" valType="code" updates="None" name="startEstim"/>
        <Param val="time (s)" valType="str" updates="None" name="startType"/>
        <Param val="0" valType="code" updates="None" name="startVal"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="True" valType="bool" updates="None" name="syncScreenRefresh"/>
        <Param val="Weiter" valType="str" updates="constant" name="text"/>
        <Param val="button onset" valType="str" updates="constant" name="timeRelativeTo"/>
        <Param val="from exp settings" valType="str" updates="None" name="units"/>
        <Param val="" valType="code" updates="None" name="validator"/>
      </ButtonComponent>
    </Routine>
    <Routine name="Ishihara">
      <RoutineSettingsComponent name="Ishihara" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="Ishihara" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <ImageComponent name="ishihara_1" plugin="None">
        <Param val="center" valType="str" updates="constant" name="anchor"/>
        <Param val="$[1,1,1]" valType="color" updates="constant" name="color"/>
        <Param val="rgb" valType="str" updates="constant" name="colorSpace"/>
        <Param val="1" valType="num" updates="constant" name="contrast"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="False" valType="bool" updates="constant" name="flipHoriz"/>
        <Param val="False" valType="bool" updates="constant" name="flipVert"/>
        <Param val="$DisplayImage" valType="file" updates="set every repeat" name="image"/>
        <Param val="linear" valType="str" updates="constant" name="interpolate"/>
        <Param val="" valType="str" updates="constant" name="mask"/>
        <Param val="ishihara_1" valType="code" updates="None" name="name"/>
        <Param val="" valType="num" updates="constant" name="opacity"/>
        <Param val="0" valType="num" updates="constant" name="ori"/>
        <Param val="(0, 0.1)" valType="list" updates="constant" name="pos"/>
        <Param val="False" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="(0.5, 0.5)" valType="list" updates="constant" name="size"/>
        <Param val="" valType="code" updates="None" name="startEstim"/>
        <Param val="time (s)" valType="str" updates="None" name="startType"/>
        <Param val="0.0" valType="code" updates="None" name="startVal"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="True" valType="bool" updates="None" name="syncScreenRefresh"/>
        <Param val="128" valType="num" updates="constant" name="texture resolution"/>
        <Param val="from exp settings" valType="str" updates="None" name="units"/>
        <Param val="" valType="code" updates="None" name="validator"/>
      </ImageComponent>
      <TextboxComponent name="ishihara_number" plugin="None">
        <Param val="center" valType="str" updates="constant" name="alignment"/>
        <Param val="center" valType="str" updates="constant" name="anchor"/>
        <Param val="True" valType="bool" updates="constant" name="autoLog"/>
        <Param val="True" valType="bool" updates="constant" name="bold"/>
        <Param val="-1.0000, -1.0000, -1.0000" valType="color" updates="constant" name="borderColor"/>
        <Param val="2" valType="num" updates="constant" name="borderWidth"/>
        <Param val="-1.0000, -1.0000, -1.0000" valType="color" updates="constant" name="color"/>
        <Param val="rgb" valType="str" updates="constant" name="colorSpace"/>
        <Param val="1" valType="num" updates="constant" name="contrast"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="True" valType="bool" updates="constant" name="editable"/>
        <Param val="None" valType="color" updates="constant" name="fillColor"/>
        <Param val="False" valType="bool" updates="constant" name="flipHoriz"/>
        <Param val="False" valType="bool" updates="constant" name="flipVert"/>
        <Param val="Open Sans" valType="str" updates="constant" name="font"/>
        <Param val="False" valType="bool" updates="constant" name="italic"/>
        <Param val="LTR" valType="str" updates="None" name="languageStyle"/>
        <Param val="0.025" valType="num" updates="constant" name="letterHeight"/>
        <Param val="1.0" valType="num" updates="constant" name="lineSpacing"/>
        <Param val="ishihara_number" valType="code" updates="None" name="name"/>
        <Param val="" valType="num" updates="constant" name="opacity"/>
        <Param val="0" valType="num" updates="constant" name="ori"/>
        <Param val="hidden" valType="str" updates="constant" name="overflow"/>
        <Param val="0" valType="num" updates="constant" name="padding"/>
        <Param val="" valType="str" updates="constant" name="placeholder"/>
        <Param val="(0, -0.3)" valType="list" updates="constant" name="pos"/>
        <Param val="False" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="(0.15, 0.1)" valType="list" updates="constant" name="size"/>
        <Param val="" valType="list" updates="constant" name="speechPoint"/>
        <Param val="" valType="code" updates="None" name="startEstim"/>
        <Param val="time (s)" valType="str" updates="None" name="startType"/>
        <Param val="0.0" valType="code" updates="None" name="startVal"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="True" valType="bool" updates="None" name="syncScreenRefresh"/>
        <Param val="" valType="str" updates="set every repeat" name="text"/>
        <Param val="from exp settings" valType="str" updates="None" name="units"/>
        <Param val="" valType="code" updates="None" name="validator"/>
      </TextboxComponent>
      <ButtonComponent name="ishihara_button" plugin="None">
        <Param val="center" valType="str" updates="constant" name="anchor"/>
        <Param val="True" valType="bool" updates="constant" name="bold"/>
        <Param val="None" valType="color" updates="constant" name="borderColor"/>
        <Param val="0" valType="num" updates="constant" name="borderWidth"/>
        <Param val="" valType="extendedCode" updates="constant" name="callback"/>
        <Param val="white" valType="color" updates="constant" name="color"/>
        <Param val="rgb" valType="str" updates="constant" name="colorSpace"/>
        <Param val="1" valType="num" updates="constant" name="contrast"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="darkgrey" valType="color" updates="constant" name="fillColor"/>
        <Param val="Open Sans" valType="str" updates="constant" name="font"/>
        <Param val="True" valType="bool" updates="constant" name="forceEndRoutine"/>
        <Param val="False" valType="bool" updates="constant" name="italic"/>
        <Param val="0.035" valType="num" updates="constant" name="letterHeight"/>
        <Param val="ishihara_button" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="constant" name="oncePerClick"/>
        <Param val="" valType="num" updates="constant" name="opacity"/>
        <Param val="0" valType="num" updates="constant" name="ori"/>
        <Param val="" valType="num" updates="constant" name="padding"/>
        <Param val="(0.3, -0.35)" valType="list" updates="constant" name="pos"/>
        <Param val="none" valType="str" updates="None" name="save"/>
        <Param val="False" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="(0.3, 0.12)" valType="list" updates="constant" name="size"/>
        <Param val="" valType="code" updates="None" name="startEstim"/>
        <Param val="time (s)" valType="str" updates="None" name="startType"/>
        <Param val="0" valType="code" updates="None" name="startVal"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="True" valType="bool" updates="None" name="syncScreenRefresh"/>
        <Param val="Weiter" valType="str" updates="constant" name="text"/>
        <Param val="button onset" valType="str" updates="constant" name="timeRelativeTo"/>
        <Param val="from exp settings" valType="str" updates="None" name="units"/>
        <Param val="" valType="code" updates="None" name="validator"/>
      </ButtonComponent>
    </Routine>
    <Routine name="feedback">
      <RoutineSettingsComponent name="feedback" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="feedback" valType="code" updates="None" name="name"/>
        <Param val="False" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <CodeComponent name="code" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="if ((ishihara_number.text === corrAns.toString())) {&amp;#10;    thisFeedback = &quot;Korrekt&quot;;&amp;#10;} else {&amp;#10;    thisFeedback = &quot;Falsch&quot;;&amp;#10;}&amp;#10;" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="if ishihara_number.text == str(corrAns):&amp;#10;    thisFeedback = &quot;Korrekt&quot;&amp;#10;else:&amp;#10;    thisFeedback = &quot;Falsch&quot;" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Auto-&gt;JS" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="code" valType="code" updates="None" name="name"/>
      </CodeComponent>
      <TextComponent name="feedback_text" plugin="None">
        <Param val="-1.0000, -1.0000, -1.0000" valType="color" updates="constant" name="color"/>
        <Param val="rgb" valType="str" updates="constant" name="colorSpace"/>
        <Param val="1" valType="num" updates="constant" name="contrast"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="None" valType="str" updates="constant" name="flip"/>
        <Param val="Open Sans" valType="str" updates="constant" name="font"/>
        <Param val="LTR" valType="str" updates="None" name="languageStyle"/>
        <Param val="0.05" valType="num" updates="constant" name="letterHeight"/>
        <Param val="feedback_text" valType="code" updates="None" name="name"/>
        <Param val="" valType="num" updates="constant" name="opacity"/>
        <Param val="0" valType="num" updates="constant" name="ori"/>
        <Param val="(0, 0)" valType="list" updates="constant" name="pos"/>
        <Param val="False" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="None" name="startEstim"/>
        <Param val="time (s)" valType="str" updates="None" name="startType"/>
        <Param val="0.0" valType="code" updates="None" name="startVal"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="1.0" valType="code" updates="constant" name="stopVal"/>
        <Param val="True" valType="bool" updates="None" name="syncScreenRefresh"/>
        <Param val="$thisFeedback" valType="str" updates="set every repeat" name="text"/>
        <Param val="from exp settings" valType="str" updates="None" name="units"/>
        <Param val="" valType="code" updates="None" name="validator"/>
        <Param val="" valType="num" updates="constant" name="wrapWidth"/>
      </TextComponent>
    </Routine>
    <Routine name="pseudotext">
      <RoutineSettingsComponent name="pseudotext" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="True" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="pseudotext" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <CodeComponent name="pseudotext_paced_block" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="#################################################&amp;#10;#            Blocks with text – paced           #&amp;#10;#################################################&amp;#10;# this routine is for all blocks with texts that are paced, i.e., visually presented without space bar&amp;#10;&amp;#10;#---------- Calculate duration of words based on previous block ----------&amp;#10;# We collected RTs &amp; words from the self-paced block of each condition&amp;#10;# for the training, we only use data from the reading BL since there is no separate training for 1- and 2-back&amp;#10;&amp;#10;# we calculate letter duration based on condition since participants need more time for n-back tasks than for baseline reading&amp;#10;# BL reading blocks are based on duration during self-paced BL reading&amp;#10;# 1- and 2-back blocks are based on their respective self-paced version&amp;#10;&amp;#10;# get block kind&amp;#10;curr_block = all_blocks[exp_block_counter]&amp;#10;&amp;#10;if curr_block == &quot;Reading_pseudotext_no_click&quot;:&amp;#10;&amp;#10;    # exclude all RTs where participant was way too fast (&lt; 50 ms) or&amp;#10;    # way too slow (&gt; 2s), also remove the corresponding words from vis_task_words&amp;#10;    print(&quot;\tBL_paced_durations:&quot;, BL_paced_durations)&amp;#10;    print(&quot;\tBL_paced_words:&quot;, BL_paced_words)&amp;#10;&amp;#10;    filtered_durations_BL = []&amp;#10;    filtered_words_BL = []&amp;#10;    for duration, word in zip(BL_paced_durations, BL_paced_words):&amp;#10;        if 50 &lt;= duration &lt;= 1500:&amp;#10;            filtered_durations_BL.append(duration)&amp;#10;            filtered_words_BL.append(word)&amp;#10;    # print(&quot;\tfiltered_durations_BL:&quot;, filtered_durations_BL)&amp;#10;    # print(&quot;\tfiltered_words_BL:&quot;, filtered_words_BL)&amp;#10;&amp;#10;    # Now get number of letters (not words, I want to know how fast they read 1 letter on average!):&amp;#10;    letters_total_BL = sum(len(word) for word in filtered_words_BL)&amp;#10;    print(&quot;\tletters_total_BL:&quot;, letters_total_BL)&amp;#10;    # also get time it took in total to read them all:&amp;#10;    reading_time_total_BL = sum(filtered_durations_BL)  # in ms&amp;#10;&amp;#10;    # Now check how many words / min they read on average.&amp;#10;    # reading_speed_wpm = words_total / (reading_time_total/60000)&amp;#10;    # print(&quot;reading speed in words / min:&quot; + str(reading_speed_wpm))&amp;#10;&amp;#10;    # Check average RT / letter&amp;#10;    RT_per_letter_baseline = reading_time_total_BL / letters_total_BL&amp;#10;    print(&quot;\taverage RT per letter in ms:&quot;, RT_per_letter_baseline)&amp;#10;&amp;#10;    # save this in the output csv:&amp;#10;    thisExp.addData('RT_per_letter_baseline', RT_per_letter_baseline)&amp;#10;&amp;#10;# keep background ivory&amp;#10;win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;win.flip()&amp;#10;&amp;#10;# ----------------------------------&amp;#10;&amp;#10;# clear buffer of all previously recorded key events:&amp;#10;event.clearEvents()&amp;#10;&amp;#10;### specify settings for the current block&amp;#10;&amp;#10;### Prepare stimuli:&amp;#10;&amp;#10;# get block kind&amp;#10;curr_block = all_blocks[exp_block_counter]&amp;#10;# print(&quot;start preparing block &quot; + curr_block)&amp;#10;&amp;#10;# if it's the paced reading training block, prepare training stimuli:&amp;#10;if curr_block == &quot;Reading_pseudotext_no_click&quot;:&amp;#10;    print(f&quot;start preparing block {curr_block}&quot;)&amp;#10;&amp;#10;    # keep background ivory&amp;#10;    win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;    win.flip()&amp;#10;&amp;#10;    ### Show instructions&amp;#10;    # set instruction text&amp;#10;    instr_text = locals()[&quot;instr_&quot; + curr_block]&amp;#10;    # create text box&amp;#10;    instr_text_stim = visual.TextStim(win,&amp;#10;                                      text=instr_text,&amp;#10;                                      height=0.025,  # font height relative to height of screen&amp;#10;                                      pos=(0, 0),  # move up a bit&amp;#10;                                      color=&quot;black&quot;)&amp;#10;&amp;#10;    # show instructions on screen&amp;#10;    win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;    instr_text_stim.draw()&amp;#10;    win.flip()&amp;#10;    core.wait(3)  # wait for 3s before starting response window&amp;#10;&amp;#10;    # display the text on screen&amp;#10;    while True:&amp;#10;        # keep background ivory&amp;#10;        win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;        instr_text_stim.draw()&amp;#10;        win.flip()&amp;#10;        # end showing screen if participant presses space&amp;#10;        if 'space' in event.getKeys():&amp;#10;            break&amp;#10;&amp;#10;    # clear buffer of all previously recorded key events:&amp;#10;    event.clearEvents()&amp;#10;&amp;#10;    ### get training text&amp;#10;    curr_text_training = reading_ps_text_no_click&amp;#10;    curr_text_nr = &quot;Reading_pseudotext_no_click&quot;&amp;#10;    curr_text = curr_text_training&amp;#10;    curr_nback_cond = None&amp;#10;    # show training questions&amp;#10;    skip_questions_paced = True&amp;#10;    training_Qs_paced = False&amp;#10;&amp;#10;    # get list with targets &amp; list with colours&amp;#10;    curr_targets = all_target_lists[exp_block_counter]&amp;#10;    curr_colours = all_colour_lists[exp_block_counter]&amp;#10;&amp;#10;    # compute RTs using participant's average reading speed / letter – old, based on linear increase of RTs,&amp;#10;    # feels very unnatural however&amp;#10;    # curr_durations = [len(word) * RT_per_letter_baseline for word in curr_text]  # in ms&amp;#10;&amp;#10;    # compute RTs using participant's average reading speed / letter&amp;#10;    # we define a minimum and a maximum duration for each word&amp;#10;    # the minimum is based on 5 x RT per letter in the respective condition&amp;#10;    # the max duration is based on a time-out of 1.5 s in the reading baseline condition&amp;#10;    minimum_duration = 5 * RT_per_letter_baseline&amp;#10;    maximum_duration = 1500&amp;#10;    curr_durations = []&amp;#10;    for word in curr_text:&amp;#10;        # this is an absolute value based on estimates of how long you need to feel comfortable reading a word on&amp;#10;        # screen in a paced task&amp;#10;        # duration = RT_per_letter_baseline * math.log((len(word))) + 300&amp;#10;        # more flexible solution:&amp;#10;        duration = RT_per_letter_baseline * math.log((len(word))) + 4 * RT_per_letter_baseline&amp;#10;        if duration &lt; maximum_duration:&amp;#10;            curr_durations.append(max(duration, minimum_duration))&amp;#10;        else:&amp;#10;            curr_durations.append(maximum_duration)&amp;#10;&amp;#10;    print(f&quot;\tdurations for paced task training block: {curr_durations}&quot;)&amp;#10;&amp;#10;    # we also need the start time (let's set it as current time&amp;#10;    # at this point in the script):&amp;#10;    start_time = core.getTime()&amp;#10;&amp;#10;    ### change background colour&amp;#10;    win.setColor(dark_bg_col, colorSpace='rgb')&amp;#10;    win.flip()&amp;#10;&amp;#10;### Start block loop&amp;#10;if curr_block == &quot;Reading_pseudotext_no_click&quot;:&amp;#10;&amp;#10;    # create empty text stimulus&amp;#10;    stim = visual.TextStim(win=win,&amp;#10;                           text=&quot; &quot;,&amp;#10;                           pos=(0, 0),  # center stimulus&amp;#10;                           font=&quot;Times New Roman&quot;,&amp;#10;                           height=0.07)&amp;#10;&amp;#10;    stim.draw()&amp;#10;    win.flip()&amp;#10;&amp;#10;    # clear buffer of all previously recorded key events:&amp;#10;    event.clearEvents()&amp;#10;&amp;#10;    # CREATE CLOCKS:&amp;#10;    my_block_clock = core.Clock()&amp;#10;    my_block_clock.reset()  # start block clock&amp;#10;    start_time = my_block_clock.getTime()  # get start time of block&amp;#10;    # also create trial clock&amp;#10;    my_trial_clock = core.Clock()&amp;#10;&amp;#10;    # loop words in current text&amp;#10;    for trial_idx, curr_word in enumerate(curr_text):&amp;#10;        # print(&quot;current idx: &quot; + str(trial_idx) + &quot;, curr word:&quot; + curr_word)&amp;#10;&amp;#10;        ### prepare &amp; show current word:&amp;#10;&amp;#10;        # get current colour&amp;#10;        curr_colour = curr_colours[trial_idx]&amp;#10;&amp;#10;        # if it's a block with an n-back task, prepare target list as well&amp;#10;        if curr_nback_cond != None:&amp;#10;            curr_target = curr_targets[trial_idx]&amp;#10;            saw_target = False&amp;#10;&amp;#10;        # get duration for current word&amp;#10;        curr_duration = curr_durations[trial_idx] / 1000  # convert ms to seconds&amp;#10;        # print(&quot;duration for current word (in s):&quot;, curr_duration)&amp;#10;&amp;#10;        # get trial number (start counting from 1, so add 1)&amp;#10;        curr_trial_nr = trial_idx + 1&amp;#10;&amp;#10;        # set current word &amp; colour as content of text stimulus&amp;#10;        stim.color = curr_colour&amp;#10;        stim.text = curr_word&amp;#10;&amp;#10;        # show word on screen&amp;#10;        stim.draw()  # draw word on screen&amp;#10;&amp;#10;        # start trial clock &amp; record trial onset time&amp;#10;        my_trial_clock.reset()&amp;#10;        onset_time = my_trial_clock.getTime()&amp;#10;&amp;#10;        ### wait for key response:&amp;#10;        # In blocks with n-back task, participants can press &quot;c&quot; to indicate they saw a target colour.&amp;#10;&amp;#10;        ### start recording responses&amp;#10;        # start while loop that looks for responses&amp;#10;        # --&gt; end while loop only if duration for current word is over&amp;#10;        while my_trial_clock.getTime() &lt; (onset_time + curr_duration):&amp;#10;&amp;#10;            stim.draw()&amp;#10;            win.flip()&amp;#10;&amp;#10;            # check for key responses:&amp;#10;            keys = event.getKeys(['c', 'escape'])&amp;#10;&amp;#10;            # if there were, check responses:&amp;#10;            for key in keys:&amp;#10;&amp;#10;                # if participant pressed button &quot;c&quot; for the first time and it's an n-back condition&amp;#10;                # where they're actually supposed to do that (aka not a reading baseline condition)...&amp;#10;                if key == 'c' and curr_nback_cond != None and saw_target == False:&amp;#10;                    # get reaction time&amp;#10;                    curr_nback_RT = my_trial_clock.getTime() * 1000&amp;#10;                    # send trigger for response:&amp;#10;                    # send_trigger(&quot;response_target&quot;)&amp;#10;                    # only get first target response, we don't care if they press the button more than once:&amp;#10;                    saw_target = True&amp;#10;&amp;#10;                # If esc is pressed, end the experiment:&amp;#10;                elif key == 'escape':&amp;#10;                    # et_abort_exp()  # shut down eyetrigger and download incremental data&amp;#10;                    # close trigger &amp; close experiment&amp;#10;                    # core.wait(time_after_trigger)&amp;#10;                    # parallel.setData(0)&amp;#10;                    core.wait(0.5)&amp;#10;                    core.quit()&amp;#10;&amp;#10;        ### end trial&amp;#10;        print(&quot;\tend paced trial&quot;)&amp;#10;        # stop display of current word &amp; send trial offset trigger&amp;#10;        # win.callOnFlip(send_trigger, &quot;trial_offset&quot;)&amp;#10;&amp;#10;        # check whether response was hit, miss, false alarm or correct rejection&amp;#10;        # they saw a target and there was one: hit&amp;#10;        if curr_nback_cond != None:&amp;#10;            if saw_target and curr_target:&amp;#10;                curr_nback_response = &quot;hit&quot;&amp;#10;            # they didn't see a target but there was one: miss&amp;#10;            elif saw_target == False and curr_target:&amp;#10;                curr_nback_response = &quot;miss&quot;&amp;#10;                curr_nback_RT = None&amp;#10;            # they didn't see a target and there was none: correct rejection&amp;#10;            elif saw_target == False and curr_target == False:&amp;#10;                curr_nback_response = &quot;correct rejection&quot;&amp;#10;                curr_nback_RT = None&amp;#10;            # they saw a target but there was none: false alarm&amp;#10;            elif saw_target and curr_target == False:&amp;#10;                curr_nback_response = &quot;false alarm&quot;&amp;#10;        # if it wasn't an n-back task block:&amp;#10;        else:&amp;#10;            curr_target = None&amp;#10;            curr_nback_response = None&amp;#10;            curr_nback_RT = None&amp;#10;&amp;#10;        ### save everything in output csv&amp;#10;        thisExp.addData('colour', curr_colour)&amp;#10;        thisExp.addData('target', curr_target)&amp;#10;        thisExp.addData('nback_response', curr_nback_response)&amp;#10;        thisExp.addData('nback_RT', curr_nback_RT)  # in ms&amp;#10;        thisExp.addData('duration', curr_duration * 1000)  # in ms&amp;#10;        thisExp.addData('text_nr', curr_text_nr)&amp;#10;        thisExp.addData('trial_nr', curr_trial_nr)&amp;#10;        thisExp.addData('block_nr', exp_block_counter)&amp;#10;        thisExp.addData('block_name', curr_block)&amp;#10;        thisExp.addData('block_kind', curr_nback_cond)&amp;#10;        # careful, make sure quotes in the strings are escaped using a&amp;#10;        # quote (weird, I know) so it's properly saved in the CSV:&amp;#10;        thisExp.addData('word', escape_quotes(curr_word))&amp;#10;&amp;#10;        # start a new row in the csv&amp;#10;        thisExp.nextEntry()&amp;#10;&amp;#10;        ### IF TESTING MODE ENABLED: end loop after 4 trials&amp;#10;        if expInfo['testing_mode'] == &quot;yes&quot;:&amp;#10;            if trial_idx == 3:&amp;#10;                break&amp;#10;&amp;#10;    print(&quot;finished presenting trials&quot;)&amp;#10;&amp;#10;    # go to next block!&amp;#10;    exp_block_counter += 1&amp;#10;    print(f&quot;Going to block {exp_block_counter + 1}/13 now!&quot;)&amp;#10;    continueRoutine = False&amp;#10;&amp;#10;    # If there are still blocks left, go to next one.&amp;#10;    # If not, end loop here:&amp;#10;    if exp_block_counter == 13:&amp;#10;        blocks.finished = True&amp;#10;&amp;#10;    # Send end of block trigger:&amp;#10;    # core.wait(time_after_trigger)  # wait 3 ms&amp;#10;    # send block offset trigger&amp;#10;    # send_trigger(&quot;block_offset&quot;)&amp;#10;&amp;#10;# end current routine&amp;#10;# continueRoutine = False" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="True" valType="bool" updates="None" name="disabled"/>
        <Param val="pseudotext_paced_block" valType="code" updates="None" name="name"/>
      </CodeComponent>
    </Routine>
    <Routine name="education">
      <RoutineSettingsComponent name="education" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="education" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <FormComponent name="edu_form" plugin="None">
        <Param val="rows" valType="str" updates="constant" name="Data Format"/>
        <Param val="Open Sans" valType="str" updates="constant" name="Font"/>
        <Param val="0.03" valType="num" updates="constant" name="Item Padding"/>
        <Param val="education_form.csv" valType="file" updates="constant" name="Items"/>
        <Param val="False" valType="bool" updates="constant" name="Randomize"/>
        <Param val="custom..." valType="str" updates="constant" name="Style"/>
        <Param val="0.03" valType="num" updates="constant" name="Text Height"/>
        <Param val="1.0000, 1.0000, 1.0000" valType="color" updates="constant" name="borderColor"/>
        <Param val="rgb" valType="str" updates="constant" name="colorSpace"/>
        <Param val="1" valType="num" updates="constant" name="contrast"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="1.0000, 1.0000, 1.0000" valType="color" updates="constant" name="fillColor"/>
        <Param val="-1.0000, -1.0000, -1.0000" valType="color" updates="constant" name="itemColor"/>
        <Param val="0.9608, 0.8431, 0.6863" valType="color" updates="constant" name="markerColor"/>
        <Param val="edu_form" valType="code" updates="None" name="name"/>
        <Param val="" valType="num" updates="constant" name="opacity"/>
        <Param val="(0, 0)" valType="list" updates="constant" name="pos"/>
        <Param val="-1.0000, -1.0000, -1.0000" valType="color" updates="constant" name="responseColor"/>
        <Param val="False" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="(1.3, 0.9)" valType="list" updates="constant" name="size"/>
        <Param val="" valType="code" updates="None" name="startEstim"/>
        <Param val="time (s)" valType="str" updates="None" name="startType"/>
        <Param val="0" valType="code" updates="None" name="startVal"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="True" valType="bool" updates="None" name="syncScreenRefresh"/>
        <Param val="" valType="code" updates="None" name="validator"/>
      </FormComponent>
      <ButtonComponent name="edu_button" plugin="None">
        <Param val="center" valType="str" updates="constant" name="anchor"/>
        <Param val="True" valType="bool" updates="constant" name="bold"/>
        <Param val="None" valType="color" updates="constant" name="borderColor"/>
        <Param val="0" valType="num" updates="constant" name="borderWidth"/>
        <Param val="" valType="extendedCode" updates="constant" name="callback"/>
        <Param val="white" valType="color" updates="constant" name="color"/>
        <Param val="rgb" valType="str" updates="constant" name="colorSpace"/>
        <Param val="1" valType="num" updates="constant" name="contrast"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="darkgrey" valType="color" updates="constant" name="fillColor"/>
        <Param val="Open Sans" valType="str" updates="constant" name="font"/>
        <Param val="True" valType="bool" updates="constant" name="forceEndRoutine"/>
        <Param val="False" valType="bool" updates="constant" name="italic"/>
        <Param val="0.06" valType="num" updates="constant" name="letterHeight"/>
        <Param val="edu_button" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="constant" name="oncePerClick"/>
        <Param val="" valType="num" updates="constant" name="opacity"/>
        <Param val="0" valType="num" updates="constant" name="ori"/>
        <Param val="" valType="num" updates="constant" name="padding"/>
        <Param val="(0.3, -0.35)" valType="list" updates="constant" name="pos"/>
        <Param val="none" valType="str" updates="None" name="save"/>
        <Param val="False" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="(0.3, 0.12)" valType="list" updates="constant" name="size"/>
        <Param val="" valType="code" updates="None" name="startEstim"/>
        <Param val="condition" valType="str" updates="None" name="startType"/>
        <Param val="$edu_form.complete" valType="code" updates="None" name="startVal"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="True" valType="bool" updates="None" name="syncScreenRefresh"/>
        <Param val="Weiter" valType="str" updates="constant" name="text"/>
        <Param val="button onset" valType="str" updates="constant" name="timeRelativeTo"/>
        <Param val="from exp settings" valType="str" updates="None" name="units"/>
        <Param val="" valType="code" updates="None" name="validator"/>
      </ButtonComponent>
    </Routine>
    <Routine name="single_reading">
      <RoutineSettingsComponent name="single_reading" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="single_reading" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <CodeComponent name="single_reading_blocks" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="/* Syntax Error: Fix Python code */" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="#################################################&amp;#10;#        Blocks with text – reading only        #&amp;#10;#################################################&amp;#10;# this routine is for all blocks with texts that are paced, i.e., visually presented without space bar&amp;#10;&amp;#10;if 0 &lt;= exp_block_counter &lt;= 1:&amp;#10;    #---------- Calculate duration of words based on task training ----------&amp;#10;    # We collected RTs &amp; words from the self-paced block of each condition&amp;#10;    # for the training, we only use data from the reading BL since there is no separate training for 1- and 2-back&amp;#10;&amp;#10;    RT_per_letter_baseline = int(expInfo['RT_per_letter_baseline'])&amp;#10;    print(&quot;Using RT_per_letter_baseline for this block:&quot;, RT_per_letter_baseline)&amp;#10;&amp;#10;    # get block kind&amp;#10;    curr_block = run1_blocks[run1_block_counter]&amp;#10;&amp;#10;    # keep background ivory&amp;#10;    win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;    win.flip()&amp;#10;&amp;#10;    # ----------------------------------&amp;#10;&amp;#10;    # clear buffer of all previously recorded key events:&amp;#10;    event.clearEvents()&amp;#10;&amp;#10;    ### specify settings for the current block&amp;#10;    ### Prepare stimuli:&amp;#10;&amp;#10;    if curr_block in [&quot;Reading_Baseline_main_no_click&quot;, &quot;Reading_pseudotext_no_click&quot;]:&amp;#10;        print(f&quot;start preparing block {curr_block}&quot;)&amp;#10;&amp;#10;        # keep background ivory&amp;#10;        win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;        win.flip()&amp;#10;&amp;#10;        ### Show instructions&amp;#10;        if curr_block == &quot;Reading_Baseline_main_no_click&quot;:&amp;#10;&amp;#10;            # set instruction text&amp;#10;            instr_text = locals()[&quot;instr_&quot; + curr_block]&amp;#10;            # create text box&amp;#10;            instr_text_stim = visual.TextStim(win,&amp;#10;                                              text=instr_text,&amp;#10;                                              height=0.025,  # font height relative to height of screen&amp;#10;                                              pos=(0, 0),  # move up a bit&amp;#10;                                              color=&quot;black&quot;)&amp;#10;&amp;#10;            # show instructions on screen&amp;#10;            win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;            instr_text_stim.draw()&amp;#10;            win.flip()&amp;#10;            core.wait(1)  # wait for 3s before starting response window&amp;#10;&amp;#10;            # get text nr:&amp;#10;            curr_text_nr = all_texts_nrs_list[exp_block_counter]&amp;#10;            curr_text = locals()[curr_text_nr]&amp;#10;&amp;#10;            # compute RTs using participant's average reading speed / letter&amp;#10;            # we define a minimum and a maximum duration for each word&amp;#10;            # the minimum is based on 5 x RT per letter in the respective condition&amp;#10;            # the max duration is based on a time-out of 1.5 s in the reading baseline condition&amp;#10;            minimum_duration = 5 * RT_per_letter_baseline&amp;#10;            maximum_duration = 1500&amp;#10;            curr_durations = []&amp;#10;            for word in curr_text:&amp;#10;                duration = RT_per_letter_baseline * math.log((len(word))) + 4 * RT_per_letter_baseline&amp;#10;                if duration &lt; maximum_duration:&amp;#10;                    curr_durations.append(max(duration, minimum_duration))&amp;#10;                else:&amp;#10;                    curr_durations.append(maximum_duration)&amp;#10;&amp;#10;            # print(f&quot;\tdurations for paced baseline block: {curr_durations}&quot;)&amp;#10;&amp;#10;            ### change background colour&amp;#10;            win.setColor(dark_bg_col, colorSpace='rgb')&amp;#10;            win.flip()&amp;#10;&amp;#10;            # show main block questions&amp;#10;            skip_questions_paced = False&amp;#10;&amp;#10;        elif curr_block == &quot;Reading_pseudotext_no_click&quot;:&amp;#10;&amp;#10;            # set instruction text&amp;#10;            instr_text = locals()[&quot;instr_&quot; + curr_block]&amp;#10;            # create text box&amp;#10;            instr_text_stim = visual.TextStim(win,&amp;#10;                                              text=instr_text,&amp;#10;                                              height=0.025,  # font height relative to height of screen&amp;#10;                                              pos=(0, 0),  # move up a bit&amp;#10;                                              color=&quot;black&quot;)&amp;#10;&amp;#10;            # show instructions on screen&amp;#10;            win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;            instr_text_stim.draw()&amp;#10;            win.flip()&amp;#10;            core.wait(1)  # wait for 3s before starting response window&amp;#10;&amp;#10;            # get text nr:&amp;#10;            curr_text_nr = all_texts_nrs_list[exp_block_counter]&amp;#10;            curr_text = locals()[curr_text_nr]&amp;#10;&amp;#10;            # compute RTs using participant's average reading speed / letter&amp;#10;            # we define a minimum and a maximum duration for each word&amp;#10;            # the minimum is based on 5 x RT per letter in the respective condition&amp;#10;            # the max duration is based on a time-out of 1.5 s in the reading baseline condition&amp;#10;            minimum_duration = 5 * RT_per_letter_baseline&amp;#10;            maximum_duration = 1500&amp;#10;            curr_durations = []&amp;#10;            for word in curr_text:&amp;#10;                duration = RT_per_letter_baseline * math.log((len(word))) + 4 * RT_per_letter_baseline&amp;#10;                if duration &lt; maximum_duration:&amp;#10;                    curr_durations.append(max(duration, minimum_duration))&amp;#10;                else:&amp;#10;                    curr_durations.append(maximum_duration)&amp;#10;&amp;#10;            # print(f&quot;\tdurations for paced baseline block: {curr_durations}&quot;)&amp;#10;&amp;#10;            ### change background colour&amp;#10;            win.setColor(dark_bg_col, colorSpace='rgb')&amp;#10;            win.flip()&amp;#10;&amp;#10;            # show main block questions&amp;#10;            skip_questions_paced = True&amp;#10;&amp;#10;        # Define n-back level&amp;#10;        curr_nback_cond = None&amp;#10;&amp;#10;        print(f&quot;\tcurrent n-back condition: {curr_nback_cond}&quot;)&amp;#10;        print(f&quot;\tcurrent text: {curr_text_nr}&quot;)&amp;#10;        print(f&quot;\texp block counter: {exp_block_counter}&quot;)&amp;#10;&amp;#10;        # get list with targets &amp; list with colours&amp;#10;        curr_targets = run1_target_lists[run1_block_counter]&amp;#10;        curr_colours = run1_colour_lists[run1_block_counter]&amp;#10;&amp;#10;    ### Start block loop&amp;#10;    if curr_block in [&quot;Reading_Baseline_main_no_click&quot;, &quot;Reading_pseudotext_no_click&quot;]:&amp;#10;&amp;#10;        # create empty text stimulus&amp;#10;        stim = visual.TextStim(win=win,&amp;#10;                               text=&quot; &quot;,&amp;#10;                               pos=(0, 0),  # center stimulus&amp;#10;                               font=&quot;Times New Roman&quot;,&amp;#10;                               height=0.07)&amp;#10;&amp;#10;        stim.draw()&amp;#10;        win.flip()&amp;#10;&amp;#10;        # clear buffer of all previously recorded key events:&amp;#10;        event.clearEvents()&amp;#10;&amp;#10;        # CREATE CLOCKS:&amp;#10;        my_block_clock = core.Clock()&amp;#10;        my_block_clock.reset()  # start block clock&amp;#10;        start_time = my_block_clock.getTime()  # get start time of block&amp;#10;        # also create trial clock&amp;#10;        my_trial_clock = core.Clock()&amp;#10;&amp;#10;        # loop words in current text&amp;#10;        for trial_idx, curr_word in enumerate(curr_text):&amp;#10;            # print(&quot;current idx: &quot; + str(trial_idx) + &quot;, curr word:&quot; + curr_word)&amp;#10;&amp;#10;            ### prepare &amp; show current word:&amp;#10;            # get current colour&amp;#10;            curr_colour = curr_colours[trial_idx]&amp;#10;&amp;#10;            # get duration for current word&amp;#10;            curr_duration = curr_durations[trial_idx] / 1000  # convert ms to seconds&amp;#10;            # print(&quot;duration for current word (in s):&quot;, curr_duration)&amp;#10;&amp;#10;            # get trial number (start counting from 1, so add 1)&amp;#10;            curr_trial_nr = trial_idx + 1&amp;#10;&amp;#10;            # set current word &amp; colour as content of text stimulus&amp;#10;            stim.color = curr_colour&amp;#10;            stim.text = curr_word&amp;#10;&amp;#10;            # show word on screen&amp;#10;            stim.draw()  # draw word on screen&amp;#10;&amp;#10;            # start trial clock &amp; record trial onset time&amp;#10;            my_trial_clock.reset()&amp;#10;            onset_time = my_trial_clock.getTime()&amp;#10;&amp;#10;            ### start recording responses&amp;#10;            # start while loop that looks for responses&amp;#10;            # --&gt; end while loop only if duration for current word is over&amp;#10;            while my_trial_clock.getTime() &lt; (onset_time + curr_duration):&amp;#10;&amp;#10;                stim.draw()&amp;#10;                win.flip()&amp;#10;&amp;#10;                # check for key responses:&amp;#10;                keys = event.getKeys(['c', 'escape'])&amp;#10;&amp;#10;                # if there were, check responses:&amp;#10;                for key in keys:&amp;#10;&amp;#10;                    # if participant pressed button &quot;c&quot; for the first time and it's an n-back condition&amp;#10;                    # where they're actually supposed to do that (aka not a reading baseline condition)...&amp;#10;                    if key == 'c' and curr_nback_cond != None and saw_target == False:&amp;#10;                        # get reaction time&amp;#10;                        curr_nback_RT = my_trial_clock.getTime() * 1000&amp;#10;                        # send trigger for response:&amp;#10;                        # send_trigger(&quot;response_target&quot;)&amp;#10;                        # only get first target response, we don't care if they press the button more than once:&amp;#10;                        saw_target = True&amp;#10;&amp;#10;                    # If esc is pressed, end the experiment:&amp;#10;                    elif key == 'escape':&amp;#10;                        # et_abort_exp()  # shut down eyetrigger and download incremental data&amp;#10;                        # close trigger &amp; close experiment&amp;#10;                        # core.wait(time_after_trigger)&amp;#10;                        # parallel.setData(0)&amp;#10;                        core.wait(0.5)&amp;#10;                        core.quit()&amp;#10;&amp;#10;            ### end trial&amp;#10;            print(&quot;\tend paced trial&quot;)&amp;#10;            # stop display of current word &amp; send trial offset trigger&amp;#10;            # win.callOnFlip(send_trigger, &quot;trial_offset&quot;)&amp;#10;&amp;#10;            # check whether response was hit, miss, false alarm or correct rejection&amp;#10;            # they saw a target and there was one: hit&amp;#10;            if curr_nback_cond != None:&amp;#10;                if saw_target and curr_target:&amp;#10;                    curr_nback_response = &quot;hit&quot;&amp;#10;                # they didn't see a target but there was one: miss&amp;#10;                elif saw_target == False and curr_target:&amp;#10;                    curr_nback_response = &quot;miss&quot;&amp;#10;                    curr_nback_RT = None&amp;#10;                # they didn't see a target and there was none: correct rejection&amp;#10;                elif saw_target == False and curr_target == False:&amp;#10;                    curr_nback_response = &quot;correct rejection&quot;&amp;#10;                    curr_nback_RT = None&amp;#10;                # they saw a target but there was none: false alarm&amp;#10;                elif saw_target and curr_target == False:&amp;#10;                    curr_nback_response = &quot;false alarm&quot;&amp;#10;            # if it wasn't an n-back task block:&amp;#10;            else:&amp;#10;                curr_target = None&amp;#10;                curr_nback_response = None&amp;#10;                curr_nback_RT = None&amp;#10;&amp;#10;            ### save everything in output csv&amp;#10;            thisExp.addData('colour', curr_colour)&amp;#10;            thisExp.addData('target', curr_target)&amp;#10;            thisExp.addData('nback_response', curr_nback_response)&amp;#10;            thisExp.addData('nback_RT', curr_nback_RT)  # in ms&amp;#10;            thisExp.addData('duration', curr_duration * 1000)  # in ms&amp;#10;            thisExp.addData('text_nr', curr_text_nr)&amp;#10;            thisExp.addData('trial_nr', curr_trial_nr)&amp;#10;            thisExp.addData('block_nr_exp', exp_block_counter)&amp;#10;            thisExp.addData('run_nr', 'run1')&amp;#10;            thisExp.addData('block_nr_run', run1_block_counter)&amp;#10;            thisExp.addData('block_name', curr_block)&amp;#10;            thisExp.addData('n-back_level', curr_nback_cond)&amp;#10;            # careful, make sure quotes in the strings are escaped using a&amp;#10;            # quote (weird, I know) so it's properly saved in the CSV:&amp;#10;            thisExp.addData('word', escape_quotes(curr_word))&amp;#10;&amp;#10;            # start a new row in the csv&amp;#10;            thisExp.nextEntry()&amp;#10;&amp;#10;            ### IF TESTING MODE ENABLED: end loop after 4 trials&amp;#10;            if expInfo['testing_mode'] == &quot;yes&quot;:&amp;#10;                if trial_idx == 3:&amp;#10;                    break&amp;#10;&amp;#10;        print(&quot;finished presenting trials&quot;)&amp;#10;&amp;#10;        if curr_block == &quot;Reading_pseudotext_no_click&quot;:&amp;#10;            # show main block questions&amp;#10;            skip_questions_paced = True&amp;#10;&amp;#10;            # go to next run&amp;#10;            exp_block_counter += 1&amp;#10;            run1_block_counter += 1&amp;#10;            print(f&quot;Going to block {exp_block_counter + 1}/10 in the experiment now!&quot;)&amp;#10;            continueRoutine = False&amp;#10;&amp;#10;            # If there are still blocks left, go to next one.&amp;#10;            # If not, end loop here:&amp;#10;            if run1_block_counter == 2:&amp;#10;                print(f&quot;Finished block {run1_block_counter}/2 in run 1, moving on to next run!&quot;)&amp;#10;                loop_run1_single_reading.finished = True&amp;#10;&amp;#10;        # Send end of block trigger:&amp;#10;        # core.wait(time_after_trigger)  # wait 3 ms&amp;#10;        # send block offset trigger&amp;#10;        # send_trigger(&quot;block_offset&quot;)" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="single_reading_blocks" valType="code" updates="None" name="name"/>
      </CodeComponent>
      <CodeComponent name="questions" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="/* Syntax Error: Fix Python code */" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="##########################################################&amp;#10;#              Text Comprehension Questions              #&amp;#10;##########################################################&amp;#10;&amp;#10;def setup_question(question_text, answers_text):&amp;#10;    question = visual.TextStim(win, text=question_text, pos=(0, 0.2), color=&quot;black&quot;, height=0.025, anchorHoriz='center', alignText='center', wrapWidth=1)&amp;#10;    answers = [visual.TextStim(win, text=ans, pos=(-0.75, 0.1 - i * 0.05), color=&quot;black&quot;, height=0.025, wrapWidth=1.5, anchorHoriz='left', alignText='center') for i, ans in enumerate(answers_text)]&amp;#10;    return question, answers&amp;#10;&amp;#10;def display_question(question, answers):&amp;#10;    question.autoDraw = True&amp;#10;    for answer in answers:&amp;#10;        answer.autoDraw = True&amp;#10;    instr_text.autoDraw = True&amp;#10;    win.flip()&amp;#10;&amp;#10;def get_response(answers, correct_answer):&amp;#10;    while True:&amp;#10;        keys = defaultKeyboard.getKeys(['1', '2', '3', '4'])&amp;#10;        if keys:&amp;#10;            key_name = keys[0].name  # Get the name of the first key pressed&amp;#10;&amp;#10;            # Now, use the key_name to determine the action&amp;#10;            if key_name == '1':&amp;#10;                index = 0  # Corresponds to the first choice&amp;#10;            elif key_name == '2':&amp;#10;                index = 1  # Corresponds to the second choice&amp;#10;            elif key_name == '3':&amp;#10;                index = 2  # Corresponds to the third choice&amp;#10;            elif key_name == '4':&amp;#10;                index = 3  # Corresponds to the fourth choice&amp;#10;            else:&amp;#10;                index = None  # Just in case, not really needed if you're sure about the input keys&amp;#10;&amp;#10;            # Proceed with your logic based on the index&amp;#10;            if index is not None:&amp;#10;                chosen_ans = chr(97 + index)  # Convert index to letter ('a', 'b', 'c', 'd')&amp;#10;                is_correct = chosen_ans == correct_answer  # Assuming correct_answer is defined ('a', 'b', 'c', or 'd')&amp;#10;                for i, answer in enumerate(answers):&amp;#10;                    answer.setColor(&quot;green&quot; if i == index else &quot;black&quot;)&amp;#10;                win.flip()&amp;#10;                core.wait(0.5)  # Ensure the color change is visible&amp;#10;                break&amp;#10;    return chosen_ans, is_correct&amp;#10;&amp;#10;def reset_answers(answers):&amp;#10;    for answer in answers:&amp;#10;        answer.setColor(&quot;black&quot;)&amp;#10;    question.autoDraw = False&amp;#10;    instr_text.autoDraw = False&amp;#10;    for answer in answers:&amp;#10;        answer.autoDraw = False&amp;#10;&amp;#10;# Example usage:&amp;#10;win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;win.flip()&amp;#10;instr_text = visual.TextStim(win, text=&quot;(Bitte benutzen Sie die Tasten 1, 2, 3 und 4, um die richtige Antwort auszuwählen.)&quot;, color=&quot;grey&quot;, pos=(0, -0.3), wrapWidth=2, height=0.018)&amp;#10;event.clearEvents()&amp;#10;&amp;#10;# Assuming skip_questions_paced and other variables are defined&amp;#10;if not skip_questions_paced:&amp;#10;    # Setup for Q1&amp;#10;    Q1_text = locals()[curr_text_nr + &quot;_Q1&quot;]&amp;#10;    Q1_answers = locals()[curr_text_nr + &quot;_Q1_ans&quot;]&amp;#10;    Q1_correct = locals()[curr_text_nr + &quot;_Q1_corr&quot;]&amp;#10;&amp;#10;    question, answers = setup_question(Q1_text, Q1_answers)&amp;#10;    display_question(question, answers)&amp;#10;    chosen_ans, is_correct = get_response(answers, Q1_correct)&amp;#10;    print(f&quot;Chosen answer for Q1: {chosen_ans}, Correct: {is_correct}&quot;)&amp;#10;    reset_answers(answers)&amp;#10;&amp;#10;    # save data:&amp;#10;    thisExp.addData('question', 'Q1')&amp;#10;    thisExp.addData('chosen_ans', chosen_ans)&amp;#10;    thisExp.addData('ans_correct', chosen_ans == Q1_correct)&amp;#10;    thisExp.addData('text_nr', curr_text_nr)&amp;#10;    thisExp.addData('block_nr', exp_block_counter)&amp;#10;    thisExp.addData('block_name', curr_block)&amp;#10;    thisExp.addData('block_kind', curr_nback_cond)&amp;#10;&amp;#10;    # start a new row in the csv&amp;#10;    thisExp.nextEntry()&amp;#10;&amp;#10;    # Setup for Q2&amp;#10;    Q2_text = locals()[curr_text_nr + &quot;_Q2&quot;]&amp;#10;    Q2_answers = locals()[curr_text_nr + &quot;_Q2_ans&quot;]&amp;#10;    Q2_correct = locals()[curr_text_nr + &quot;_Q2_corr&quot;]&amp;#10;&amp;#10;    question, answers = setup_question(Q2_text, Q2_answers)&amp;#10;    display_question(question, answers)&amp;#10;    chosen_ans, is_correct = get_response(answers, Q2_correct)&amp;#10;    print(f&quot;Chosen answer for Q2: {chosen_ans}, Correct: {is_correct}&quot;)&amp;#10;    reset_answers(answers)&amp;#10;&amp;#10;    # save data:&amp;#10;    thisExp.addData('question', 'Q2')&amp;#10;    thisExp.addData('chosen_ans', chosen_ans)&amp;#10;    thisExp.addData('ans_correct', chosen_ans == Q2_correct)&amp;#10;    thisExp.addData('text_nr', curr_text_nr)&amp;#10;    thisExp.addData('block_nr', exp_block_counter)&amp;#10;    thisExp.addData('block_name', curr_block)&amp;#10;    thisExp.addData('block_kind', curr_nback_cond)&amp;#10;&amp;#10;    # start a new row in the csv&amp;#10;    thisExp.nextEntry()&amp;#10;&amp;#10;    # Setup for Q3&amp;#10;    Q3_text = locals()[curr_text_nr + &quot;_Q3&quot;]&amp;#10;    Q3_answers = locals()[curr_text_nr + &quot;_Q3_ans&quot;]&amp;#10;    Q3_correct = locals()[curr_text_nr + &quot;_Q3_corr&quot;]&amp;#10;&amp;#10;    question, answers = setup_question(Q3_text, Q3_answers)&amp;#10;    display_question(question, answers)&amp;#10;    chosen_ans, is_correct = get_response(answers, Q3_correct)&amp;#10;    print(f&quot;Chosen answer for Q3: {chosen_ans}, Correct: {is_correct}&quot;)&amp;#10;    reset_answers(answers)&amp;#10;&amp;#10;    # save data:&amp;#10;    thisExp.addData('question', 'Q3')&amp;#10;    thisExp.addData('chosen_ans', chosen_ans)&amp;#10;    thisExp.addData('ans_correct', chosen_ans == Q3_correct)&amp;#10;    thisExp.addData('text_nr', curr_text_nr)&amp;#10;    thisExp.addData('block_nr', exp_block_counter)&amp;#10;    thisExp.addData('block_name', curr_block)&amp;#10;    thisExp.addData('block_kind', curr_nback_cond)&amp;#10;&amp;#10;    # start a new row in the csv&amp;#10;    thisExp.nextEntry()&amp;#10;&amp;#10;    # go to next block!&amp;#10;    exp_block_counter += 1&amp;#10;    run1_block_counter += 1&amp;#10;    print(f&quot;Going to block {exp_block_counter + 1}/20 in the experiment now!&quot;)&amp;#10;    print(f&quot;Going to block {run1_block_counter + 1}/2 in run 1 now!&quot;)&amp;#10;    continueRoutine = False&amp;#10;&amp;#10;    # If there are still blocks left, go to next one.&amp;#10;    # If not, end loop here:&amp;#10;    if run1_block_counter == 2:&amp;#10;        loop_run1_single_reading.finished = True" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="questions" valType="code" updates="None" name="name"/>
      </CodeComponent>
    </Routine>
    <Routine name="single_nback">
      <RoutineSettingsComponent name="single_nback" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="single_nback" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <CodeComponent name="single_nback_blocks" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="#################################################&amp;#10;#        Blocks w/o text – single n-back        #&amp;#10;#################################################&amp;#10;# this routine is for all blocks where there are&amp;#10;# coloured rectangles instead of words and participants are presented with a paced version, i.e., rectangles are presented based on their reaction times in a&amp;#10;&amp;#10;print(f&quot;exp_block_counter: {exp_block_counter}&quot;)&amp;#10;if 2 &lt;= exp_block_counter &lt;= 5:&amp;#10;#if exp_block_counter == 2 and run1_block_counter == 2 and run2_block_counter == 0:&amp;#10;&amp;#10;    event. Mouse(visible=False)&amp;#10;    # keep background ivory&amp;#10;    win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;    win.flip()&amp;#10;&amp;#10;    # clear buffer of all previously recorded key events:&amp;#10;    event.clearEvents()&amp;#10;&amp;#10;    ### Prepare stimuli:&amp;#10;&amp;#10;    RT_per_rectangle_oneback_single = int(expInfo['RT_per_rectangle_oneback_single'])&amp;#10;    RT_per_rectangle_twoback_single = int(expInfo['RT_per_rectangle_twoback_single'])&amp;#10;&amp;#10;    # get block kind&amp;#10;    curr_block = run2_blocks[run2_block_counter]&amp;#10;    print(f&quot;curr_block: {curr_block}&quot;)&amp;#10;&amp;#10;    if curr_block in [&quot;1back_single_main_no_click&quot;, &quot;2back_single_main_no_click&quot;]:&amp;#10;        print(f&quot;start preparing block {curr_block}&quot;)&amp;#10;        if curr_block == &quot;1back_single_main_no_click&quot;:&amp;#10;            print(&quot;Using RT_per_rectangle_oneback for this block:&quot;, RT_per_rectangle_oneback_single)&amp;#10;&amp;#10;        elif curr_block == &quot;2back_single_main_no_click&quot;:&amp;#10;            print(&quot;Using RT_per_rectangle_twoback for this block:&quot;, RT_per_rectangle_twoback_single)&amp;#10;&amp;#10;        # keep background ivory&amp;#10;        win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;        win.flip()&amp;#10;&amp;#10;        ### Show instructions&amp;#10;        # set instruction text&amp;#10;        instr_text = locals()[&quot;instr_&quot; + curr_block]&amp;#10;        # create text box&amp;#10;        instr_text_stim = visual.TextStim(win,&amp;#10;                                          text=instr_text,&amp;#10;                                          height=0.025,  # font height relative to height of screen&amp;#10;                                          pos=(0, 0.2),  # move up a bit&amp;#10;                                          color=&quot;black&quot;)&amp;#10;        # create ImageStim object&amp;#10;        curr_instr_pic = visual.ImageStim(win,&amp;#10;                                          size=(0.8, 0.3),&amp;#10;                                          pos=(0, -0.2),&amp;#10;                                          image=locals()[&quot;instr_pic_&quot; + curr_block])  # set path to image here&amp;#10;&amp;#10;        # show instructions on screen&amp;#10;        instr_text_stim.draw()&amp;#10;        curr_instr_pic.draw()&amp;#10;        win.flip()&amp;#10;        core.wait(3)  # wait for 3s before starting response window&amp;#10;&amp;#10;        ### change background colour&amp;#10;        win.setColor(dark_bg_col, colorSpace='rgb')&amp;#10;        win.flip()&amp;#10;&amp;#10;        # get n-back condition:&amp;#10;        curr_nback_cond = curr_block[0]  # get first character of block name&amp;#10;&amp;#10;        # if it is a 1 or a 2, set that as current n-back level:&amp;#10;        if curr_nback_cond in ['1', '2']:&amp;#10;            curr_nback_cond == int(curr_nback_cond)&amp;#10;        # if it's neither 1 nor 2, it has to be a block without n-back,&amp;#10;        # so set curr_nback_cond to None&amp;#10;        else:&amp;#10;            curr_nback_cond = None&amp;#10;&amp;#10;        print(f&quot;\tcurrent n-back condition: {curr_nback_cond}&quot;)&amp;#10;&amp;#10;        # get list with targets &amp; list with colours&amp;#10;        curr_targets = run2_target_lists[run2_block_counter]&amp;#10;        curr_colours = run1_colour_lists[run2_block_counter]&amp;#10;&amp;#10;        # determine duration per rectangle for this block&amp;#10;        # we use average time per rectangle as duration here and add an increment over the duration of the block&amp;#10;        if curr_block == &quot;1back_single_main_no_click&quot;:&amp;#10;            curr_durations = []&amp;#10;            for rect in curr_targets:&amp;#10;                curr_durations.append(RT_per_rectangle_oneback_single)&amp;#10;&amp;#10;            # Latency factor of an incremental increase (increment per trial = 3 ms) added over duration of entire&amp;#10;            # block assuming that participants get tired of the course of the block and thus need a bit more&amp;#10;            # time:&amp;#10;            # Increment of 3 ms per trial&amp;#10;            increment_per_trial = 3&amp;#10;            for i in range(len(curr_durations)):&amp;#10;                # Calculate incremental increase for current trial&amp;#10;                increment = i * increment_per_trial&amp;#10;                # Add incremental increase to current trial's duration&amp;#10;                curr_durations[i] += increment&amp;#10;&amp;#10;        elif curr_block == &quot;2back_single_main_no_click&quot;:&amp;#10;            curr_durations = []&amp;#10;            for rect in curr_targets:&amp;#10;                curr_durations.append(RT_per_rectangle_twoback_single)&amp;#10;&amp;#10;            # Latency factor of an incremental increase (increment per trial = 3 ms) added over duration of entire&amp;#10;            # block assuming that participants get tired of the course of the block and thus need a bit more&amp;#10;            # time:&amp;#10;            # Increment of 3 ms per trial&amp;#10;            increment_per_trial = 3&amp;#10;            for i in range(len(curr_durations)):&amp;#10;                # Calculate incremental increase for current trial&amp;#10;                increment = i * increment_per_trial&amp;#10;                # Add incremental increase to current trial's duration&amp;#10;                curr_durations[i] += increment&amp;#10;&amp;#10;        ### Start block loop&amp;#10;&amp;#10;        # CREATE CLOCKS:&amp;#10;        my_block_clock = core.Clock()&amp;#10;        my_block_clock.reset()  # start block clock&amp;#10;        start_time = my_block_clock.getTime()  # get start time of block&amp;#10;        # also create trial clock&amp;#10;        my_trial_clock = core.Clock()&amp;#10;&amp;#10;        # create empty stimulus&amp;#10;        stim = visual.Rect(win=win,&amp;#10;                           width=0.4,  # width = 3 * 1° visual angle (to make it look rectangle-ish)&amp;#10;                           height=0.15,  # height = 1° visual angle (just like words)&amp;#10;                           # colorSpace = &quot;hex&quot;,&amp;#10;                           pos=(0, 0))  # center stimulus&amp;#10;&amp;#10;        stim.draw()&amp;#10;        win.flip()&amp;#10;&amp;#10;        # clear buffer of all previously recorded key events:&amp;#10;        event.clearEvents()&amp;#10;&amp;#10;        # loop colours in current text&amp;#10;        for trial_idx, curr_col in enumerate(curr_colours):&amp;#10;            # print(&quot;current idx: &quot; + str(trial_idx) + &quot;, curr colour:&quot; + curr_col)&amp;#10;&amp;#10;            ### prepare &amp; show current trial:&amp;#10;            my_trial_clock.reset()  # start trial clock&amp;#10;            onset_time = my_trial_clock.getTime()&amp;#10;&amp;#10;            # if it's a block with an n-back task, prepare target list&amp;#10;            if curr_nback_cond != None:&amp;#10;                curr_target = curr_targets[trial_idx]&amp;#10;                saw_target = False&amp;#10;&amp;#10;            # get duration for current trial&amp;#10;            curr_duration = curr_durations[trial_idx] / 1000  # convert ms to seconds&amp;#10;&amp;#10;            # get trial number (start counting from 1, so add 1)&amp;#10;            curr_trial_nr = trial_idx + 1&amp;#10;&amp;#10;            ### ISI: wait for 200 ms&amp;#10;            while my_trial_clock.getTime() &lt; 0.2:&amp;#10;                win.flip()  # don't draw anything&amp;#10;                core.wait(0.005)  # wait 5 ms before next iteration&amp;#10;&amp;#10;            # set current colour as colour of rectangle&amp;#10;            stim.fillColor = curr_col&amp;#10;&amp;#10;            # draw stimulus on screen&amp;#10;            stim.draw()&amp;#10;            win.flip()&amp;#10;&amp;#10;            # show stimulus on screen &amp; send trigger:&amp;#10;            stim.draw()  # draw stimulus on screen&amp;#10;            # update the window to clear the screen and display&amp;#10;            # the stimulus&amp;#10;&amp;#10;            # start trial clock for measuring RTs from stimulus onset&amp;#10;            my_trial_clock.reset()&amp;#10;            onset_time = my_trial_clock.getTime()&amp;#10;&amp;#10;            ### start recording responses&amp;#10;            # start &quot;endless&quot; while loop that looks for responses&amp;#10;            # --&gt; end while loop only if duration for current word is over&amp;#10;            while my_trial_clock.getTime() &lt; (onset_time + curr_duration):&amp;#10;&amp;#10;                # draw stimulus on screen&amp;#10;                stim.draw()&amp;#10;                win.flip()&amp;#10;&amp;#10;                # check for responses:&amp;#10;                keys = event.getKeys(['c', 'escape'])&amp;#10;&amp;#10;                # check if there was a response. If there wasn't, we can go straight&amp;#10;                # to the next iteration which will hopefully save us some dropped&amp;#10;                # frames in the flicker.&amp;#10;                for key in keys:&amp;#10;&amp;#10;                    # if participant pressed button &quot;c&quot; for the first time and it's an n-back condition&amp;#10;                    # where they're actually supposed to do that (aka not a reading baseline condition)...&amp;#10;                    if key == 'c' and curr_nback_cond != None and saw_target == False:&amp;#10;                        # get reaction time&amp;#10;                        curr_nback_RT = my_trial_clock.getTime() * 1000&amp;#10;                        # send trigger for response:&amp;#10;                        # send_trigger(&quot;response_target&quot;)&amp;#10;                        # only get first target response, we don't care if they press the button more than once:&amp;#10;                        saw_target = True&amp;#10;&amp;#10;                    # If esc is pressed, end the experiment:&amp;#10;                    elif key == 'escape':&amp;#10;                        # et_abort_exp()  # shut down eyetrigger and download incremental data&amp;#10;                        # close trigger &amp; close experiment&amp;#10;                        # core.wait(time_after_trigger)&amp;#10;                        # parallel.setData(0)&amp;#10;                        core.wait(0.5)&amp;#10;                        core.quit()&amp;#10;&amp;#10;            ### end trial&amp;#10;            print(&quot;end paced rect trial&quot;)&amp;#10;&amp;#10;            # check whether response was hit, miss, false alarm or correct rejection&amp;#10;            # they saw a target and there was one: hit&amp;#10;            if curr_nback_cond != None:&amp;#10;                if saw_target and curr_target:&amp;#10;                    curr_nback_response = &quot;hit&quot;&amp;#10;                # they didn't see a target but there was one: miss&amp;#10;                elif saw_target == False and curr_target:&amp;#10;                    curr_nback_response = &quot;miss&quot;&amp;#10;                    curr_nback_RT = None&amp;#10;                # they didn't see a target and there was none: correct rejection&amp;#10;                elif saw_target == False and curr_target == False:&amp;#10;                    curr_nback_response = &quot;correct rejection&quot;&amp;#10;                    curr_nback_RT = None&amp;#10;                # they saw a target but there was none: false alarm&amp;#10;                elif saw_target and curr_target == False:&amp;#10;                    curr_nback_response = &quot;false alarm&quot;&amp;#10;            # if it wasn't an n-back task block:&amp;#10;            else:&amp;#10;                curr_target = None&amp;#10;                curr_nback_response = None&amp;#10;                curr_nback_RT = None&amp;#10;&amp;#10;            ### save everything in output csv&amp;#10;            thisExp.addData('colour', curr_col)&amp;#10;            thisExp.addData('target', curr_target)&amp;#10;            thisExp.addData('nback_response', curr_nback_response)&amp;#10;            thisExp.addData('nback_RT', curr_nback_RT)  # in ms&amp;#10;            thisExp.addData('duration', curr_duration)  # in ms&amp;#10;            thisExp.addData('trial_nr', curr_trial_nr)&amp;#10;            thisExp.addData('block_nr_exp', exp_block_counter)&amp;#10;            thisExp.addData('run_nr', 'run2')&amp;#10;            thisExp.addData('block_nr_run', run2_block_counter)&amp;#10;            thisExp.addData('block_name', curr_block)&amp;#10;            thisExp.addData('n-back_level', curr_nback_cond)&amp;#10;&amp;#10;            # start a new row in the csv&amp;#10;            thisExp.nextEntry()&amp;#10;&amp;#10;            ### IF TESTING MODE ENABLED: end loop after 4 trials&amp;#10;            if expInfo['testing_mode'] == &quot;yes&quot;:&amp;#10;                if trial_idx == 3:&amp;#10;                    break&amp;#10;&amp;#10;        print(&quot;\t\tfinished presenting trials&quot;)&amp;#10;&amp;#10;        # change background colour from grey (RGB: 10, 10, 10)&amp;#10;        # to ivory (RGB: 240, 223, 204)&amp;#10;        # win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;        # win.flip()&amp;#10;&amp;#10;        # add 1 to the block counter to go load the next block&amp;#10;        exp_block_counter += 1&amp;#10;        run2_block_counter += 1&amp;#10;        print(f&quot;Going to block {exp_block_counter + 1}/10 in the experiment now!&quot;)&amp;#10;        continueRoutine = False&amp;#10;&amp;#10;        # If there are still blocks left, go to next one.&amp;#10;        # If not, end loop here:&amp;#10;        if run2_block_counter == 4:&amp;#10;            print(f&quot;Finished block {run2_block_counter}/4 in run 2, moving on to next run!&quot;)&amp;#10;            loop_run2_single_nback.finished = True" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="#################################################&amp;#10;#        Blocks w/o text – single n-back        #&amp;#10;#################################################&amp;#10;# this routine is for all blocks where there are&amp;#10;# coloured rectangles instead of words and participants are presented with a paced version, i.e., rectangles are presented based on their reaction times in a&amp;#10;&amp;#10;if 2 &lt;= exp_block_counter &lt;= 5:&amp;#10;&amp;#10;    event. Mouse(visible=False)&amp;#10;    # keep background ivory&amp;#10;    win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;    win.flip()&amp;#10;&amp;#10;    # clear buffer of all previously recorded key events:&amp;#10;    event.clearEvents()&amp;#10;&amp;#10;    ### Prepare stimuli:&amp;#10;&amp;#10;    RT_per_rectangle_oneback_single = int(expInfo['RT_per_rectangle_oneback_single'])&amp;#10;    RT_per_rectangle_twoback_single = int(expInfo['RT_per_rectangle_twoback_single'])&amp;#10;&amp;#10;    # get block kind&amp;#10;    curr_block = run2_blocks[run2_block_counter]&amp;#10;&amp;#10;    if curr_block in [&quot;1back_single_main_no_click&quot;, &quot;2back_single_main_no_click&quot;]:&amp;#10;        print(f&quot;start preparing block {curr_block}&quot;)&amp;#10;        if curr_block == &quot;1back_single_main_no_click&quot;:&amp;#10;            print(&quot;Using RT_per_rectangle_oneback for this block:&quot;, RT_per_rectangle_oneback_single)&amp;#10;&amp;#10;        elif curr_block == &quot;2back_single_main_no_click&quot;:&amp;#10;            print(&quot;Using RT_per_rectangle_twoback for this block:&quot;, RT_per_rectangle_twoback_single)&amp;#10;&amp;#10;        # keep background ivory&amp;#10;        win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;        win.flip()&amp;#10;&amp;#10;        ### Show instructions&amp;#10;        # set instruction text&amp;#10;        instr_text = locals()[&quot;instr_&quot; + curr_block]&amp;#10;        # create text box&amp;#10;        instr_text_stim = visual.TextStim(win,&amp;#10;                                          text=instr_text,&amp;#10;                                          height=0.025,  # font height relative to height of screen&amp;#10;                                          pos=(0, 0.2),  # move up a bit&amp;#10;                                          color=&quot;black&quot;)&amp;#10;        # create ImageStim object&amp;#10;        curr_instr_pic = visual.ImageStim(win,&amp;#10;                                          size=(0.8, 0.3),&amp;#10;                                          pos=(0, -0.2),&amp;#10;                                          image=locals()[&quot;instr_pic_&quot; + curr_block])  # set path to image here&amp;#10;&amp;#10;        # show instructions on screen&amp;#10;        instr_text_stim.draw()&amp;#10;        curr_instr_pic.draw()&amp;#10;        win.flip()&amp;#10;        core.wait(3)  # wait for 3s before starting response window&amp;#10;&amp;#10;        ### change background colour&amp;#10;        win.setColor(dark_bg_col, colorSpace='rgb')&amp;#10;        win.flip()&amp;#10;&amp;#10;        # get n-back condition:&amp;#10;        curr_nback_cond = curr_block[0]  # get first character of block name&amp;#10;&amp;#10;        # if it is a 1 or a 2, set that as current n-back level:&amp;#10;        if curr_nback_cond in ['1', '2']:&amp;#10;            curr_nback_cond == int(curr_nback_cond)&amp;#10;        # if it's neither 1 nor 2, it has to be a block without n-back,&amp;#10;        # so set curr_nback_cond to None&amp;#10;        else:&amp;#10;            curr_nback_cond = None&amp;#10;&amp;#10;        print(f&quot;\tcurrent n-back condition: {curr_nback_cond}&quot;)&amp;#10;&amp;#10;        # get list with targets &amp; list with colours&amp;#10;        curr_targets = run2_target_lists[run2_block_counter]&amp;#10;        curr_colours = run2_colour_lists[run2_block_counter]&amp;#10;&amp;#10;        # determine duration per rectangle for this block&amp;#10;        # we use average time per rectangle as duration here and add an increment over the duration of the block&amp;#10;        if curr_block == &quot;1back_single_main_no_click&quot;:&amp;#10;            curr_durations = []&amp;#10;            for rect in curr_targets:&amp;#10;                curr_durations.append(RT_per_rectangle_oneback_single)&amp;#10;&amp;#10;            # Latency factor of an incremental increase (increment per trial = 3 ms) added over duration of entire&amp;#10;            # block assuming that participants get tired of the course of the block and thus need a bit more&amp;#10;            # time:&amp;#10;            # Increment of 3 ms per trial&amp;#10;            increment_per_trial = 3&amp;#10;            for i in range(len(curr_durations)):&amp;#10;                # Calculate incremental increase for current trial&amp;#10;                increment = i * increment_per_trial&amp;#10;                # Add incremental increase to current trial's duration&amp;#10;                curr_durations[i] += increment&amp;#10;&amp;#10;        elif curr_block == &quot;2back_single_main_no_click&quot;:&amp;#10;            curr_durations = []&amp;#10;            for rect in curr_targets:&amp;#10;                curr_durations.append(RT_per_rectangle_twoback_single)&amp;#10;&amp;#10;            # Latency factor of an incremental increase (increment per trial = 3 ms) added over duration of entire&amp;#10;            # block assuming that participants get tired of the course of the block and thus need a bit more&amp;#10;            # time:&amp;#10;            # Increment of 3 ms per trial&amp;#10;            increment_per_trial = 3&amp;#10;            for i in range(len(curr_durations)):&amp;#10;                # Calculate incremental increase for current trial&amp;#10;                increment = i * increment_per_trial&amp;#10;                # Add incremental increase to current trial's duration&amp;#10;                curr_durations[i] += increment&amp;#10;&amp;#10;        ### Start block loop&amp;#10;&amp;#10;        # CREATE CLOCKS:&amp;#10;        my_block_clock = core.Clock()&amp;#10;        my_block_clock.reset()  # start block clock&amp;#10;        start_time = my_block_clock.getTime()  # get start time of block&amp;#10;        # also create trial clock&amp;#10;        my_trial_clock = core.Clock()&amp;#10;&amp;#10;        # create empty stimulus&amp;#10;        stim = visual.Rect(win=win,&amp;#10;                           width=0.4,  # width = 3 * 1° visual angle (to make it look rectangle-ish)&amp;#10;                           height=0.15,  # height = 1° visual angle (just like words)&amp;#10;                           # colorSpace = &quot;hex&quot;,&amp;#10;                           pos=(0, 0))  # center stimulus&amp;#10;&amp;#10;        stim.draw()&amp;#10;        win.flip()&amp;#10;&amp;#10;        # clear buffer of all previously recorded key events:&amp;#10;        event.clearEvents()&amp;#10;&amp;#10;        # loop colours in current text&amp;#10;        for trial_idx, curr_col in enumerate(curr_colours):&amp;#10;            # print(&quot;current idx: &quot; + str(trial_idx) + &quot;, curr colour:&quot; + curr_col)&amp;#10;&amp;#10;            ### prepare &amp; show current trial:&amp;#10;            my_trial_clock.reset()  # start trial clock&amp;#10;            onset_time = my_trial_clock.getTime()&amp;#10;&amp;#10;            # if it's a block with an n-back task, prepare target list&amp;#10;            if curr_nback_cond != None:&amp;#10;                curr_target = curr_targets[trial_idx]&amp;#10;                saw_target = False&amp;#10;&amp;#10;            # get duration for current trial&amp;#10;            curr_duration = curr_durations[trial_idx] / 1000  # convert ms to seconds&amp;#10;&amp;#10;            # get trial number (start counting from 1, so add 1)&amp;#10;            curr_trial_nr = trial_idx + 1&amp;#10;&amp;#10;            ### ISI: wait for 200 ms&amp;#10;            while my_trial_clock.getTime() &lt; 0.2:&amp;#10;                win.flip()  # don't draw anything&amp;#10;                core.wait(0.005)  # wait 5 ms before next iteration&amp;#10;&amp;#10;            # set current colour as colour of rectangle&amp;#10;            stim.fillColor = curr_col&amp;#10;&amp;#10;            # draw stimulus on screen&amp;#10;            stim.draw()&amp;#10;            win.flip()&amp;#10;&amp;#10;            # show stimulus on screen &amp; send trigger:&amp;#10;            stim.draw()  # draw stimulus on screen&amp;#10;            # update the window to clear the screen and display&amp;#10;            # the stimulus&amp;#10;&amp;#10;            # start trial clock for measuring RTs from stimulus onset&amp;#10;            my_trial_clock.reset()&amp;#10;            onset_time = my_trial_clock.getTime()&amp;#10;&amp;#10;            ### start recording responses&amp;#10;            # start &quot;endless&quot; while loop that looks for responses&amp;#10;            # --&gt; end while loop only if duration for current word is over&amp;#10;            while my_trial_clock.getTime() &lt; (onset_time + curr_duration):&amp;#10;&amp;#10;                # draw stimulus on screen&amp;#10;                stim.draw()&amp;#10;                win.flip()&amp;#10;&amp;#10;                # check for responses:&amp;#10;                keys = event.getKeys(['c', 'escape'])&amp;#10;&amp;#10;                # check if there was a response. If there wasn't, we can go straight&amp;#10;                # to the next iteration which will hopefully save us some dropped&amp;#10;                # frames in the flicker.&amp;#10;                for key in keys:&amp;#10;&amp;#10;                    # if participant pressed button &quot;c&quot; for the first time and it's an n-back condition&amp;#10;                    # where they're actually supposed to do that (aka not a reading baseline condition)...&amp;#10;                    if key == 'c' and curr_nback_cond != None and saw_target == False:&amp;#10;                        # get reaction time&amp;#10;                        curr_nback_RT = my_trial_clock.getTime() * 1000&amp;#10;                        # send trigger for response:&amp;#10;                        # send_trigger(&quot;response_target&quot;)&amp;#10;                        # only get first target response, we don't care if they press the button more than once:&amp;#10;                        saw_target = True&amp;#10;&amp;#10;                    # If esc is pressed, end the experiment:&amp;#10;                    elif key == 'escape':&amp;#10;                        # et_abort_exp()  # shut down eyetrigger and download incremental data&amp;#10;                        # close trigger &amp; close experiment&amp;#10;                        # core.wait(time_after_trigger)&amp;#10;                        # parallel.setData(0)&amp;#10;                        core.wait(0.5)&amp;#10;                        core.quit()&amp;#10;&amp;#10;            ### end trial&amp;#10;            print(&quot;end paced rect trial&quot;)&amp;#10;&amp;#10;            # check whether response was hit, miss, false alarm or correct rejection&amp;#10;            # they saw a target and there was one: hit&amp;#10;            if curr_nback_cond != None:&amp;#10;                if saw_target and curr_target:&amp;#10;                    curr_nback_response = &quot;hit&quot;&amp;#10;                # they didn't see a target but there was one: miss&amp;#10;                elif saw_target == False and curr_target:&amp;#10;                    curr_nback_response = &quot;miss&quot;&amp;#10;                    curr_nback_RT = None&amp;#10;                # they didn't see a target and there was none: correct rejection&amp;#10;                elif saw_target == False and curr_target == False:&amp;#10;                    curr_nback_response = &quot;correct rejection&quot;&amp;#10;                    curr_nback_RT = None&amp;#10;                # they saw a target but there was none: false alarm&amp;#10;                elif saw_target and curr_target == False:&amp;#10;                    curr_nback_response = &quot;false alarm&quot;&amp;#10;            # if it wasn't an n-back task block:&amp;#10;            else:&amp;#10;                curr_target = None&amp;#10;                curr_nback_response = None&amp;#10;                curr_nback_RT = None&amp;#10;&amp;#10;            ### save everything in output csv&amp;#10;            thisExp.addData('colour', curr_col)&amp;#10;            thisExp.addData('target', curr_target)&amp;#10;            thisExp.addData('nback_response', curr_nback_response)&amp;#10;            thisExp.addData('nback_RT', curr_nback_RT)  # in ms&amp;#10;            thisExp.addData('duration', curr_duration)  # in ms&amp;#10;            thisExp.addData('trial_nr', curr_trial_nr)&amp;#10;            thisExp.addData('block_nr_exp', exp_block_counter)&amp;#10;            thisExp.addData('run_nr', 'run2')&amp;#10;            thisExp.addData('block_nr_run', run2_block_counter)&amp;#10;            thisExp.addData('block_name', curr_block)&amp;#10;            thisExp.addData('n-back_level', curr_nback_cond)&amp;#10;&amp;#10;            # start a new row in the csv&amp;#10;            thisExp.nextEntry()&amp;#10;&amp;#10;            ### IF TESTING MODE ENABLED: end loop after 4 trials&amp;#10;            if expInfo['testing_mode'] == &quot;yes&quot;:&amp;#10;                if trial_idx == 3:&amp;#10;                    break&amp;#10;&amp;#10;        print(&quot;\t\tfinished presenting trials&quot;)&amp;#10;&amp;#10;        # change background colour from grey (RGB: 10, 10, 10)&amp;#10;        # to ivory (RGB: 240, 223, 204)&amp;#10;        # win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;        # win.flip()&amp;#10;&amp;#10;        # add 1 to the block counter to go load the next block&amp;#10;        exp_block_counter += 1&amp;#10;        run2_block_counter += 1&amp;#10;        print(f&quot;Going to block {exp_block_counter + 1}/10 in the experiment now!&quot;)&amp;#10;        continueRoutine = False&amp;#10;&amp;#10;        # If there are still blocks left, go to next one.&amp;#10;        # If not, end loop here:&amp;#10;        if run2_block_counter == 4:&amp;#10;            print(f&quot;Finished block {run2_block_counter}/4 in run 2, moving on to next run!&quot;)&amp;#10;            loop_run2_single_nback.finished = True" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="single_nback_blocks" valType="code" updates="None" name="name"/>
      </CodeComponent>
    </Routine>
    <Routine name="dual_task_block">
      <RoutineSettingsComponent name="dual_task_block" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="dual_task_block" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <CodeComponent name="dual_task" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="/* Syntax Error: Fix Python code */" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="#################################################&amp;#10;#         Blocks with text – dual task          #&amp;#10;#################################################&amp;#10;# this routine is for all blocks with texts that are paced, i.e., visually presented without space bar&amp;#10;&amp;#10;if 6 &lt;= exp_block_counter &lt;= 7:&amp;#10;    # We collected RTs &amp; words from the self-paced block of each condition&amp;#10;    RT_per_letter_oneback_dual = int(expInfo['RT_per_letter_oneback_dual'])&amp;#10;    RT_per_letter_twoback_dual = int(expInfo['RT_per_letter_twoback_dual'])&amp;#10;&amp;#10;    # get block kind&amp;#10;    curr_block = run3_blocks[run3_block_counter]&amp;#10;&amp;#10;    # clear buffer of all previously recorded key events:&amp;#10;    event.clearEvents()&amp;#10;&amp;#10;    if curr_block in [&quot;1back_dual_main_no_click&quot;, &quot;2back_dual_main_no_click&quot;]:&amp;#10;        print(f&quot;Start preparing block {curr_block}&quot;)&amp;#10;        if curr_block == &quot;1back_dual_main_no_click&quot;:&amp;#10;            print(&quot;Using RT_per_letter_oneback_dual for this block:&quot;, RT_per_letter_oneback_dual)&amp;#10;&amp;#10;        elif curr_block == &quot;2back_dual_main_no_click&quot;:&amp;#10;            print(&quot;Using RT_per_letter_twoback_dual for this block:&quot;, RT_per_letter_twoback_dual)&amp;#10;&amp;#10;    ### Prepare stimuli:&amp;#10;    # keep background ivory&amp;#10;    win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;    win.flip()&amp;#10;&amp;#10;    # set instruction text&amp;#10;    instr_text = locals()[&quot;instr_&quot; + curr_block]&amp;#10;    # create text box&amp;#10;    instr_text_stim = visual.TextStim(win,&amp;#10;                                      text=instr_text,&amp;#10;                                      height=0.025,  # font height relative to height of screen&amp;#10;                                      pos=(0, 0.2),  # move up a bit&amp;#10;                                      color=&quot;black&quot;)&amp;#10;    # create ImageStim object&amp;#10;    curr_instr_pic = visual.ImageStim(win,&amp;#10;                                      size=(0.8, 0.3),&amp;#10;                                      pos=(0, -0.2),&amp;#10;                                      image=locals()[&quot;instr_pic_&quot; + curr_block])  # set path to image here&amp;#10;&amp;#10;    # show instructions on screen&amp;#10;    win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;    instr_text_stim.draw()&amp;#10;    curr_instr_pic.draw()&amp;#10;    win.flip()&amp;#10;    core.wait(3)  # wait for 3s before starting response window&amp;#10;&amp;#10;    # Display the text on screen&amp;#10;    # while True:&amp;#10;    #     instr_text_stim.draw()&amp;#10;    #     curr_instr_pic.draw()&amp;#10;    #     win.flip()&amp;#10;    #     # end showing screen if participant presses space&amp;#10;    #     if 'space' in event.getKeys():&amp;#10;    #         break&amp;#10;&amp;#10;    # get text nr:&amp;#10;    curr_text_nr = all_texts_nrs_list[exp_block_counter]&amp;#10;    curr_text = locals()[curr_text_nr]&amp;#10;    # compute RTs using participant's average reading speed / letter&amp;#10;    if curr_block == &quot;1back_dual_main_no_click&quot;:&amp;#10;        # compute RTs using participant's average reading speed / letter&amp;#10;        # we define a minimum and a maximum duration for each word&amp;#10;        # the minimum is based on 5 x RT per letter in the respective condition&amp;#10;        # the max duration is based on a time-out of 2 s in the 1-back condition&amp;#10;        minimum_duration = 5 * RT_per_letter_oneback_dual&amp;#10;        maximum_duration = 2000&amp;#10;        curr_durations = []&amp;#10;        for word in curr_text:&amp;#10;            duration = RT_per_letter_oneback_dual * math.log((len(word))) + 4 * RT_per_letter_oneback_dual&amp;#10;            if duration &lt; maximum_duration:&amp;#10;                curr_durations.append(max(duration, minimum_duration))&amp;#10;            else:&amp;#10;                curr_durations.append(maximum_duration)&amp;#10;&amp;#10;        # Latency factor of an incremental increase (increment per trial = 3 ms) added over duration of entire&amp;#10;        # block assuming that participants get tired of the course of a 300 words block and thus need a bit more&amp;#10;        # time:&amp;#10;        # Increment of 3 ms per trial&amp;#10;        increment_per_trial = 3&amp;#10;        for i in range(len(curr_durations)):&amp;#10;            # Calculate incremental increase for current trial&amp;#10;            increment = i * increment_per_trial&amp;#10;            # Add incremental increase to current trial's duration&amp;#10;            curr_durations[i] += increment&amp;#10;&amp;#10;    elif curr_block == &quot;2back_dual_main_no_click&quot;:&amp;#10;        minimum_duration = 5 * RT_per_letter_twoback_dual&amp;#10;        maximum_duration = 2000&amp;#10;        curr_durations = []&amp;#10;        for word in curr_text:&amp;#10;            # this is an absolute value based on estimates of how long you need to feel comfortable reading a word on&amp;#10;            # screen in a paced task&amp;#10;            # duration = RT_per_letter_baseline * math.log((len(word))) + 300&amp;#10;            # more flexible solution:&amp;#10;            duration = RT_per_letter_twoback_dual * math.log((len(word))) + 4 * RT_per_letter_twoback_dual&amp;#10;            if duration &lt; maximum_duration:&amp;#10;                curr_durations.append(max(duration, minimum_duration))&amp;#10;            else:&amp;#10;                curr_durations.append(maximum_duration)&amp;#10;&amp;#10;        # Add increment of 3 ms per trial&amp;#10;        increment_per_trial = 3&amp;#10;        for i in range(len(curr_durations)):&amp;#10;            # Calculate incremental increase for current trial&amp;#10;            increment = i * increment_per_trial&amp;#10;            # Add incremental increase to current trial's duration&amp;#10;            curr_durations[i] += increment&amp;#10;&amp;#10;    # print(f&quot;\tdurations for paced n-back block: {curr_durations}&quot;)&amp;#10;&amp;#10;    ### change background colour&amp;#10;    win.setColor(dark_bg_col, colorSpace='rgb')&amp;#10;    win.flip()&amp;#10;&amp;#10;    # show main block questions&amp;#10;    skip_questions_paced = False&amp;#10;&amp;#10;    # get n-back condition:&amp;#10;    curr_nback_cond = curr_block[0]  # get first character of block name&amp;#10;&amp;#10;    # if it is a 1 or a 2, set that as current n-back level:&amp;#10;    if curr_nback_cond in ['1', '2']:&amp;#10;        curr_nback_cond == int(curr_nback_cond)&amp;#10;    # if it's neither 1 nor 2, it has to be a block without n-back,&amp;#10;    # so set curr_nback_cond to None&amp;#10;    else:&amp;#10;        curr_nback_cond = None&amp;#10;&amp;#10;    print(f&quot;\tCurrent n-back condition: {curr_nback_cond}&quot;)&amp;#10;    print(f&quot;\tCurrent text: {curr_text_nr}&quot;)&amp;#10;&amp;#10;    # get list with targets &amp; list with colours&amp;#10;    curr_targets = run3_target_lists[run3_block_counter]&amp;#10;    curr_colours = run3_colour_lists[run3_block_counter]&amp;#10;&amp;#10;    # create empty text stimulus&amp;#10;    stim = visual.TextStim(win=win,&amp;#10;                           text=&quot; &quot;,&amp;#10;                           pos=(0, 0),  # center stimulus&amp;#10;                           font=&quot;Times New Roman&quot;,&amp;#10;                           height=0.07)&amp;#10;&amp;#10;    stim.draw()&amp;#10;    win.flip()&amp;#10;&amp;#10;    # clear buffer of all previously recorded key events:&amp;#10;    event.clearEvents()&amp;#10;&amp;#10;    # CREATE CLOCKS:&amp;#10;    my_block_clock = core.Clock()&amp;#10;    my_block_clock.reset()  # start block clock&amp;#10;    start_time = my_block_clock.getTime()  # get start time of block&amp;#10;    # also create trial clock&amp;#10;    my_trial_clock = core.Clock()&amp;#10;&amp;#10;    # loop words in current text&amp;#10;    for trial_idx, curr_word in enumerate(curr_text):&amp;#10;        # print(&quot;current idx: &quot; + str(trial_idx) + &quot;, curr word:&quot; + curr_word)&amp;#10;&amp;#10;        ### prepare &amp; show current word:&amp;#10;&amp;#10;        # get current colour&amp;#10;        curr_colour = curr_colours[trial_idx]&amp;#10;&amp;#10;        # if it's a block with an n-back task, prepare target list as well&amp;#10;        if curr_nback_cond != None:&amp;#10;            curr_target = curr_targets[trial_idx]&amp;#10;            saw_target = False&amp;#10;&amp;#10;        # get duration for current word&amp;#10;        curr_duration = curr_durations[trial_idx] / 1000  # convert ms to seconds&amp;#10;        # print(&quot;duration for current word (in s):&quot;, curr_duration)&amp;#10;&amp;#10;        # get trial number (start counting from 1, so add 1)&amp;#10;        curr_trial_nr = trial_idx + 1&amp;#10;&amp;#10;        # set current word &amp; colour as content of text stimulus&amp;#10;        stim.color = curr_colour&amp;#10;        stim.text = curr_word&amp;#10;&amp;#10;        # show word on screen&amp;#10;        stim.draw()  # draw word on screen&amp;#10;&amp;#10;        # start trial clock &amp; record trial onset time&amp;#10;        my_trial_clock.reset()&amp;#10;        onset_time = my_trial_clock.getTime()&amp;#10;&amp;#10;        ### wait for key response:&amp;#10;        # In blocks with n-back task, participants can press &quot;c&quot; to indicate they saw a target colour.&amp;#10;&amp;#10;        ### start recording responses&amp;#10;        # start while loop that looks for responses&amp;#10;        # --&gt; end while loop only if duration for current word is over&amp;#10;        while my_trial_clock.getTime() &lt; (onset_time + curr_duration):&amp;#10;&amp;#10;            stim.draw()&amp;#10;            win.flip()&amp;#10;&amp;#10;            # check for key responses:&amp;#10;            keys = event.getKeys(['c', 'escape'])&amp;#10;&amp;#10;            # if there were, check responses:&amp;#10;            for key in keys:&amp;#10;&amp;#10;                # if participant pressed button &quot;c&quot; for the first time and it's an n-back condition&amp;#10;                # where they're actually supposed to do that (aka not a reading baseline condition)...&amp;#10;                if key == 'c' and curr_nback_cond != None and saw_target == False:&amp;#10;                    # get reaction time&amp;#10;                    curr_nback_RT = my_trial_clock.getTime() * 1000&amp;#10;                    # send trigger for response:&amp;#10;                    # send_trigger(&quot;response_target&quot;)&amp;#10;                    # only get first target response, we don't care if they press the button more than once:&amp;#10;                    saw_target = True&amp;#10;&amp;#10;                # If esc is pressed, end the experiment:&amp;#10;                elif key == 'escape':&amp;#10;                    # et_abort_exp()  # shut down eyetrigger and download incremental data&amp;#10;                    # close trigger &amp; close experiment&amp;#10;                    # core.wait(time_after_trigger)&amp;#10;                    # parallel.setData(0)&amp;#10;                    core.wait(0.5)&amp;#10;                    core.quit()&amp;#10;&amp;#10;        ### end trial&amp;#10;        print(&quot;\tend paced trial&quot;)&amp;#10;        # stop display of current word &amp; send trial offset trigger&amp;#10;        # win.callOnFlip(send_trigger, &quot;trial_offset&quot;)&amp;#10;&amp;#10;        # check whether response was hit, miss, false alarm or correct rejection&amp;#10;        # they saw a target and there was one: hit&amp;#10;        if curr_nback_cond != None:&amp;#10;            if saw_target and curr_target:&amp;#10;                curr_nback_response = &quot;hit&quot;&amp;#10;            # they didn't see a target but there was one: miss&amp;#10;            elif saw_target == False and curr_target:&amp;#10;                curr_nback_response = &quot;miss&quot;&amp;#10;                curr_nback_RT = None&amp;#10;            # they didn't see a target and there was none: correct rejection&amp;#10;            elif saw_target == False and curr_target == False:&amp;#10;                curr_nback_response = &quot;correct rejection&quot;&amp;#10;                curr_nback_RT = None&amp;#10;            # they saw a target but there was none: false alarm&amp;#10;            elif saw_target and curr_target == False:&amp;#10;                curr_nback_response = &quot;false alarm&quot;&amp;#10;        # if it wasn't an n-back task block:&amp;#10;        else:&amp;#10;            curr_target = None&amp;#10;            curr_nback_response = None&amp;#10;            curr_nback_RT = None&amp;#10;&amp;#10;        ### save everything in output csv&amp;#10;        thisExp.addData('colour', curr_colour)&amp;#10;        thisExp.addData('target', curr_target)&amp;#10;        thisExp.addData('nback_response', curr_nback_response)&amp;#10;        thisExp.addData('nback_RT', curr_nback_RT)  # in ms&amp;#10;        thisExp.addData('duration', curr_duration * 1000)  # in ms&amp;#10;        thisExp.addData('text_nr', curr_text_nr)&amp;#10;        thisExp.addData('trial_nr', curr_trial_nr)&amp;#10;        thisExp.addData('block_nr_exp', exp_block_counter)&amp;#10;        thisExp.addData('run_nr', 'run3')&amp;#10;        thisExp.addData('block_nr_run', run3_block_counter)&amp;#10;        thisExp.addData('block_name', curr_block)&amp;#10;        thisExp.addData('n-back_level', curr_nback_cond)&amp;#10;        # careful, make sure quotes in the strings are escaped using a&amp;#10;        # quote (weird, I know) so it's properly saved in the CSV:&amp;#10;        thisExp.addData('word', escape_quotes(curr_word))&amp;#10;&amp;#10;        # start a new row in the csv&amp;#10;        thisExp.nextEntry()&amp;#10;&amp;#10;        ### IF TESTING MODE ENABLED: end loop after 4 trials&amp;#10;        if expInfo['testing_mode'] == &quot;yes&quot;:&amp;#10;            if trial_idx == 3:&amp;#10;                break&amp;#10;&amp;#10;    print(&quot;finished presenting trials&quot;)&amp;#10;&amp;#10;    # add 1 to the block counter to go load the next block&amp;#10;    # exp_block_counter += 1&amp;#10;    # run3_block_counter += 1&amp;#10;    # print(f&quot;Going to block {exp_block_counter + 1}/10 in the experiment now!&quot;)&amp;#10;    # continueRoutine = False&amp;#10;    #&amp;#10;    # # If there are still blocks left, go to next one.&amp;#10;    # # If not, end loop here:&amp;#10;    # if run3_block_counter == 2:&amp;#10;    #     print(f&quot;Finished block {run3_block_counter}/2 in run 3, moving on to next run!&quot;)&amp;#10;    #     # loop_dual_task_blocks.finished = True&amp;#10;&amp;#10;    # Send end of block trigger:&amp;#10;    # core.wait(time_after_trigger)  # wait 3 ms&amp;#10;    # send block offset trigger&amp;#10;    # send_trigger(&quot;block_offset&quot;)&amp;#10;&amp;#10;elif 8 &lt;= exp_block_counter &lt;= 9:&amp;#10;    # We collected RTs &amp; words from the self-paced block of each condition&amp;#10;    RT_per_letter_oneback_dual = int(expInfo['RT_per_letter_oneback_dual'])&amp;#10;    RT_per_letter_twoback_dual = int(expInfo['RT_per_letter_twoback_dual'])&amp;#10;&amp;#10;    # get block kind&amp;#10;    curr_block = run4_blocks[run4_block_counter]&amp;#10;&amp;#10;    # clear buffer of all previously recorded key events:&amp;#10;    event.clearEvents()&amp;#10;&amp;#10;    if curr_block in [&quot;1back_dual_main_no_click&quot;, &quot;2back_dual_main_no_click&quot;]:&amp;#10;        print(f&quot;Start preparing block {curr_block}&quot;)&amp;#10;        if curr_block == &quot;1back_dual_main_no_click&quot;:&amp;#10;            print(&quot;Using RT_per_letter_oneback_dual for this block:&quot;, RT_per_letter_oneback_dual)&amp;#10;&amp;#10;        elif curr_block == &quot;2back_dual_main_no_click&quot;:&amp;#10;            print(&quot;Using RT_per_letter_twoback_dual for this block:&quot;, RT_per_letter_twoback_dual)&amp;#10;&amp;#10;    ### Prepare stimuli:&amp;#10;    # keep background ivory&amp;#10;    win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;    win.flip()&amp;#10;&amp;#10;    # set instruction text&amp;#10;    instr_text = locals()[&quot;instr_&quot; + curr_block]&amp;#10;    # create text box&amp;#10;    instr_text_stim = visual.TextStim(win,&amp;#10;                                      text=instr_text,&amp;#10;                                      height=0.025,  # font height relative to height of screen&amp;#10;                                      pos=(0, 0.2),  # move up a bit&amp;#10;                                      color=&quot;black&quot;)&amp;#10;    # create ImageStim object&amp;#10;    curr_instr_pic = visual.ImageStim(win,&amp;#10;                                      size=(0.8, 0.3),&amp;#10;                                      pos=(0, -0.2),&amp;#10;                                      image=locals()[&quot;instr_pic_&quot; + curr_block])  # set path to image here&amp;#10;&amp;#10;    # show instructions on screen&amp;#10;    win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;    instr_text_stim.draw()&amp;#10;    curr_instr_pic.draw()&amp;#10;    win.flip()&amp;#10;    core.wait(3)  # wait for 3s before starting response window&amp;#10;&amp;#10;    # Display the text on screen&amp;#10;    # while True:&amp;#10;    #     instr_text_stim.draw()&amp;#10;    #     curr_instr_pic.draw()&amp;#10;    #     win.flip()&amp;#10;    #     # end showing screen if participant presses space&amp;#10;    #     if 'space' in event.getKeys():&amp;#10;    #         break&amp;#10;&amp;#10;    # get text nr:&amp;#10;    curr_text_nr = all_texts_nrs_list[exp_block_counter]&amp;#10;    curr_text = locals()[curr_text_nr]&amp;#10;    # compute RTs using participant's average reading speed / letter&amp;#10;    if curr_block == &quot;1back_dual_main_no_click&quot;:&amp;#10;        # compute RTs using participant's average reading speed / letter&amp;#10;        # we define a minimum and a maximum duration for each word&amp;#10;        # the minimum is based on 5 x RT per letter in the respective condition&amp;#10;        # the max duration is based on a time-out of 2 s in the 1-back condition&amp;#10;        minimum_duration = 5 * RT_per_letter_oneback_dual&amp;#10;        maximum_duration = 2000&amp;#10;        curr_durations = []&amp;#10;        for word in curr_text:&amp;#10;            duration = RT_per_letter_oneback_dual * math.log((len(word))) + 4 * RT_per_letter_oneback_dual&amp;#10;            if duration &lt; maximum_duration:&amp;#10;                curr_durations.append(max(duration, minimum_duration))&amp;#10;            else:&amp;#10;                curr_durations.append(maximum_duration)&amp;#10;&amp;#10;        # Latency factor of an incremental increase (increment per trial = 3 ms) added over duration of entire&amp;#10;        # block assuming that participants get tired of the course of a 300 words block and thus need a bit more&amp;#10;        # time:&amp;#10;        # Increment of 3 ms per trial&amp;#10;        increment_per_trial = 3&amp;#10;        for i in range(len(curr_durations)):&amp;#10;            # Calculate incremental increase for current trial&amp;#10;            increment = i * increment_per_trial&amp;#10;            # Add incremental increase to current trial's duration&amp;#10;            curr_durations[i] += increment&amp;#10;&amp;#10;    elif curr_block == &quot;2back_dual_main_no_click&quot;:&amp;#10;        minimum_duration = 5 * RT_per_letter_twoback_dual&amp;#10;        maximum_duration = 2000&amp;#10;        curr_durations = []&amp;#10;        for word in curr_text:&amp;#10;            # this is an absolute value based on estimates of how long you need to feel comfortable reading a word on&amp;#10;            # screen in a paced task&amp;#10;            # duration = RT_per_letter_baseline * math.log((len(word))) + 300&amp;#10;            # more flexible solution:&amp;#10;            duration = RT_per_letter_twoback_dual * math.log((len(word))) + 4 * RT_per_letter_twoback_dual&amp;#10;            if duration &lt; maximum_duration:&amp;#10;                curr_durations.append(max(duration, minimum_duration))&amp;#10;            else:&amp;#10;                curr_durations.append(maximum_duration)&amp;#10;&amp;#10;        # Add increment of 3 ms per trial&amp;#10;        increment_per_trial = 3&amp;#10;        for i in range(len(curr_durations)):&amp;#10;            # Calculate incremental increase for current trial&amp;#10;            increment = i * increment_per_trial&amp;#10;            # Add incremental increase to current trial's duration&amp;#10;            curr_durations[i] += increment&amp;#10;&amp;#10;    # print(f&quot;\tdurations for paced n-back block: {curr_durations}&quot;)&amp;#10;&amp;#10;    ### change background colour&amp;#10;    win.setColor(dark_bg_col, colorSpace='rgb')&amp;#10;    win.flip()&amp;#10;&amp;#10;    # show main block questions&amp;#10;    skip_questions_paced = False&amp;#10;&amp;#10;    # get n-back condition:&amp;#10;    curr_nback_cond = curr_block[0]  # get first character of block name&amp;#10;&amp;#10;    # if it is a 1 or a 2, set that as current n-back level:&amp;#10;    if curr_nback_cond in ['1', '2']:&amp;#10;        curr_nback_cond == int(curr_nback_cond)&amp;#10;    # if it's neither 1 nor 2, it has to be a block without n-back,&amp;#10;    # so set curr_nback_cond to None&amp;#10;    else:&amp;#10;        curr_nback_cond = None&amp;#10;&amp;#10;    print(f&quot;\tCurrent n-back condition: {curr_nback_cond}&quot;)&amp;#10;    print(f&quot;\tCurrent text: {curr_text_nr}&quot;)&amp;#10;&amp;#10;    # get list with targets &amp; list with colours&amp;#10;    curr_targets = run4_target_lists[run4_block_counter]&amp;#10;    curr_colours = run4_colour_lists[run4_block_counter]&amp;#10;&amp;#10;    # create empty text stimulus&amp;#10;    stim = visual.TextStim(win=win,&amp;#10;                           text=&quot; &quot;,&amp;#10;                           pos=(0, 0),  # center stimulus&amp;#10;                           font=&quot;Times New Roman&quot;,&amp;#10;                           height=0.07)&amp;#10;&amp;#10;    stim.draw()&amp;#10;    win.flip()&amp;#10;&amp;#10;    # clear buffer of all previously recorded key events:&amp;#10;    event.clearEvents()&amp;#10;&amp;#10;    # CREATE CLOCKS:&amp;#10;    my_block_clock = core.Clock()&amp;#10;    my_block_clock.reset()  # start block clock&amp;#10;    start_time = my_block_clock.getTime()  # get start time of block&amp;#10;    # also create trial clock&amp;#10;    my_trial_clock = core.Clock()&amp;#10;&amp;#10;    # loop words in current text&amp;#10;    for trial_idx, curr_word in enumerate(curr_text):&amp;#10;        # print(&quot;current idx: &quot; + str(trial_idx) + &quot;, curr word:&quot; + curr_word)&amp;#10;&amp;#10;        ### prepare &amp; show current word:&amp;#10;&amp;#10;        # get current colour&amp;#10;        curr_colour = curr_colours[trial_idx]&amp;#10;&amp;#10;        # if it's a block with an n-back task, prepare target list as well&amp;#10;        if curr_nback_cond != None:&amp;#10;            curr_target = curr_targets[trial_idx]&amp;#10;            saw_target = False&amp;#10;&amp;#10;        # get duration for current word&amp;#10;        curr_duration = curr_durations[trial_idx] / 1000  # convert ms to seconds&amp;#10;        # print(&quot;duration for current word (in s):&quot;, curr_duration)&amp;#10;&amp;#10;        # get trial number (start counting from 1, so add 1)&amp;#10;        curr_trial_nr = trial_idx + 1&amp;#10;&amp;#10;        # set current word &amp; colour as content of text stimulus&amp;#10;        stim.color = curr_colour&amp;#10;        stim.text = curr_word&amp;#10;&amp;#10;        # show word on screen&amp;#10;        stim.draw()  # draw word on screen&amp;#10;&amp;#10;        # start trial clock &amp; record trial onset time&amp;#10;        my_trial_clock.reset()&amp;#10;        onset_time = my_trial_clock.getTime()&amp;#10;&amp;#10;        ### wait for key response:&amp;#10;        # In blocks with n-back task, participants can press &quot;c&quot; to indicate they saw a target colour.&amp;#10;&amp;#10;        ### start recording responses&amp;#10;        # start while loop that looks for responses&amp;#10;        # --&gt; end while loop only if duration for current word is over&amp;#10;        while my_trial_clock.getTime() &lt; (onset_time + curr_duration):&amp;#10;&amp;#10;            stim.draw()&amp;#10;            win.flip()&amp;#10;&amp;#10;            # check for key responses:&amp;#10;            keys = event.getKeys(['c', 'escape'])&amp;#10;&amp;#10;            # if there were, check responses:&amp;#10;            for key in keys:&amp;#10;&amp;#10;                # if participant pressed button &quot;c&quot; for the first time and it's an n-back condition&amp;#10;                # where they're actually supposed to do that (aka not a reading baseline condition)...&amp;#10;                if key == 'c' and curr_nback_cond != None and saw_target == False:&amp;#10;                    # get reaction time&amp;#10;                    curr_nback_RT = my_trial_clock.getTime() * 1000&amp;#10;                    # send trigger for response:&amp;#10;                    # send_trigger(&quot;response_target&quot;)&amp;#10;                    # only get first target response, we don't care if they press the button more than once:&amp;#10;                    saw_target = True&amp;#10;&amp;#10;                # If esc is pressed, end the experiment:&amp;#10;                elif key == 'escape':&amp;#10;                    # et_abort_exp()  # shut down eyetrigger and download incremental data&amp;#10;                    # close trigger &amp; close experiment&amp;#10;                    # core.wait(time_after_trigger)&amp;#10;                    # parallel.setData(0)&amp;#10;                    core.wait(0.5)&amp;#10;                    core.quit()&amp;#10;&amp;#10;        ### end trial&amp;#10;        print(&quot;\tend paced trial&quot;)&amp;#10;        # stop display of current word &amp; send trial offset trigger&amp;#10;        # win.callOnFlip(send_trigger, &quot;trial_offset&quot;)&amp;#10;&amp;#10;        # check whether response was hit, miss, false alarm or correct rejection&amp;#10;        # they saw a target and there was one: hit&amp;#10;        if curr_nback_cond != None:&amp;#10;            if saw_target and curr_target:&amp;#10;                curr_nback_response = &quot;hit&quot;&amp;#10;            # they didn't see a target but there was one: miss&amp;#10;            elif saw_target == False and curr_target:&amp;#10;                curr_nback_response = &quot;miss&quot;&amp;#10;                curr_nback_RT = None&amp;#10;            # they didn't see a target and there was none: correct rejection&amp;#10;            elif saw_target == False and curr_target == False:&amp;#10;                curr_nback_response = &quot;correct rejection&quot;&amp;#10;                curr_nback_RT = None&amp;#10;            # they saw a target but there was none: false alarm&amp;#10;            elif saw_target and curr_target == False:&amp;#10;                curr_nback_response = &quot;false alarm&quot;&amp;#10;        # if it wasn't an n-back task block:&amp;#10;        else:&amp;#10;            curr_target = None&amp;#10;            curr_nback_response = None&amp;#10;            curr_nback_RT = None&amp;#10;&amp;#10;        ### save everything in output csv&amp;#10;        thisExp.addData('colour', curr_colour)&amp;#10;        thisExp.addData('target', curr_target)&amp;#10;        thisExp.addData('nback_response', curr_nback_response)&amp;#10;        thisExp.addData('nback_RT', curr_nback_RT)  # in ms&amp;#10;        thisExp.addData('duration', curr_duration * 1000)  # in ms&amp;#10;        thisExp.addData('text_nr', curr_text_nr)&amp;#10;        thisExp.addData('trial_nr', curr_trial_nr)&amp;#10;        thisExp.addData('block_nr_exp', exp_block_counter)&amp;#10;        thisExp.addData('run_nr', 'run4')&amp;#10;        thisExp.addData('block_nr_run', run4_block_counter)&amp;#10;        thisExp.addData('block_name', curr_block)&amp;#10;        thisExp.addData('n-back_level', curr_nback_cond)&amp;#10;        # careful, make sure quotes in the strings are escaped using a&amp;#10;        # quote (weird, I know) so it's properly saved in the CSV:&amp;#10;        thisExp.addData('word', escape_quotes(curr_word))&amp;#10;&amp;#10;        # start a new row in the csv&amp;#10;        thisExp.nextEntry()&amp;#10;&amp;#10;        ### IF TESTING MODE ENABLED: end loop after 4 trials&amp;#10;        if expInfo['testing_mode'] == &quot;yes&quot;:&amp;#10;            if trial_idx == 3:&amp;#10;                break&amp;#10;&amp;#10;    print(&quot;finished presenting trials&quot;)&amp;#10;&amp;#10;    # # add 1 to the block counter to go load the next block&amp;#10;    # exp_block_counter += 1&amp;#10;    # run4_block_counter += 1&amp;#10;    # print(f&quot;Going to block {exp_block_counter + 1}/10 in the experiment now!&quot;)&amp;#10;    # continueRoutine = False&amp;#10;    #&amp;#10;    # # If there are still blocks left, go to next one.&amp;#10;    # # If not, end loop here:&amp;#10;    # if run4_block_counter == 2:&amp;#10;    #     print(f&quot;Finished block {run4_block_counter}/2 in run 4, moving on to next run!&quot;)&amp;#10;    #     loop_dual_task_blocks.finished = True&amp;#10;&amp;#10;    # Send end of block trigger:&amp;#10;    # core.wait(time_after_trigger)  # wait 3 ms&amp;#10;    # send block offset trigger&amp;#10;    # send_trigger(&quot;block_offset&quot;)" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="dual_task" valType="code" updates="None" name="name"/>
      </CodeComponent>
      <CodeComponent name="questions_dual_task" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="/* Syntax Error: Fix Python code */" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="##########################################################&amp;#10;#              Text Comprehension Questions              #&amp;#10;##########################################################&amp;#10;&amp;#10;def setup_question(question_text, answers_text):&amp;#10;    question = visual.TextStim(win, text=question_text, pos=(0, 0.2), color=&quot;black&quot;, height=0.025, anchorHoriz='center', alignText='center', wrapWidth=1)&amp;#10;    answers = [visual.TextStim(win, text=ans, pos=(-0.75, 0.1 - i * 0.05), color=&quot;black&quot;, height=0.025, wrapWidth=1.5, anchorHoriz='left', alignText='center') for i, ans in enumerate(answers_text)]&amp;#10;    return question, answers&amp;#10;&amp;#10;def display_question(question, answers):&amp;#10;    question.autoDraw = True&amp;#10;    for answer in answers:&amp;#10;        answer.autoDraw = True&amp;#10;    instr_text.autoDraw = True&amp;#10;    win.flip()&amp;#10;&amp;#10;def get_response(answers, correct_answer):&amp;#10;    while True:&amp;#10;        keys = defaultKeyboard.getKeys(['1', '2', '3', '4'])&amp;#10;        if keys:&amp;#10;            key_name = keys[0].name  # Get the name of the first key pressed&amp;#10;&amp;#10;            # Now, use the key_name to determine the action&amp;#10;            if key_name == '1':&amp;#10;                index = 0  # Corresponds to the first choice&amp;#10;            elif key_name == '2':&amp;#10;                index = 1  # Corresponds to the second choice&amp;#10;            elif key_name == '3':&amp;#10;                index = 2  # Corresponds to the third choice&amp;#10;            elif key_name == '4':&amp;#10;                index = 3  # Corresponds to the fourth choice&amp;#10;            else:&amp;#10;                index = None  # Just in case, not really needed if you're sure about the input keys&amp;#10;&amp;#10;            # Proceed with your logic based on the index&amp;#10;            if index is not None:&amp;#10;                chosen_ans = chr(97 + index)  # Convert index to letter ('a', 'b', 'c', 'd')&amp;#10;                is_correct = chosen_ans == correct_answer  # Assuming correct_answer is defined ('a', 'b', 'c', or 'd')&amp;#10;                for i, answer in enumerate(answers):&amp;#10;                    answer.setColor(&quot;green&quot; if i == index else &quot;black&quot;)&amp;#10;                win.flip()&amp;#10;                core.wait(0.5)  # Ensure the color change is visible&amp;#10;                break&amp;#10;    return chosen_ans, is_correct&amp;#10;&amp;#10;def reset_answers(answers):&amp;#10;    for answer in answers:&amp;#10;        answer.setColor(&quot;black&quot;)&amp;#10;    question.autoDraw = False&amp;#10;    instr_text.autoDraw = False&amp;#10;    for answer in answers:&amp;#10;        answer.autoDraw = False&amp;#10;&amp;#10;# Example usage:&amp;#10;win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;win.flip()&amp;#10;instr_text = visual.TextStim(win, text=&quot;(Bitte benutzen Sie die Tasten 1, 2, 3 und 4, um die richtige Antwort auszuwählen.)&quot;, color=&quot;grey&quot;, pos=(0, -0.3), wrapWidth=2, height=0.018)&amp;#10;event.clearEvents()&amp;#10;&amp;#10;# Assuming skip_questions_paced and other variables are defined&amp;#10;if not skip_questions_paced:&amp;#10;    # this is run 3:&amp;#10;    if 6 &lt;= exp_block_counter &lt;= 7:&amp;#10;        # Setup for Q1&amp;#10;        Q1_text = locals()[curr_text_nr + &quot;_Q1&quot;]&amp;#10;        Q1_answers = locals()[curr_text_nr + &quot;_Q1_ans&quot;]&amp;#10;        Q1_correct = locals()[curr_text_nr + &quot;_Q1_corr&quot;]&amp;#10;&amp;#10;        question, answers = setup_question(Q1_text, Q1_answers)&amp;#10;        display_question(question, answers)&amp;#10;        chosen_ans, is_correct = get_response(answers, Q1_correct)&amp;#10;        print(f&quot;Chosen answer for Q1: {chosen_ans}, Correct: {is_correct}&quot;)&amp;#10;        reset_answers(answers)&amp;#10;&amp;#10;        # save data:&amp;#10;        thisExp.addData('question', 'Q1')&amp;#10;        thisExp.addData('chosen_ans', chosen_ans)&amp;#10;        thisExp.addData('ans_correct', chosen_ans == Q1_correct)&amp;#10;        thisExp.addData('text_nr', curr_text_nr)&amp;#10;        thisExp.addData('block_nr_exp', exp_block_counter)&amp;#10;        thisExp.addData('run_nr', 'run3')&amp;#10;        thisExp.addData('block_nr_run', run3_block_counter)&amp;#10;        thisExp.addData('block_name', curr_block)&amp;#10;        thisExp.addData('n-back_level', curr_nback_cond)&amp;#10;&amp;#10;        # start a new row in the csv&amp;#10;        thisExp.nextEntry()&amp;#10;&amp;#10;        # Setup for Q2&amp;#10;        Q2_text = locals()[curr_text_nr + &quot;_Q2&quot;]&amp;#10;        Q2_answers = locals()[curr_text_nr + &quot;_Q2_ans&quot;]&amp;#10;        Q2_correct = locals()[curr_text_nr + &quot;_Q2_corr&quot;]&amp;#10;&amp;#10;        question, answers = setup_question(Q2_text, Q2_answers)&amp;#10;        display_question(question, answers)&amp;#10;        chosen_ans, is_correct = get_response(answers, Q2_correct)&amp;#10;        print(f&quot;Chosen answer for Q2: {chosen_ans}, Correct: {is_correct}&quot;)&amp;#10;        reset_answers(answers)&amp;#10;&amp;#10;        # save data:&amp;#10;        thisExp.addData('question', 'Q2')&amp;#10;        thisExp.addData('chosen_ans', chosen_ans)&amp;#10;        thisExp.addData('ans_correct', chosen_ans == Q2_correct)&amp;#10;        thisExp.addData('text_nr', curr_text_nr)&amp;#10;        thisExp.addData('block_nr_exp', exp_block_counter)&amp;#10;        thisExp.addData('run_nr', 'run3')&amp;#10;        thisExp.addData('block_nr_run', run3_block_counter)&amp;#10;        thisExp.addData('block_name', curr_block)&amp;#10;        thisExp.addData('n-back_level', curr_nback_cond)&amp;#10;&amp;#10;        # start a new row in the csv&amp;#10;        thisExp.nextEntry()&amp;#10;&amp;#10;        # Setup for Q3&amp;#10;        Q3_text = locals()[curr_text_nr + &quot;_Q3&quot;]&amp;#10;        Q3_answers = locals()[curr_text_nr + &quot;_Q3_ans&quot;]&amp;#10;        Q3_correct = locals()[curr_text_nr + &quot;_Q3_corr&quot;]&amp;#10;&amp;#10;        question, answers = setup_question(Q3_text, Q3_answers)&amp;#10;        display_question(question, answers)&amp;#10;        chosen_ans, is_correct = get_response(answers, Q3_correct)&amp;#10;        print(f&quot;Chosen answer for Q3: {chosen_ans}, Correct: {is_correct}&quot;)&amp;#10;        reset_answers(answers)&amp;#10;&amp;#10;        # save data:&amp;#10;        thisExp.addData('question', 'Q3')&amp;#10;        thisExp.addData('chosen_ans', chosen_ans)&amp;#10;        thisExp.addData('ans_correct', chosen_ans == Q3_correct)&amp;#10;        thisExp.addData('text_nr', curr_text_nr)&amp;#10;        thisExp.addData('block_nr_exp', exp_block_counter)&amp;#10;        thisExp.addData('run_nr', 'run3')&amp;#10;        thisExp.addData('block_nr_run', run3_block_counter)&amp;#10;        thisExp.addData('block_name', curr_block)&amp;#10;        thisExp.addData('n-back_level', curr_nback_cond)&amp;#10;&amp;#10;        # start a new row in the csv&amp;#10;        thisExp.nextEntry()&amp;#10;&amp;#10;        exp_block_counter += 1&amp;#10;        run3_block_counter += 1&amp;#10;        print(f&quot;Going to block {exp_block_counter + 1}/10 in the experiment now!&quot;)&amp;#10;        continueRoutine = False&amp;#10;&amp;#10;        # If there are still blocks left, go to next one.&amp;#10;        # If not, end loop here:&amp;#10;        if run3_block_counter == 2:&amp;#10;            print(f&quot;Finished block {run3_block_counter}/2 in run 3, moving on to next run!&quot;)&amp;#10;            # loop_dual_task_blocks.finished = True&amp;#10;&amp;#10;    # this is run 4:&amp;#10;    elif 8 &lt;= exp_block_counter &lt;= 9:&amp;#10;&amp;#10;        # Setup for Q1&amp;#10;        Q1_text = locals()[curr_text_nr + &quot;_Q1&quot;]&amp;#10;        Q1_answers = locals()[curr_text_nr + &quot;_Q1_ans&quot;]&amp;#10;        Q1_correct = locals()[curr_text_nr + &quot;_Q1_corr&quot;]&amp;#10;&amp;#10;        question, answers = setup_question(Q1_text, Q1_answers)&amp;#10;        display_question(question, answers)&amp;#10;        chosen_ans, is_correct = get_response(answers, Q1_correct)&amp;#10;        print(f&quot;Chosen answer for Q1: {chosen_ans}, Correct: {is_correct}&quot;)&amp;#10;        reset_answers(answers)&amp;#10;&amp;#10;        # save data:&amp;#10;        thisExp.addData('question', 'Q1')&amp;#10;        thisExp.addData('chosen_ans', chosen_ans)&amp;#10;        thisExp.addData('ans_correct', chosen_ans == Q1_correct)&amp;#10;        thisExp.addData('text_nr', curr_text_nr)&amp;#10;        thisExp.addData('block_nr_exp', exp_block_counter)&amp;#10;        thisExp.addData('run_nr', 'run3')&amp;#10;        thisExp.addData('block_nr_run', run4_block_counter)&amp;#10;        thisExp.addData('block_name', curr_block)&amp;#10;        thisExp.addData('n-back_level', curr_nback_cond)&amp;#10;&amp;#10;        # start a new row in the csv&amp;#10;        thisExp.nextEntry()&amp;#10;&amp;#10;        # Setup for Q2&amp;#10;        Q2_text = locals()[curr_text_nr + &quot;_Q2&quot;]&amp;#10;        Q2_answers = locals()[curr_text_nr + &quot;_Q2_ans&quot;]&amp;#10;        Q2_correct = locals()[curr_text_nr + &quot;_Q2_corr&quot;]&amp;#10;&amp;#10;        question, answers = setup_question(Q2_text, Q2_answers)&amp;#10;        display_question(question, answers)&amp;#10;        chosen_ans, is_correct = get_response(answers, Q2_correct)&amp;#10;        print(f&quot;Chosen answer for Q2: {chosen_ans}, Correct: {is_correct}&quot;)&amp;#10;        reset_answers(answers)&amp;#10;&amp;#10;        # save data:&amp;#10;        thisExp.addData('question', 'Q2')&amp;#10;        thisExp.addData('chosen_ans', chosen_ans)&amp;#10;        thisExp.addData('ans_correct', chosen_ans == Q2_correct)&amp;#10;        thisExp.addData('text_nr', curr_text_nr)&amp;#10;        thisExp.addData('block_nr_exp', exp_block_counter)&amp;#10;        thisExp.addData('run_nr', 'run3')&amp;#10;        thisExp.addData('block_nr_run', run4_block_counter)&amp;#10;        thisExp.addData('block_name', curr_block)&amp;#10;        thisExp.addData('n-back_level', curr_nback_cond)&amp;#10;&amp;#10;        # start a new row in the csv&amp;#10;        thisExp.nextEntry()&amp;#10;&amp;#10;        # Setup for Q3&amp;#10;        Q3_text = locals()[curr_text_nr + &quot;_Q3&quot;]&amp;#10;        Q3_answers = locals()[curr_text_nr + &quot;_Q3_ans&quot;]&amp;#10;        Q3_correct = locals()[curr_text_nr + &quot;_Q3_corr&quot;]&amp;#10;&amp;#10;        question, answers = setup_question(Q3_text, Q3_answers)&amp;#10;        display_question(question, answers)&amp;#10;        chosen_ans, is_correct = get_response(answers, Q3_correct)&amp;#10;        print(f&quot;Chosen answer for Q3: {chosen_ans}, Correct: {is_correct}&quot;)&amp;#10;        reset_answers(answers)&amp;#10;&amp;#10;        # save data:&amp;#10;        thisExp.addData('question', 'Q3')&amp;#10;        thisExp.addData('chosen_ans', chosen_ans)&amp;#10;        thisExp.addData('ans_correct', chosen_ans == Q3_correct)&amp;#10;        thisExp.addData('text_nr', curr_text_nr)&amp;#10;        thisExp.addData('block_nr_exp', exp_block_counter)&amp;#10;        thisExp.addData('run_nr', 'run3')&amp;#10;        thisExp.addData('block_nr_run', run4_block_counter)&amp;#10;        thisExp.addData('block_name', curr_block)&amp;#10;        thisExp.addData('n-back_level', curr_nback_cond)&amp;#10;&amp;#10;        # start a new row in the csv&amp;#10;        thisExp.nextEntry()&amp;#10;&amp;#10;        # add 1 to the block counter to go load the next block&amp;#10;        exp_block_counter += 1&amp;#10;        run4_block_counter += 1&amp;#10;        print(f&quot;Going to block {exp_block_counter + 1}/10 in the experiment now!&quot;)&amp;#10;        continueRoutine = False&amp;#10;&amp;#10;        # If there are still blocks left, go to next one.&amp;#10;        # If not, end loop here:&amp;#10;        if run4_block_counter == 2:&amp;#10;            print(f&quot;Finished block {run4_block_counter}/2 in run 4, moving on to next run!&quot;)&amp;#10;            loop_dual_task_blocks.finished = True" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="questions_dual_task" valType="code" updates="None" name="name"/>
      </CodeComponent>
    </Routine>
  </Routines>
  <Flow>
    <Routine name="Settings"/>
    <LoopInitiator loopType="TrialHandler" name="loop_run1_single_reading">
      <Param name="Selected rows" updates="None" val="" valType="str"/>
      <Param name="conditions" updates="None" val="None" valType="str"/>
      <Param name="conditionsFile" updates="None" val="" valType="file"/>
      <Param name="endPoints" updates="None" val="[0, 1]" valType="num"/>
      <Param name="isTrials" updates="None" val="True" valType="bool"/>
      <Param name="loopType" updates="None" val="sequential" valType="str"/>
      <Param name="nReps" updates="None" val="5" valType="num"/>
      <Param name="name" updates="None" val="loop_run1_single_reading" valType="code"/>
      <Param name="random seed" updates="None" val="" valType="code"/>
    </LoopInitiator>
    <Routine name="single_reading"/>
    <LoopTerminator name="loop_run1_single_reading"/>
    <LoopInitiator loopType="TrialHandler" name="loop_run2_single_nback">
      <Param name="Selected rows" updates="None" val="" valType="str"/>
      <Param name="conditions" updates="None" val="None" valType="str"/>
      <Param name="conditionsFile" updates="None" val="" valType="file"/>
      <Param name="endPoints" updates="None" val="[0, 1]" valType="num"/>
      <Param name="isTrials" updates="None" val="True" valType="bool"/>
      <Param name="loopType" updates="None" val="sequential" valType="str"/>
      <Param name="nReps" updates="None" val="10" valType="num"/>
      <Param name="name" updates="None" val="loop_run2_single_nback" valType="code"/>
      <Param name="random seed" updates="None" val="" valType="code"/>
    </LoopInitiator>
    <Routine name="single_nback"/>
    <LoopTerminator name="loop_run2_single_nback"/>
    <LoopInitiator loopType="TrialHandler" name="loop_dual_task_blocks">
      <Param name="Selected rows" updates="None" val="" valType="str"/>
      <Param name="conditions" updates="None" val="None" valType="str"/>
      <Param name="conditionsFile" updates="None" val="" valType="file"/>
      <Param name="endPoints" updates="None" val="[0, 1]" valType="num"/>
      <Param name="isTrials" updates="None" val="True" valType="bool"/>
      <Param name="loopType" updates="None" val="sequential" valType="str"/>
      <Param name="nReps" updates="None" val="5" valType="num"/>
      <Param name="name" updates="None" val="loop_dual_task_blocks" valType="code"/>
      <Param name="random seed" updates="None" val="" valType="code"/>
    </LoopInitiator>
    <Routine name="dual_task_block"/>
    <LoopTerminator name="loop_dual_task_blocks"/>
    <LoopInitiator loopType="TrialHandler" name="blocks">
      <Param name="Selected rows" updates="None" val="" valType="str"/>
      <Param name="conditions" updates="None" val="None" valType="str"/>
      <Param name="conditionsFile" updates="None" val="" valType="file"/>
      <Param name="endPoints" updates="None" val="[0, 1]" valType="num"/>
      <Param name="isTrials" updates="None" val="True" valType="bool"/>
      <Param name="loopType" updates="None" val="sequential" valType="str"/>
      <Param name="nReps" updates="None" val="30" valType="num"/>
      <Param name="name" updates="None" val="blocks" valType="code"/>
      <Param name="random seed" updates="None" val="" valType="code"/>
    </LoopInitiator>
    <Routine name="no_text_training"/>
    <Routine name="text_blocks_self_paced"/>
    <Routine name="text_blocks_paced"/>
    <Routine name="pseudotext"/>
    <LoopTerminator name="blocks"/>
    <Routine name="end"/>
  </Flow>
</PsychoPy2experiment>
