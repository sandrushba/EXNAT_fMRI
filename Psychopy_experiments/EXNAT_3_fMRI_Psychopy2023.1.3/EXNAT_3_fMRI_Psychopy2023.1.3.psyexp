<?xml version="1.0" ?>
<PsychoPy2experiment encoding="utf-8" version="2023.1.3">
  <Settings>
    <Param val="3" valType="str" updates="None" name="Audio latency priority"/>
    <Param val="ptb" valType="str" updates="None" name="Audio lib"/>
    <Param val="" valType="str" updates="None" name="Completed URL"/>
    <Param val="comma" valType="str" updates="None" name="Data file delimiter"/>
    <Param val="u'Data/Psychopy/%s_%s_%s' % (expInfo['participant'], expName, expInfo['date'])" valType="code" updates="None" name="Data filename"/>
    <Param val="True" valType="bool" updates="None" name="Enable Escape"/>
    <Param val="" valType="str" updates="None" name="End Message"/>
    <Param val="{'participant': '', 'session': '001', 'testing_mode': 'no', 'RT_per_rectangle_oneback_single': '', 'RT_per_rectangle_twoback_single': '', 'RT_per_letter_baseline': '', 'RT_per_letter_oneback_dual': '', 'RT_per_letter_twoback_dual': ''}" valType="code" updates="None" name="Experiment info"/>
    <Param val="True" valType="bool" updates="None" name="Force stereo"/>
    <Param val="True" valType="bool" updates="None" name="Full-screen window"/>
    <Param val="" valType="str" updates="None" name="HTML path"/>
    <Param val="" valType="str" updates="None" name="Incomplete URL"/>
    <Param val="testMonitor" valType="str" updates="None" name="Monitor"/>
    <Param val="[]" valType="list" updates="None" name="Resources"/>
    <Param val="False" valType="bool" updates="None" name="Save csv file"/>
    <Param val="False" valType="bool" updates="None" name="Save excel file"/>
    <Param val="True" valType="bool" updates="None" name="Save hdf5 file"/>
    <Param val="True" valType="bool" updates="None" name="Save log file"/>
    <Param val="True" valType="bool" updates="None" name="Save psydat file"/>
    <Param val="True" valType="bool" updates="None" name="Save wide csv file"/>
    <Param val="1" valType="num" updates="None" name="Screen"/>
    <Param val="True" valType="bool" updates="None" name="Show info dlg"/>
    <Param val="False" valType="bool" updates="None" name="Show mouse"/>
    <Param val="height" valType="str" updates="None" name="Units"/>
    <Param val="2023.1.3" valType="str" updates="None" name="Use version"/>
    <Param val="[1280, 1024]" valType="list" updates="None" name="Window size (pixels)"/>
    <Param val="none" valType="str" updates="None" name="backgroundFit"/>
    <Param val="" valType="str" updates="None" name="backgroundImg"/>
    <Param val="avg" valType="str" updates="None" name="blendMode"/>
    <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
    <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
    <Param val="100.1.1.1" valType="str" updates="None" name="elAddress"/>
    <Param val="FILTER_LEVEL_2" valType="str" updates="None" name="elDataFiltering"/>
    <Param val="FILTER_LEVEL_OFF" valType="str" updates="None" name="elLiveFiltering"/>
    <Param val="EYELINK 1000 DESKTOP" valType="str" updates="None" name="elModel"/>
    <Param val="ELLIPSE_FIT" valType="str" updates="None" name="elPupilAlgorithm"/>
    <Param val="PUPIL_AREA" valType="str" updates="None" name="elPupilMeasure"/>
    <Param val="1000" valType="num" updates="None" name="elSampleRate"/>
    <Param val="False" valType="bool" updates="None" name="elSimMode"/>
    <Param val="RIGHT_EYE" valType="str" updates="None" name="elTrackEyes"/>
    <Param val="PUPIL_CR_TRACKING" valType="str" updates="None" name="elTrackingMode"/>
    <Param val="EXNAT_3_fMRI_Psychopy2023.1.3" valType="str" updates="None" name="expName"/>
    <Param val="on Sync" valType="str" updates="None" name="exportHTML"/>
    <Param val="SR Research Ltd" valType="str" updates="None" name="eyetracker"/>
    <Param val="127.0.0.1" valType="str" updates="None" name="gpAddress"/>
    <Param val="4242" valType="num" updates="None" name="gpPort"/>
    <Param val="ioHub" valType="str" updates="None" name="keyboardBackend"/>
    <Param val="exp" valType="code" updates="None" name="logging level"/>
    <Param val="('MIDDLE_BUTTON',)" valType="list" updates="None" name="mgBlink"/>
    <Param val="CONTINUOUS" valType="str" updates="None" name="mgMove"/>
    <Param val="0.5" valType="num" updates="None" name="mgSaccade"/>
    <Param val="0.6" valType="num" updates="None" name="plConfidenceThreshold"/>
    <Param val="True" valType="bool" updates="None" name="plPupilCaptureRecordingEnabled"/>
    <Param val="" valType="str" updates="None" name="plPupilCaptureRecordingLocation"/>
    <Param val="127.0.0.1" valType="str" updates="None" name="plPupilRemoteAddress"/>
    <Param val="50020" valType="num" updates="None" name="plPupilRemotePort"/>
    <Param val="1000" valType="num" updates="None" name="plPupilRemoteTimeoutMs"/>
    <Param val="False" valType="bool" updates="None" name="plPupillometryOnly"/>
    <Param val="psychopy_iohub_surface" valType="str" updates="None" name="plSurfaceName"/>
    <Param val="" valType="str" updates="None" name="tbLicenseFile"/>
    <Param val="" valType="str" updates="None" name="tbModel"/>
    <Param val="60" valType="num" updates="None" name="tbSampleRate"/>
    <Param val="" valType="str" updates="None" name="tbSerialNo"/>
    <Param val="pyglet" valType="str" updates="None" name="winBackend"/>
  </Settings>
  <Routines>
    <Routine name="trial"/>
    <Routine name="settings">
      <CodeComponent name="functions" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="# set screen resolution for eyetracker here:&amp;#10;SCN_W, SCN_H = (1280, 800)&amp;#10;&amp;#10;### import packages:&amp;#10;&amp;#10;# for setting the output encoding to UTF-8&amp;#10;# import sys&amp;#10;# --&gt; if you don't do this, German &quot;Umlaute&quot; can't be displayed correctly:&amp;#10;sys.stdout = open(sys.stdout.fileno(), mode='w', encoding='utf8', buffering=1)&amp;#10;# print Python environment psychopy is currently using&amp;#10;print(sys.executable)&amp;#10;&amp;#10;# for showing pictures&amp;#10;from psychopy import visual&amp;#10;# for getting current date &amp; time:&amp;#10;import datetime&amp;#10;# numpy for being able to calculate&amp;#10;import numpy as np&amp;#10;# for random number generator:&amp;#10;import random&amp;#10;# for saving data in csv / working with pd data frames:&amp;#10;import pandas as pd&amp;#10;# additional timing package (I know we have core.wait, but I also want this one)&amp;#10;import time&amp;#10;# for calculations&amp;#10;import math&amp;#10;&amp;#10;# Get functions from my custom scripts:&amp;#10;# import all texts and instructions&amp;#10;from EXNAT3_texts_MC_Qs import (instr_pic_path, welcome_text, instr_Reading_Baseline_main_no_click, instr_Reading_pseudotext_no_click, \&amp;#10;    instr_1back_single_main_no_click, instr_pic_1back_single_main_no_click, instr_1back_dual_main_no_click, \&amp;#10;    instr_pic_1back_dual_main_no_click, instr_2back_single_main_no_click, instr_pic_2back_single_main_no_click, instr_2back_dual_main_no_click, \&amp;#10;    instr_pic_2back_dual_main_no_click, warning_sign, text_01, text_01_Q1, text_01_Q1_ans, text_01_Q1_corr, \&amp;#10;    text_01_Q2, text_01_Q2_ans, text_01_Q2_corr, text_01_Q3, text_01_Q3_ans, text_01_Q3_corr, text_02, text_02_Q1, \&amp;#10;    text_02_Q1_ans, text_02_Q1_corr, text_02_Q2, text_02_Q2_ans, text_02_Q2_corr, text_02_Q3, text_02_Q3_ans, \&amp;#10;    text_02_Q3_corr, text_03, text_03_Q1, text_03_Q1_ans, text_03_Q1_corr, text_03_Q2, text_03_Q2_ans, text_03_Q2_corr, \&amp;#10;    text_03_Q3, text_03_Q3_ans, text_03_Q3_corr, text_04, text_04_Q1, text_04_Q1_ans, text_04_Q1_corr, text_04_Q2, \&amp;#10;    text_04_Q2_ans, text_04_Q2_corr, text_04_Q3, text_04_Q3_ans, text_04_Q3_corr, text_05, text_05_Q1, text_05_Q1_ans, \&amp;#10;    text_05_Q1_corr, text_05_Q2, text_05_Q2_ans, text_05_Q2_corr, text_05_Q3, text_05_Q3_ans, text_05_Q3_corr, text_06, \&amp;#10;    text_06_Q1, text_06_Q1_ans, text_06_Q1_corr, text_06_Q2, text_06_Q2_ans, text_06_Q2_corr, text_06_Q3, \&amp;#10;    text_06_Q3_ans, text_06_Q3_corr, text_07, text_07_Q1, text_07_Q1_ans, text_07_Q1_corr, text_07_Q2, text_07_Q2_ans, \&amp;#10;    text_07_Q2_corr, text_07_Q3, text_07_Q3_ans, text_07_Q3_corr, text_08, text_08_Q1, text_08_Q1_ans, text_08_Q1_corr, \&amp;#10;    text_08_Q2, text_08_Q2_ans, text_08_Q2_corr, text_08_Q3, text_08_Q3_ans, text_08_Q3_corr, text_09, text_09_Q1, \&amp;#10;    text_09_Q1_ans, text_09_Q1_corr, text_09_Q2, text_09_Q2_ans, text_09_Q2_corr, text_09_Q3, text_09_Q3_ans, \&amp;#10;    text_09_Q3_corr, text_10, text_10_Q1, text_10_Q1_ans, text_10_Q1_corr, text_10_Q2, text_10_Q2_ans, text_10_Q2_corr, \&amp;#10;    text_10_Q3, text_10_Q3_ans, text_10_Q3_corr, pseudo_text_01, pseudo_text_02, pseudo_text_03, pseudo_text_04, pseudo_text_05, \&amp;#10;    pseudo_text_06, pseudo_text_07, pseudo_text_08, pseudo_text_09)&amp;#10;&amp;#10;# import some additional functions I wrote for the experiment:&amp;#10;# from EXNAT3_study_components import change_bg_colour&amp;#10;from nback_colour_generator import create_nback_stimlist, draw_without_replacement, get_targets, create_0back_stimlist&amp;#10;&amp;#10;&amp;#10;# build little function to flatten nested lists:&amp;#10;def flatten_list(nested_list):&amp;#10;    flattened_list = []&amp;#10;    for item in nested_list:&amp;#10;        if isinstance(item, list):&amp;#10;            flattened_list.extend(flatten_list(item))&amp;#10;        else:&amp;#10;            flattened_list.append(item)&amp;#10;    return flattened_list&amp;#10;&amp;#10;&amp;#10;# If I try to save strings containing escaped quotes in a csv file,&amp;#10;# the format gets completely messed up. So we need to escape all&amp;#10;# weird characters like quotes and backslashes with quotes (as odd as it sounds).&amp;#10;def escape_quotes(string):&amp;#10;    # escape quotes with quotes instead of backslashes&amp;#10;    return string.replace('&quot;', '&quot;&quot;')&amp;#10;&amp;#10;### fMRI set-up ####&amp;#10;# Define a list to store all trigger times and a counter for the number of triggers&amp;#10;all_trigger_times = []&amp;#10;trigger_count = 0&amp;#10;&amp;#10;# Start global clock&amp;#10;globalClock = core.Clock()&amp;#10;&amp;#10;def wait_for_first_trigger(instr_text, number_of_triggers):&amp;#10;    &quot;&quot;&quot;&amp;#10;    Wait for the first scanner trigger while displaying instructions on the screen.&amp;#10;&amp;#10;    Parameters:&amp;#10;    - instr_text: The instruction text to display.&amp;#10;    &quot;&quot;&quot;&amp;#10;    trigger_count = number_of_triggers  # Declare trigger_count as global to modify it&amp;#10;&amp;#10;    print(&quot;Waiting for the first scanner trigger...&quot;)&amp;#10;&amp;#10;    # Define the instruction text stimulus&amp;#10;    instr_text_stim = visual.TextStim(&amp;#10;        win,&amp;#10;        text=instr_text,&amp;#10;        height=0.04,  # font height relative to height of screen&amp;#10;        pos=(0, 0.08),  # move up a bit&amp;#10;        color=&quot;black&quot;&amp;#10;    )&amp;#10;&amp;#10;    while True:&amp;#10;        # Display the instructions&amp;#10;        win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;        instr_text_stim.draw()&amp;#10;        win.flip()&amp;#10;&amp;#10;        # Check for the first trigger key '5'&amp;#10;        keys = event.getKeys(keyList=['5'])&amp;#10;        if keys:&amp;#10;            first_trigger_time = globalClock.getTime()&amp;#10;            trigger_count += 1&amp;#10;            thisExp.addData('TriggerCount', trigger_count)&amp;#10;            thisExp.addData('TriggerTime', first_trigger_time)&amp;#10;            # Start a new row in the csv&amp;#10;            # thisExp.nextEntry()&amp;#10;            print(f&quot;First trigger received at {first_trigger_time}&quot;)&amp;#10;            &amp;#10;            # Wait for an additional 2 seconds&amp;#10;            core.wait(2)&amp;#10;            &amp;#10;            return first_trigger_time, trigger_count&amp;#10;&amp;#10;&amp;#10;def log_trigger(instr_text, instr_pic, number_of_triggers):&amp;#10;    &quot;&quot;&quot;&amp;#10;    Wait for the first scanner trigger while displaying instructions on the screen.&amp;#10;&amp;#10;    Parameters:&amp;#10;    - instr_text: The instruction text to display.&amp;#10;    &quot;&quot;&quot;&amp;#10;    trigger_count = number_of_triggers&amp;#10;&amp;#10;    print(&quot;Waiting for the first scanner trigger...&quot;)&amp;#10;&amp;#10;    # create text box&amp;#10;    instr_text_stim = visual.TextStim(win,&amp;#10;                                      text=instr_text,&amp;#10;                                      height=0.03,  # font height relative to height of screen&amp;#10;                                      pos=(0, 0.2),  # move up a bit&amp;#10;                                      color=&quot;black&quot;,&amp;#10;                                      wrapWidth=1)&amp;#10;    # create ImageStim object&amp;#10;    curr_instr_pic = visual.ImageStim(win,&amp;#10;                                      size=(0.9, 0.3),&amp;#10;                                      pos=(0, -0.2),&amp;#10;                                      image=instr_pic)  # set path to image here&amp;#10;&amp;#10;    first_trigger_time = None&amp;#10;    while True:&amp;#10;        # Display the instructions&amp;#10;        win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;        instr_text_stim.draw()&amp;#10;        curr_instr_pic.draw()&amp;#10;        win.flip()&amp;#10;&amp;#10;        # Check for the first trigger key '5'&amp;#10;        keys = event.getKeys(keyList=['5'])&amp;#10;        if keys:&amp;#10;            first_trigger_time = globalClock.getTime()&amp;#10;            trigger_count += 1&amp;#10;            thisExp.addData('TriggerCount', trigger_count)&amp;#10;            thisExp.addData('TriggerTime', first_trigger_time)&amp;#10;            # Start a new row in the csv&amp;#10;            # thisExp.nextEntry()&amp;#10;            print(f&quot;First trigger received at {first_trigger_time}&quot;)&amp;#10;            # break&amp;#10;&amp;#10;            # Wait for an additional 8.75 seconds&amp;#10;            core.wait(8.75)&amp;#10;&amp;#10;            return first_trigger_time, trigger_count" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="functions" valType="code" updates="None" name="name"/>
      </CodeComponent>
      <CodeComponent name="stimuli" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="### Stimulus settings&amp;#10;&amp;#10;# set colours you want to use for background:&amp;#10;# light_bg_col_hex = &quot;#FDFBF0&quot; # ivory instructions background&amp;#10;# dark_bg_col_hex  = &quot;#505050&quot; # dark grey background for stimuli&amp;#10;#light_bg_col = [(x / 127.5) - 1 for x in (253, 251, 240)]&amp;#10;light_bg_col = [(x / 127.5) - 1 for x in (186, 186, 186)] # ivory instructions background (use RGB -1:1)&amp;#10;dark_bg_col = [(x / 127.5) - 1 for x in (80, 80, 80)]  # dark grey background for stimuli (use RGB -1:1)&amp;#10;&amp;#10;# make background light for a start - use rgb -1:1 colour codes&amp;#10;win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;&amp;#10;# set colours you want to use for the stimuli:&amp;#10;colours = [&quot;#D292F3&quot;, &quot;#F989A2&quot;, &quot;#2AB7EF&quot;, &quot;#88BA3F&quot;]&amp;#10;print(&quot;Preparing experiment with n-back colours:&quot;, colours)&amp;#10;&amp;#10;#  #D292F3 = weird lilac with a 2000s vibe&amp;#10;#  #F989A2 = Barbie pink&amp;#10;#  #2AB7EF = Twitter blue&amp;#10;#  #88BA3F = medium grass green&amp;#10;# (#D8A244 = dark curry-ish yellow --&gt; excluded!)&amp;#10;&amp;#10;#   All colours have a luminance of 70 and a chroma of 74.&amp;#10;&amp;#10;#   The colours are selected for distinguishability (is that a word?!)&amp;#10;#   for people with &quot;normal&quot; colour vision as well as for&amp;#10;#   people with protanomaly (red olour vision deficiency (CVD)),&amp;#10;#   deuteranomaly (green CVD) and&amp;#10;#   tritanomaly (blue CVD).&amp;#10;&amp;#10;#   People with a &quot;true&quot; colour blindness&amp;#10;#   (i.e. protanopia, deuteranopia, tritanopia)&amp;#10;#   shouldn't participate in this study. */&amp;#10;&amp;#10;&amp;#10;# ----------------------------------------------&amp;#10;### Shuffle order of texts&amp;#10;print(&quot;shuffle texts&quot;)&amp;#10;# collect the text IDs in lists so I know which text was shown&amp;#10;all_main_texts_nrs_list = [&quot;text_01&quot;, &quot;text_02&quot;, &quot;text_03&quot;, &quot;text_04&quot;, &quot;text_05&quot;, &quot;text_06&quot;, &quot;text_07&quot;, &quot;text_08&quot;,&amp;#10;                           &quot;text_09&quot;, &quot;text_10&quot;]&amp;#10;all_pseudotexts_nrs_list = [&quot;pseudo_text_01&quot;, &quot;pseudo_text_02&quot;, &quot;pseudo_text_03&quot;, &quot;pseudo_text_04&quot;, &quot;pseudo_text_05&quot;,&amp;#10;                            &quot;pseudo_text_06&quot;, &quot;pseudo_text_07&quot;, &quot;pseudo_text_08&quot;, &quot;pseudo_text_09&quot;]&amp;#10;# shuffle text numbers&amp;#10;random.shuffle(all_main_texts_nrs_list)&amp;#10;random.shuffle(all_pseudotexts_nrs_list)&amp;#10;&amp;#10;# only get first 5 texts for the main blocks&amp;#10;all_main_texts_nrs_list = all_main_texts_nrs_list[0:5]&amp;#10;&amp;#10;# only get first text for pseudotext&amp;#10;all_pseudotexts_nrs_list = all_pseudotexts_nrs_list[0:1]&amp;#10;&amp;#10;# append &quot;empty&quot; text numbers to the list where we have blocks that are not main blocks.&amp;#10;all_texts_nrs_list = []&amp;#10;&amp;#10;# Loop through the range of the length of texts since it's the longer list&amp;#10;for t_idx in range(len(all_main_texts_nrs_list)):&amp;#10;    # if it's the first text, it's the reading BL main block.&amp;#10;    if t_idx == 0:&amp;#10;        # Append 1 text for baseline reading&amp;#10;        all_texts_nrs_list.append(all_main_texts_nrs_list[t_idx])&amp;#10;        # Then append 1 text for pseudotext plus 4 empty blocks for n-back single task&amp;#10;        all_texts_nrs_list.extend([all_pseudotexts_nrs_list[0], &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;])&amp;#10;    elif t_idx &gt;= 1:&amp;#10;        # Then 4 reading blocks for dual task&amp;#10;        all_texts_nrs_list.append(all_main_texts_nrs_list[t_idx])&amp;#10;&amp;#10;# This will result in a list following your described logic&amp;#10;print(all_texts_nrs_list)&amp;#10;&amp;#10;### Set order of blocks&amp;#10;print(&quot;set block order for runs&quot;)&amp;#10;&amp;#10;# RUN 1&amp;#10;# always starts with single reading (BL + PS)&amp;#10;single_reading = [&quot;Reading_Baseline_main_no_click&quot;, &quot;Reading_pseudotext_no_click&quot;]&amp;#10;&amp;#10;run1_blocks = single_reading&amp;#10;print(&quot;Blocks for run1:&quot;, run1_blocks)&amp;#10;&amp;#10;# RUN 2&amp;#10;# then you get both single n-back conditions&amp;#10;nback1 = [&quot;1back_single_main_no_click&quot;, &quot;2back_single_main_no_click&quot;]&amp;#10;random.shuffle(nback1)&amp;#10;&amp;#10;nback2 = [&quot;1back_single_main_no_click&quot;, &quot;2back_single_main_no_click&quot;]&amp;#10;random.shuffle(nback2)&amp;#10;&amp;#10;run2_blocks = nback1 + nback2&amp;#10;print(&quot;Blocks for run2:&quot;, run2_blocks)&amp;#10;&amp;#10;# RUNS 3, 4, 5 &amp; 6&amp;#10;# one dual-task block per run, order randomized&amp;#10;dual_blocks = [&quot;1back_dual_main_no_click&quot;, &quot;2back_dual_main_no_click&quot;, &quot;1back_dual_main_no_click&quot;, &quot;2back_dual_main_no_click&quot;]&amp;#10;&amp;#10;random.shuffle(dual_blocks)&amp;#10;&amp;#10;run3_blocks = dual_blocks[0]&amp;#10;run4_blocks = dual_blocks[1]&amp;#10;run5_blocks = dual_blocks[2]&amp;#10;run6_blocks = dual_blocks[3]&amp;#10;&amp;#10;print(&quot;Blocks for run3:&quot;, run3_blocks)&amp;#10;print(&quot;Blocks for run4:&quot;, run4_blocks)&amp;#10;print(&quot;Blocks for run5:&quot;, run5_blocks)&amp;#10;print(&quot;Blocks for run6:&quot;, run6_blocks)&amp;#10;&amp;#10;### Create n-back colour lists for all blocks&amp;#10;&amp;#10;print(&quot;create n-back colour lists&quot;)&amp;#10;# There are 10 blocks in total&amp;#10;# For run 1, 6 blocks (2 text blocks + 4 single n-back)&amp;#10;# Run 2 and 3 each have 2 dual-task blocks with 300 stimuli each (50 targets)&amp;#10;&amp;#10;# So for every block, build a list with colour codes containing the right amount of targets.&amp;#10;# The function is defined in another script bc it's super long,&amp;#10;# I import it at the beginning of this script.&amp;#10;&amp;#10;# RUN 1&amp;#10;blocks_textlen = [300, 100] # reading blocks&amp;#10;blocks_target_counts = [25, 25]  # reading blocks&amp;#10;&amp;#10;# Now loop this list. Check which condition we have there and then create colour list for each text.&amp;#10;run1_colour_lists = []&amp;#10;run1_target_lists = []&amp;#10;for block_idx, block_length in enumerate(blocks_textlen):&amp;#10;    # get 1st letter of block name - that tells us the condition&amp;#10;    block_cond = run1_blocks[block_idx][0]&amp;#10;&amp;#10;    # for each condition, decide which n-back level we want to assign&amp;#10;    # For all no-n-back blocks, we use 1 (just for the colour list generation)&amp;#10;    # global curr_nback_level&amp;#10;    if block_cond == &quot;R&quot;:&amp;#10;        curr_nback_level = 1&amp;#10;    elif block_cond == &quot;1&quot;:&amp;#10;        curr_nback_level = 1&amp;#10;    else:&amp;#10;        curr_nback_level = 2&amp;#10;&amp;#10;    # generate colour list for current block&amp;#10;    # global curr_colours&amp;#10;    curr_colours = create_nback_stimlist(nback_level=curr_nback_level,&amp;#10;                                         colour_codes=colours,&amp;#10;                                         story=[&quot;x&quot;] * block_length,&amp;#10;                                         target_abs_min=blocks_target_counts[block_idx],&amp;#10;                                         target_abs_max=blocks_target_counts[block_idx],&amp;#10;                                         zeroback_target=None)&amp;#10;&amp;#10;    # get list of targets / non-targets&amp;#10;    curr_targets = get_targets(stim_list=curr_colours,&amp;#10;                               nback_level=curr_nback_level)&amp;#10;&amp;#10;    # add to bigger lists&amp;#10;    run1_colour_lists.append(curr_colours)&amp;#10;    run1_target_lists.append(curr_targets)&amp;#10;&amp;#10;# RUN 2&amp;#10;blocks_textlen = [60, 60, 60, 60]  # single n-back blocks&amp;#10;blocks_target_counts = [10, 10, 10, 10]&amp;#10;&amp;#10;# Now loop this list. Check which condition we have there and then create colour list for each text.&amp;#10;run2_colour_lists = []&amp;#10;run2_target_lists = []&amp;#10;for block_idx, block_length in enumerate(blocks_textlen):&amp;#10;    # get 1st letter of block name - that tells us the condition&amp;#10;    block_cond = run2_blocks[block_idx][0]&amp;#10;    #print(f&quot;block cond: {block_cond}&quot;)&amp;#10;&amp;#10;    # for each condition, decide which n-back level we want to assign&amp;#10;    # For all no-n-back blocks, we use 1 (just for the colour list generation)&amp;#10;    # global curr_nback_level&amp;#10;    if block_cond == &quot;R&quot;:&amp;#10;        curr_nback_level = 1&amp;#10;    elif block_cond == &quot;1&quot;:&amp;#10;        curr_nback_level = 1&amp;#10;    elif block_cond == &quot;2&quot;:&amp;#10;        curr_nback_level = 2&amp;#10;    #print(f&quot;curr nback: {curr_nback_level}&quot;)&amp;#10;&amp;#10;    # generate colour list for current block&amp;#10;    # global curr_colours&amp;#10;    curr_colours = create_nback_stimlist(nback_level=curr_nback_level,&amp;#10;                                         colour_codes=colours,&amp;#10;                                         story=[&quot;x&quot;] * block_length,&amp;#10;                                         target_abs_min=blocks_target_counts[block_idx],&amp;#10;                                         target_abs_max=blocks_target_counts[block_idx],&amp;#10;                                         zeroback_target=None)&amp;#10;&amp;#10;    # get list of targets / non-targets&amp;#10;    curr_targets = get_targets(stim_list=curr_colours,&amp;#10;                               nback_level=curr_nback_level)&amp;#10;&amp;#10;    # add to bigger lists&amp;#10;    run2_colour_lists.append(curr_colours)&amp;#10;    run2_target_lists.append(curr_targets)&amp;#10;&amp;#10;# RUNS 3, 4, 5 &amp; 6&amp;#10;blocks_textlen = [300, 300, 300, 300] # dual-task blocks&amp;#10;blocks_target_counts = [50, 50, 50, 50]  # dual-task blocks&amp;#10;&amp;#10;# Now loop this list. Check which condition we have there and then create colour list for each text.&amp;#10;dual_blocks = run3_blocks, run4_blocks, run5_blocks, run6_blocks&amp;#10;run3_4_5_6_colour_lists = []&amp;#10;run3_4_5_6_target_lists = []&amp;#10;for block_idx, block_length in enumerate(blocks_textlen):&amp;#10;    # get 1st letter of block name - that tells us the condition&amp;#10;    block_cond = dual_blocks[block_idx][0]&amp;#10;&amp;#10;    # for each condition, decide which n-back level we want to assign&amp;#10;    # For all no-n-back blocks, we use 1 (just for the colour list generation)&amp;#10;    # global curr_nback_level&amp;#10;    if block_cond == &quot;R&quot;:&amp;#10;        curr_nback_level = 1&amp;#10;    elif block_cond == &quot;1&quot;:&amp;#10;        curr_nback_level = 1&amp;#10;    elif block_cond == &quot;2&quot;:&amp;#10;        curr_nback_level = 2&amp;#10;    #print(f&quot;curr nback: {curr_nback_level}&quot;)&amp;#10;&amp;#10;    # generate colour list for current block&amp;#10;    # global curr_colours&amp;#10;    curr_colours = create_nback_stimlist(nback_level=curr_nback_level,&amp;#10;                                         colour_codes=colours,&amp;#10;                                         story=[&quot;x&quot;] * block_length,&amp;#10;                                         target_abs_min=blocks_target_counts[block_idx],&amp;#10;                                         target_abs_max=blocks_target_counts[block_idx],&amp;#10;                                         zeroback_target=None)&amp;#10;&amp;#10;    # get list of targets / non-targets&amp;#10;    curr_targets = get_targets(stim_list=curr_colours,&amp;#10;                               nback_level=curr_nback_level)&amp;#10;&amp;#10;    # add to bigger lists&amp;#10;    run3_4_5_6_colour_lists.append(curr_colours)&amp;#10;    run3_4_5_6_target_lists.append(curr_targets)&amp;#10;&amp;#10;run3_colour_lists = run3_4_5_6_colour_lists[0]&amp;#10;run4_colour_lists = run3_4_5_6_colour_lists[1]&amp;#10;run5_colour_lists = run3_4_5_6_colour_lists[2]&amp;#10;run6_colour_lists = run3_4_5_6_colour_lists[3]&amp;#10;&amp;#10;run3_target_lists = run3_4_5_6_target_lists[0]&amp;#10;run4_target_lists = run3_4_5_6_target_lists[1]&amp;#10;run5_target_lists = run3_4_5_6_target_lists[2]&amp;#10;run6_target_lists = run3_4_5_6_target_lists[3]&amp;#10;&amp;#10;print(&quot;------ finished preparing stimuli! ------&quot;)&amp;#10;&amp;#10;# ------------------------------------------&amp;#10;&amp;#10;# init block counter for the whole experiment and for each run&amp;#10;exp_block_counter = 0&amp;#10;# init block counter for run1 (two blocks in total)&amp;#10;run1_block_counter = 0&amp;#10;# init block counter for run2 (four blocks in total)&amp;#10;run2_block_counter = 0&amp;#10;# init block counter for run3 (one block in total)&amp;#10;run3_block_counter = 0&amp;#10;# init block counter for run4 (one block in total)&amp;#10;run4_block_counter = 0&amp;#10;# init block counter for run5 (one block in total)&amp;#10;run5_block_counter = 0&amp;#10;# init block counter for run6 (one block in total)&amp;#10;run6_block_counter = 0&amp;#10;&amp;#10;print(&quot;starting experiment now!&quot;)" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="stimuli" valType="code" updates="None" name="name"/>
      </CodeComponent>
      <CodeComponent name="setup_eyelink" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="import * as pylink from 'pylink';&amp;#10;import * as platform from 'platform';&amp;#10;import {Image} from 'PIL';&amp;#10;import {EyeLinkCoreGraphicsPsychoPy} from 'EyeLinkCoreGraphicsPsychoPy';&amp;#10;import {ascii_letters, digits} from 'string';&amp;#10;edf_name = expInfo[&quot;participant&quot;];&amp;#10;if ((edf_name.length &gt; 4)) {&amp;#10;    console.log(&quot;edf file name is too long - choose shorter participant code!&quot;);&amp;#10;}&amp;#10;eyelink_IP = &quot;100.1.1.1&quot;;&amp;#10;el_tracker = new pylink.EyeLink(eyelink_IP);&amp;#10;edf_file = (edf_name + &quot;.EDF&quot;);&amp;#10;el_tracker.openDataFile(edf_file);&amp;#10;preamble_text = `RECORDED BY ${os.path.basename(__file__)}`;&amp;#10;el_tracker.sendCommand(`add_file_preamble_text '${preamble_text}`);&amp;#10;el_tracker.setOfflineMode();&amp;#10;file_event_flags = &quot;LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT&quot;;&amp;#10;link_event_flags = &quot;LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT&quot;;&amp;#10;eyelink_ver = 5;&amp;#10;if ((eyelink_ver &gt; 3)) {&amp;#10;    file_sample_flags = &quot;LEFT,RIGHT,GAZE,HREF,RAW,AREA,HTARGET,GAZERES,BUTTON,STATUS,INPUT&quot;;&amp;#10;    link_sample_flags = &quot;LEFT,RIGHT,GAZE,GAZERES,AREA,HTARGET,STATUS,INPUT&quot;;&amp;#10;} else {&amp;#10;    file_sample_flags = &quot;LEFT,RIGHT,GAZE,HREF,RAW,AREA,GAZERES,BUTTON,STATUS,INPUT&quot;;&amp;#10;    link_sample_flags = &quot;LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS,INPUT&quot;;&amp;#10;}&amp;#10;el_tracker.sendCommand(&quot;sample_rate = 1000&quot;);&amp;#10;el_tracker.sendCommand(&quot;calibration_type = HV9&quot;);&amp;#10;el_tracker.sendCommand(&quot;button_function 5 'accept_target_fixation'&quot;);&amp;#10;[scn_width, scn_height] = psychoJS.window.size;&amp;#10;el_coords = `screen_pixel_coords = 0 0 ${(scn_width - 1)} ${(scn_height - 1)}`;&amp;#10;el_tracker.sendCommand(el_coords);&amp;#10;dv_coords = `DISPLAY_COORDS 0 0 ${(scn_width - 1)} ${(scn_height - 1)}`;&amp;#10;el_tracker.sendMessage(dv_coords);&amp;#10;function et_abort_exp() {&amp;#10;    /* Ends recording  */&amp;#10;    el_tracker = pylink.getEYELINK();&amp;#10;    if (el_tracker.isRecording()) {&amp;#10;        pylink.pumpDelay(100);&amp;#10;        el_tracker.stopRecording();&amp;#10;    }&amp;#10;    el_tracker.setOfflineMode();&amp;#10;    el_tracker.sendCommand(&quot;clear_screen 0&quot;);&amp;#10;    pylink.msecDelay(500);&amp;#10;    el_tracker.closeDataFile();&amp;#10;    console.log(&quot;EDF data is transferring from Eyetracking PC&quot;);&amp;#10;    el_tracker.receiveDataFile(edf_file, edf_file);&amp;#10;    core.wait(2);&amp;#10;    el_tracker.close();&amp;#10;    core.wait(2);&amp;#10;}&amp;#10;" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="### Set up connection to EyeLink Eyetracker&amp;#10;&amp;#10;# for connecting to Eyelink:&amp;#10;import pylink&amp;#10;import platform  # ?&amp;#10;from PIL import Image  # for host backdrop image&amp;#10;from EyeLinkCoreGraphicsPsychoPy import EyeLinkCoreGraphicsPsychoPy  # ?&amp;#10;from string import ascii_letters, digits  # ?&amp;#10;&amp;#10;# set up EDF data file:&amp;#10;edf_name = expInfo['participant']  # make sure file name (without .edf) is &lt;= 8 characters&amp;#10;#if len(edf_name) &gt; 4:&amp;#10;#    print(&quot;edf file name is too long - choose shorter participant code!&quot;)&amp;#10;# eyetracking data should be saved in folder &quot;eyetracking_data&quot;,&amp;#10;# located in the same folder as this script&amp;#10;&amp;#10;# We download the EDF file with the data from the Eyelink Host PC (aka the Eyetracking PC)&amp;#10;# at the end of this experiment and put it into this folder.&amp;#10;&amp;#10;&amp;#10;### Connect to the Eyelink Host PC&amp;#10;&amp;#10;eyelink_IP = &quot;100.1.1.1&quot;  # set IP address of host PC here&amp;#10;el_tracker = pylink.EyeLink(eyelink_IP)&amp;#10;&amp;#10;### Open an EDF file on the Host PC:&amp;#10;edf_file = edf_name + &quot;.EDF&quot;&amp;#10;el_tracker.openDataFile(edf_file)&amp;#10;&amp;#10;# Modify EDF file (this is optional):&amp;#10;# If the text starts with &quot;RECORDED BY&quot;, it will be available in the DataViewer's Inspector window&amp;#10;# if you click on the EDF session node in the top panel and look for the &quot;Recorded By:&quot; field&amp;#10;# in the bottom panel of the inspector.&amp;#10;preamble_text = &quot;RECORDED BY %s&quot; % os.path.basename(__file__)&amp;#10;el_tracker.sendCommand(&quot;add_file_preamble_text '%s'&quot; % preamble_text)&amp;#10;&amp;#10;### Configure the Eyetracker:&amp;#10;# put the tracker in offline mode before we change the tracking parameters:&amp;#10;el_tracker.setOfflineMode()&amp;#10;&amp;#10;# Get software version: 1-EyeLink I, 2-EyeLink II, 3/4-EyeLink 1000, 5-EyeLink 1000 Plus, 6-Portable DUO&amp;#10;# vstr = el_tracker.getTrackerVersionString()&amp;#10;# eyelink_ver = int(vstr.split()[-1].split('.')[0]&amp;#10;# print version info:&amp;#10;# print(&quot;running experiment on %s, version %d&quot; % (vstr, eyelink_ver))&amp;#10;&amp;#10;&amp;#10;### Data control:&amp;#10;&amp;#10;# Which events do you want to save in the EDF file?&amp;#10;# --&gt; include everything by default!&amp;#10;file_event_flags = 'LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT'&amp;#10;# Which events should be made available over the link?&amp;#10;# --&gt; include everything by default!&amp;#10;link_event_flags = 'LEFT,RIGHT,FIXATION,SACCADE,BLINK,MESSAGE,BUTTON,INPUT'&amp;#10;# What sample data should be saved in the EDF data file and made available over the link?&amp;#10;# --&gt; include the &quot;HTARGET&quot; flag to save head target sticker data for supported eye trackers with version &gt; 3&amp;#10;eyelink_ver = 5&amp;#10;if eyelink_ver &gt; 3:&amp;#10;    file_sample_flags = 'LEFT,RIGHT,GAZE,HREF,RAW,AREA,HTARGET,GAZERES,BUTTON,STATUS,INPUT'&amp;#10;    link_sample_flags = 'LEFT,RIGHT,GAZE,GAZERES,AREA,HTARGET,STATUS,INPUT'&amp;#10;else:&amp;#10;    file_sample_flags = 'LEFT,RIGHT,GAZE,HREF,RAW,AREA,GAZERES,BUTTON,STATUS,INPUT'&amp;#10;    link_sample_flags = 'LEFT,RIGHT,GAZE,GAZERES,AREA,STATUS,INPUT'&amp;#10;&amp;#10;# Optional tracking parameters:&amp;#10;# Sample rate: 250, 500, 1000 or 2000 (depending on tracker)&amp;#10;el_tracker.sendCommand(&quot;sample_rate = 1000&quot;)&amp;#10;# choose a calibration type: H3, HV3, HV5, HV13 (HV = Horizontal/Vertical)&amp;#10;el_tracker.sendCommand(&quot;calibration_type = HV9&quot;)  # use 9 target dots for calibration/validation screen&amp;#10;# Set a gamepad button to accept calibration/drift check target&amp;#10;# You need a supported gamepad/button box that's connected to the Host PC&amp;#10;el_tracker.sendCommand(&quot;button_function 5 'accept_target_fixation'&quot;)  # I think that's enter on our keyboard?&amp;#10;&amp;#10;### Set screen resolution:&amp;#10;&amp;#10;# get the native screen resolution used by PsychoPy&amp;#10;scn_width, scn_height = win.size&amp;#10;&amp;#10;# pass the display pixel coordinates (left, top, right, bottom) to the tracker&amp;#10;el_coords = &quot;screen_pixel_coords = 0 0 %d %d&quot; % (scn_width - 1, scn_height - 1)&amp;#10;el_tracker.sendCommand(el_coords)&amp;#10;&amp;#10;# write a DISPLAY_COORDS message to the EDF file&amp;#10;# Data Viewer needs this piece of info for proper visualisation,&amp;#10;# see &quot;Protocol for Eyelink Data to Viewer Integration&quot; in DataViewer user manual&amp;#10;dv_coords = &quot;DISPLAY_COORDS 0 0 %d %d&quot; % (scn_width - 1, scn_height - 1)&amp;#10;el_tracker.sendMessage(dv_coords)&amp;#10;&amp;#10;&amp;#10;def et_abort_exp():&amp;#10;    &quot;&quot;&quot;Ends recording &quot;&quot;&quot;&amp;#10;    el_tracker = pylink.getEYELINK()&amp;#10;&amp;#10;    # Stop recording&amp;#10;    if el_tracker.isRecording():&amp;#10;        # add 100 ms to catch final trial events&amp;#10;        pylink.pumpDelay(100)&amp;#10;        el_tracker.stopRecording()&amp;#10;&amp;#10;    # put eyetracker into Offline Mode:&amp;#10;    el_tracker.setOfflineMode()&amp;#10;&amp;#10;    # clear eyetracking host PC screen and wait for 500 ms&amp;#10;    el_tracker.sendCommand('clear_screen 0')&amp;#10;    pylink.msecDelay(500)&amp;#10;&amp;#10;    # close data file:&amp;#10;    el_tracker.closeDataFile()&amp;#10;&amp;#10;    # print file transfer message:&amp;#10;    print(&quot;EDF data is transferring from Eyetracking PC&quot;)&amp;#10;&amp;#10;    # download the EDF data from the Host PC to a local data folder:&amp;#10;    el_tracker.receiveDataFile(edf_file, edf_file)&amp;#10;&amp;#10;    # Wait 2s to ensure data isn't lost:&amp;#10;    core.wait(2)&amp;#10;&amp;#10;    # close eyetracker:&amp;#10;    el_tracker.close()&amp;#10;&amp;#10;    # Wait again:&amp;#10;    core.wait(2) " valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="setup_eyelink" valType="code" updates="None" name="name"/>
      </CodeComponent>
    </Routine>
    <Routine name="wait_for_scanner">
      <CodeComponent name="scanner_wait" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="psychoJS.eventManager.clearEvents();&amp;#10;trigger_count_run1 = 0;&amp;#10;instr_text = locals()[&quot;welcome_text&quot;];&amp;#10;[first_trigger_time, trigger_count] = wait_for_first_trigger(instr_text, trigger_count);&amp;#10;" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="#################################################&amp;#10;#              Welcome to experiment            #&amp;#10;#################################################&amp;#10;# this routine waits for the scanner trigger and then starts the experiment&amp;#10;print(f&quot;trigger count: {trigger_count}&quot;)&amp;#10;# clear buffer of all previously recorded key events:&amp;#10;event.clearEvents()&amp;#10;&amp;#10;# Reset global clock&amp;#10;# globalClock = core.Clock()&amp;#10;# globalClock.reset()&amp;#10;&amp;#10;### Show instructions&amp;#10;# set instruction text&amp;#10;instr_text = locals()[&quot;welcome_text&quot;]&amp;#10;&amp;#10;# Wait for the first trigger&amp;#10;first_trigger_time, trigger_count = wait_for_first_trigger(instr_text, trigger_count)" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="scanner_wait" valType="code" updates="None" name="name"/>
      </CodeComponent>
    </Routine>
    <Routine name="single_reading">
      <CodeComponent name="single_reading_blocks" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="#################################################&amp;#10;#        Blocks with text – reading only        #&amp;#10;#################################################&amp;#10;# this routine is for all blocks with texts that are paced, i.e., visually presented without space bar&amp;#10;# this is for reading only texts&amp;#10;&amp;#10;# make mouse invisible during experiment&amp;#10;# mouse = io.devices.mouse&amp;#10;win.setMouseVisible(False)&amp;#10;&amp;#10;if 0 &lt;= exp_block_counter &lt;= 1:&amp;#10;    # We collected RTs &amp; words from the self-paced block of each condition&amp;#10;    RT_per_letter_baseline = int(expInfo['RT_per_letter_baseline'])&amp;#10;    print(&quot;Using RT_per_letter_baseline for this block:&quot;, RT_per_letter_baseline)&amp;#10;&amp;#10;    # get block kind&amp;#10;    curr_block = run1_blocks[run1_block_counter]&amp;#10;&amp;#10;    # ----------------------------------&amp;#10;&amp;#10;    # clear buffer of all previously recorded key events:&amp;#10;    event.clearEvents()&amp;#10;&amp;#10;    ### specify settings for the current block&amp;#10;    ### Prepare stimuli:&amp;#10;&amp;#10;    if curr_block in [&quot;Reading_Baseline_main_no_click&quot;, &quot;Reading_pseudotext_no_click&quot;]:&amp;#10;        print(f&quot;Start preparing block {curr_block}&quot;)&amp;#10;&amp;#10;        # light background&amp;#10;        win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;        win.flip()&amp;#10;&amp;#10;        ### Show instructions&amp;#10;        if curr_block == &quot;Reading_Baseline_main_no_click&quot;:&amp;#10;&amp;#10;            # set instruction text&amp;#10;            instr_text = locals()[&quot;instr_&quot; + curr_block]&amp;#10;            # create text box&amp;#10;            instr_text_stim = visual.TextStim(win,&amp;#10;                                              text=instr_text,&amp;#10;                                              height=0.03,  # font height relative to height of screen&amp;#10;                                              pos=(0, 0.08),  # move up a bit&amp;#10;                                              color=&quot;black&quot;)&amp;#10;&amp;#10;            # show instructions on screen&amp;#10;            win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;            instr_text_stim.draw()&amp;#10;            win.flip()&amp;#10;            core.wait(8.75)  # wait for 8.75 s&amp;#10;            # If esc is pressed, end the experiment:&amp;#10;            if 'escape' in event.getKeys():&amp;#10;                et_abort_exp()  # shut down eyetrigger and download incremental data&amp;#10;                # close trigger &amp; close experiment&amp;#10;                core.wait(0.5)&amp;#10;                core.quit()&amp;#10;&amp;#10;            # get text nr:&amp;#10;            curr_text_nr = all_texts_nrs_list[exp_block_counter]&amp;#10;            curr_text = locals()[curr_text_nr]&amp;#10;&amp;#10;            # compute RTs using participant's average reading speed / letter&amp;#10;            # we define a minimum and a maximum duration for each word&amp;#10;            # the minimum is based on 5 x RT per letter in the respective condition&amp;#10;            # the max duration is based on a time-out of 1.5 s in the reading baseline condition&amp;#10;            minimum_duration = 5 * RT_per_letter_baseline&amp;#10;            maximum_duration = 1500&amp;#10;            curr_durations = []&amp;#10;            for word in curr_text:&amp;#10;                duration = RT_per_letter_baseline * math.log((len(word))) + 4 * RT_per_letter_baseline&amp;#10;                if duration &lt; maximum_duration:&amp;#10;                    curr_durations.append(max(duration, minimum_duration))&amp;#10;                else:&amp;#10;                    curr_durations.append(maximum_duration)&amp;#10;&amp;#10;            # print(f&quot;\tdurations for paced baseline block: {curr_durations}&quot;)&amp;#10;&amp;#10;            ### change background colour&amp;#10;            win.setColor(dark_bg_col, colorSpace='rgb')&amp;#10;            win.flip()&amp;#10;&amp;#10;            # show main block questions&amp;#10;            skip_questions_paced = False&amp;#10;&amp;#10;        elif curr_block == &quot;Reading_pseudotext_no_click&quot;:&amp;#10;&amp;#10;            # set instruction text&amp;#10;            instr_text = locals()[&quot;instr_&quot; + curr_block]&amp;#10;            # create text box&amp;#10;            instr_text_stim = visual.TextStim(win,&amp;#10;                                              text=instr_text,&amp;#10;                                              height=0.03,  # font height relative to height of screen&amp;#10;                                              pos=(0, 0.08),  # move up a bit&amp;#10;                                              color=&quot;black&quot;,&amp;#10;                                              wrapWidth=1.5)&amp;#10;&amp;#10;            # show instructions on screen&amp;#10;            win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;            instr_text_stim.draw()&amp;#10;            win.flip()&amp;#10;            core.wait(8.75)  # wait for 8.75 s&amp;#10;            # If esc is pressed, end the experiment:&amp;#10;            if 'escape' in event.getKeys():&amp;#10;                et_abort_exp()  # shut down eyetrigger and download incremental data&amp;#10;                # close trigger &amp; close experiment&amp;#10;                core.wait(0.5)&amp;#10;                core.quit()&amp;#10;&amp;#10;            # get text nr:&amp;#10;            curr_text_nr = all_texts_nrs_list[exp_block_counter]&amp;#10;            curr_text = locals()[curr_text_nr]&amp;#10;&amp;#10;            # compute RTs using participant's average reading speed / letter&amp;#10;            # we define a minimum and a maximum duration for each word&amp;#10;            # the minimum is based on 5 x RT per letter in the respective condition&amp;#10;            # the max duration is based on a time-out of 1.5 s in the reading baseline condition&amp;#10;            minimum_duration = 5 * RT_per_letter_baseline&amp;#10;            maximum_duration = 1500&amp;#10;            curr_durations = []&amp;#10;            for word in curr_text:&amp;#10;                duration = RT_per_letter_baseline * math.log((len(word))) + 4 * RT_per_letter_baseline&amp;#10;                if duration &lt; maximum_duration:&amp;#10;                    curr_durations.append(max(duration, minimum_duration))&amp;#10;                else:&amp;#10;                    curr_durations.append(maximum_duration)&amp;#10;&amp;#10;            # print(f&quot;\tdurations for paced baseline block: {curr_durations}&quot;)&amp;#10;&amp;#10;            ### change background colour&amp;#10;            win.setColor(dark_bg_col, colorSpace='rgb')&amp;#10;            win.flip()&amp;#10;&amp;#10;            # show main block questions&amp;#10;            skip_questions_paced = True&amp;#10;&amp;#10;        # Define n-back level&amp;#10;        curr_nback_cond = None&amp;#10;&amp;#10;        print(f&quot;\tcurrent n-back condition: {curr_nback_cond}&quot;)&amp;#10;        print(f&quot;\tcurrent text: {curr_text_nr}&quot;)&amp;#10;        print(f&quot;\texp block counter: {exp_block_counter}&quot;)&amp;#10;&amp;#10;        # get list with targets &amp; list with colours&amp;#10;        curr_targets = run1_target_lists[run1_block_counter]&amp;#10;        curr_colours = run1_colour_lists[run1_block_counter]&amp;#10;&amp;#10;    ### Start block loop&amp;#10;    if curr_block in [&quot;Reading_Baseline_main_no_click&quot;, &quot;Reading_pseudotext_no_click&quot;]:&amp;#10;&amp;#10;        # create empty text stimulus&amp;#10;        stim = visual.TextStim(win=win,&amp;#10;                               text=&quot; &quot;,&amp;#10;                               pos=(0, 0),  # center stimulus&amp;#10;                               font=&quot;Times New Roman&quot;,&amp;#10;                               height=0.07)&amp;#10;&amp;#10;        stim.draw()&amp;#10;        win.flip()&amp;#10;&amp;#10;        # clear buffer of all previously recorded key events:&amp;#10;        event.clearEvents()&amp;#10;        defaultKeyboard.clearEvents()&amp;#10;&amp;#10;        # CREATE CLOCKS:&amp;#10;        my_block_clock = core.Clock()&amp;#10;        my_block_clock.reset()  # start block clock&amp;#10;        start_time = my_block_clock.getTime()  # get start time of block&amp;#10;        # also create trial clock&amp;#10;        my_trial_clock = core.Clock()&amp;#10;&amp;#10;        # send block onset trigger&amp;#10;        send_trigger(curr_block + &quot;_onset&quot;)&amp;#10;&amp;#10;        # loop words in current text&amp;#10;        for trial_idx, curr_word in enumerate(curr_text):&amp;#10;            # print(&quot;current idx: &quot; + str(trial_idx) + &quot;, curr word:&quot; + curr_word)&amp;#10;&amp;#10;            # Log trigger information before or after other trial-specific logging&amp;#10;            # trigger_count = log_trigger(trigger_count)&amp;#10;&amp;#10;            ### prepare &amp; show current word:&amp;#10;            # get current colour&amp;#10;            curr_colour = curr_colours[trial_idx]&amp;#10;&amp;#10;            # get duration for current word&amp;#10;            curr_duration = curr_durations[trial_idx] / 1000  # convert ms to seconds&amp;#10;            # print(&quot;duration for current word (in s):&quot;, curr_duration)&amp;#10;&amp;#10;            # get trial number (start counting from 1, so add 1)&amp;#10;            curr_trial_nr = trial_idx + 1&amp;#10;&amp;#10;            # set current word &amp; colour as content of text stimulus&amp;#10;            stim.color = curr_colour&amp;#10;            stim.text = curr_word&amp;#10;&amp;#10;            # show word on screen&amp;#10;            stim.draw()  # draw word on screen&amp;#10;            # update the window to clear the screen and display&amp;#10;            # the stimulus, send trigger on flip&amp;#10;            win.callOnFlip(send_trigger, &quot;trial_onset&quot;)&amp;#10;&amp;#10;            # start trial clock &amp; record trial onset time&amp;#10;            my_trial_clock.reset()&amp;#10;            onset_time = my_trial_clock.getTime()&amp;#10;            global_onset_time = globalClock.getTime()&amp;#10;            onset_time_rel2trigger = global_onset_time - first_trigger_time&amp;#10;&amp;#10;            ### start recording responses&amp;#10;            # start while loop that looks for responses&amp;#10;            # --&gt; end while loop only if duration for current word is over&amp;#10;            while my_trial_clock.getTime() &lt; (onset_time + curr_duration):&amp;#10;&amp;#10;                stim.draw()&amp;#10;                win.flip()&amp;#10;&amp;#10;                # check for key responses:&amp;#10;                keys = event.getKeys(['1', 'escape'])&amp;#10;&amp;#10;                # if there were, check responses:&amp;#10;                for key in keys:&amp;#10;&amp;#10;                    # if participant pressed button &quot;c&quot; for the first time and it's an n-back condition&amp;#10;                    # where they're actually supposed to do that (aka not a reading baseline condition)...&amp;#10;                    if key == '1' and curr_nback_cond != None and saw_target == False:&amp;#10;                        # get reaction time&amp;#10;                        curr_nback_RT = my_trial_clock.getTime() * 1000&amp;#10;                        # send trigger for response:&amp;#10;                        send_trigger(&quot;response_target&quot;)&amp;#10;                        # only get first target response, we don't care if they press the button more than once:&amp;#10;                        saw_target = True&amp;#10;&amp;#10;                    # If esc is pressed, end the experiment:&amp;#10;                    elif key == 'escape':&amp;#10;                        et_abort_exp()  # shut down eyetrigger and download incremental data&amp;#10;                        # close trigger &amp; close experiment&amp;#10;                        # core.wait(time_after_trigger)&amp;#10;                        # parallel.setData(0)&amp;#10;                        core.wait(0.5)&amp;#10;                        core.quit()&amp;#10;&amp;#10;            ### end trial&amp;#10;            # print(&quot;\tend paced trial&quot;)&amp;#10;            # stop display of current word &amp; send trial offset trigger&amp;#10;            win.callOnFlip(send_trigger, &quot;trial_offset&quot;)&amp;#10;&amp;#10;            # check whether response was hit, miss, false alarm or correct rejection&amp;#10;            # they saw a target and there was one: hit&amp;#10;            if curr_nback_cond != None:&amp;#10;                if saw_target and curr_target:&amp;#10;                    curr_nback_response = &quot;hit&quot;&amp;#10;                # they didn't see a target but there was one: miss&amp;#10;                elif saw_target == False and curr_target:&amp;#10;                    curr_nback_response = &quot;miss&quot;&amp;#10;                    curr_nback_RT = None&amp;#10;                # they didn't see a target and there was none: correct rejection&amp;#10;                elif saw_target == False and curr_target == False:&amp;#10;                    curr_nback_response = &quot;correct rejection&quot;&amp;#10;                    curr_nback_RT = None&amp;#10;                # they saw a target but there was none: false alarm&amp;#10;                elif saw_target and curr_target == False:&amp;#10;                    curr_nback_response = &quot;false alarm&quot;&amp;#10;            # if it wasn't an n-back task block:&amp;#10;            else:&amp;#10;                curr_target = None&amp;#10;                curr_nback_response = None&amp;#10;                curr_nback_RT = None&amp;#10;&amp;#10;            ### save everything in output csv&amp;#10;            thisExp.addData('colour', curr_colour)&amp;#10;            thisExp.addData('global_onset_time', global_onset_time)&amp;#10;            thisExp.addData('onset_time_rel2trigger', onset_time_rel2trigger)&amp;#10;            thisExp.addData('target', curr_target)&amp;#10;            thisExp.addData('nback_response', curr_nback_response)&amp;#10;            thisExp.addData('nback_RT', curr_nback_RT)  # in ms&amp;#10;            thisExp.addData('duration', curr_duration * 1000)  # in ms&amp;#10;            thisExp.addData('text_nr', curr_text_nr)&amp;#10;            thisExp.addData('trial_nr', curr_trial_nr)&amp;#10;            thisExp.addData('block_nr_exp', exp_block_counter+1)&amp;#10;            thisExp.addData('run_nr', '1')&amp;#10;            thisExp.addData('block_nr_run', run1_block_counter+1)&amp;#10;            thisExp.addData('block_name', curr_block)&amp;#10;            thisExp.addData('n-back_level', curr_nback_cond)&amp;#10;            # careful, make sure quotes in the strings are escaped using a&amp;#10;            # quote (weird, I know) so it's properly saved in the CSV:&amp;#10;            thisExp.addData('word', escape_quotes(curr_word))&amp;#10;&amp;#10;            # start a new row in the csv&amp;#10;            thisExp.nextEntry()&amp;#10;&amp;#10;            ### IF TESTING MODE ENABLED: end loop after 4 trials&amp;#10;            if expInfo['testing_mode'] == &quot;yes&quot;:&amp;#10;                if trial_idx == 3:&amp;#10;                    break&amp;#10;&amp;#10;        print(&quot;finished presenting trials&quot;)&amp;#10;&amp;#10;        # send block offset trigger&amp;#10;        send_trigger(&quot;block_offset&quot;)&amp;#10;&amp;#10;        if curr_block == &quot;Reading_pseudotext_no_click&quot;:&amp;#10;            # show main block questions&amp;#10;            skip_questions_paced = True&amp;#10;&amp;#10;            # go to next run&amp;#10;            exp_block_counter += 1&amp;#10;            run1_block_counter += 1&amp;#10;            print(f&quot;Going to block {exp_block_counter + 1}/10 in the experiment now!&quot;)&amp;#10;            continueRoutine = False&amp;#10;&amp;#10;            # If there are still blocks left, go to next one.&amp;#10;            # If not, end loop here:&amp;#10;            if run1_block_counter == 2:&amp;#10;                print(f&quot;Finished block {run1_block_counter}/2 in run 1, moving on to next run!&quot;)&amp;#10;                loop_run1_single_reading.finished = True" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="single_reading_blocks" valType="code" updates="None" name="name"/>
      </CodeComponent>
      <CodeComponent name="questions" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="##########################################################&amp;#10;#              Text Comprehension Questions              #&amp;#10;##########################################################&amp;#10;&amp;#10;def setup_question(question_text, answers_text):&amp;#10;    question = visual.TextStim(win, text=question_text, pos=(0, 0.2), color=&quot;black&quot;, height=0.03, anchorHoriz='center', alignText='center', wrapWidth=1)&amp;#10;    answers = [visual.TextStim(win, text=ans, pos=(0, 0.1 - i * 0.08), color=&quot;black&quot;, height=0.03, wrapWidth=1, anchorHoriz='center', alignText='center') for i, ans in enumerate(answers_text)]&amp;#10;    return question, answers&amp;#10;&amp;#10;def display_question_and_get_response(question, answers, correct_answer):&amp;#10;    defaultKeyboard.clearEvents()&amp;#10;    &amp;#10;    # Set-up time to write into logfile&amp;#10;    question_time = globalClock.getTime()&amp;#10;    onset_time_rel2trigger = question_time - first_trigger_time&amp;#10;&amp;#10;    question.autoDraw = True&amp;#10;    for answer in answers:&amp;#10;        answer.autoDraw = True&amp;#10;    instr_text.autoDraw = True&amp;#10;&amp;#10;    countdown_timer = visual.TextStim(win, text='', pos=(0, -0.25), color=&quot;grey&quot;, height=0.02, anchorHoriz='center', alignText='center', wrapWidth=1)&amp;#10;&amp;#10;    chosen_ans = &quot;NA&quot;&amp;#10;    is_correct = &quot;NA&quot;&amp;#10;    button_pressed = &quot;NA&quot;&amp;#10;    response_received = False&amp;#10;&amp;#10;    # Start a clock to track response time&amp;#10;    response_clock = core.Clock()&amp;#10;&amp;#10;    # Countdown from 10 seconds&amp;#10;    while response_clock.getTime() &lt; 10:&amp;#10;        remaining_time = 10 - int(response_clock.getTime())&amp;#10;        countdown_timer.text = f&quot;Zeit: {remaining_time}&quot;&amp;#10;        countdown_timer.draw()&amp;#10;        win.flip()&amp;#10;&amp;#10;        keys = defaultKeyboard.getKeys(['1', '2', '3', '4'], waitRelease=False)&amp;#10;        if keys:&amp;#10;            key_name = keys[0].name  # Get the name of the first key pressed&amp;#10;            button_pressed = key_name&amp;#10;&amp;#10;            # Now, use the key_name to determine the action&amp;#10;            if key_name == '1':&amp;#10;                index = 0  # Corresponds to the first choice&amp;#10;            elif key_name == '2':&amp;#10;                index = 1  # Corresponds to the second choice&amp;#10;            elif key_name == '3':&amp;#10;                index = 2  # Corresponds to the third choice&amp;#10;            elif key_name == '4':&amp;#10;                index = 3  # Corresponds to the fourth choice&amp;#10;            else:&amp;#10;                index = None  # Just in case, not really needed if you're sure about the input keys&amp;#10;&amp;#10;            # Proceed with your logic based on the index&amp;#10;            if index is not None:&amp;#10;                chosen_ans = chr(97 + index)  # Convert index to letter ('a', 'b', 'c', 'd')&amp;#10;                is_correct = chosen_ans == correct_answer  # Assuming correct_answer is defined ('a', 'b', 'c', or 'd')&amp;#10;                for i, answer in enumerate(answers):&amp;#10;                    answer.setColor(&quot;green&quot; if i == index else &quot;black&quot;)&amp;#10;                win.flip()&amp;#10;                core.wait(0.5)  # Ensure the color change is visible&amp;#10;                response_received = True&amp;#10;                break&amp;#10;&amp;#10;    # Hide the countdown timer after it finishes&amp;#10;    countdown_timer.text = ''&amp;#10;    countdown_timer.draw()&amp;#10;    win.flip()&amp;#10;&amp;#10;    # If no response is received within 10 seconds, return &quot;NA&quot;&amp;#10;    if not response_received:&amp;#10;        chosen_ans = &quot;NA&quot;&amp;#10;        is_correct = &quot;NA&quot;&amp;#10;        button_pressed = &quot;NA&quot;&amp;#10;&amp;#10;    return question_time, onset_time_rel2trigger, chosen_ans, is_correct, button_pressed&amp;#10;&amp;#10;def reset_answers(answers):&amp;#10;    for answer in answers:&amp;#10;        answer.setColor(&quot;black&quot;)&amp;#10;    question.autoDraw = False&amp;#10;    instr_text.autoDraw = False&amp;#10;    for answer in answers:&amp;#10;        answer.autoDraw = False&amp;#10;&amp;#10;# Set up instructions&amp;#10;win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;win.flip()&amp;#10;instr_text = visual.TextStim(win, text=&quot;(Bitte benutzen Sie die Tasten 1, 2, 3 und 4, um die richtige Antwort auszuwählen.)&quot;, color=&quot;grey&quot;, pos=(0, -0.3), wrapWidth=2, height=0.018)&amp;#10;event.clearEvents()&amp;#10;&amp;#10;# Assuming skip_questions_paced and other variables are defined&amp;#10;if not skip_questions_paced:&amp;#10;    # Setup for Q1&amp;#10;    Q1_text = locals()[curr_text_nr + &quot;_Q1&quot;]&amp;#10;    Q1_answers = locals()[curr_text_nr + &quot;_Q1_ans&quot;]&amp;#10;    Q1_correct = locals()[curr_text_nr + &quot;_Q1_corr&quot;]&amp;#10;&amp;#10;    question, answers = setup_question(Q1_text, Q1_answers)&amp;#10;    question_time, onset_time_rel2trigger, chosen_ans, is_correct, button_pressed = display_question_and_get_response(question, answers, Q1_correct)&amp;#10;    print(f&quot;Chosen answer for Q1: {chosen_ans}, Correct: {is_correct}&quot;)&amp;#10;    reset_answers(answers)&amp;#10;&amp;#10;    # save data:&amp;#10;    thisExp.addData('global_onset_time', question_time)&amp;#10;    thisExp.addData('onset_time_rel2trigger', onset_time_rel2trigger)&amp;#10;    thisExp.addData('question', 'Q1')&amp;#10;    thisExp.addData('button_pressed', button_pressed)&amp;#10;    thisExp.addData('chosen_ans', chosen_ans)&amp;#10;    thisExp.addData('ans_correct', chosen_ans == Q1_correct)&amp;#10;    thisExp.addData('text_nr', curr_text_nr)&amp;#10;    thisExp.addData('block_nr_exp', exp_block_counter+1)&amp;#10;    thisExp.addData('run_nr', '1')&amp;#10;    thisExp.addData('block_nr_run', run1_block_counter+1)&amp;#10;    thisExp.addData('block_name', curr_block)&amp;#10;    thisExp.addData('n-back_level', curr_nback_cond)&amp;#10;&amp;#10;    # start a new row in the csv&amp;#10;    thisExp.nextEntry()&amp;#10;&amp;#10;    # Setup for Q2&amp;#10;    Q2_text = locals()[curr_text_nr + &quot;_Q2&quot;]&amp;#10;    Q2_answers = locals()[curr_text_nr + &quot;_Q2_ans&quot;]&amp;#10;    Q2_correct = locals()[curr_text_nr + &quot;_Q2_corr&quot;]&amp;#10;&amp;#10;    question, answers = setup_question(Q2_text, Q2_answers)&amp;#10;    question_time, onset_time_rel2trigger, chosen_ans, is_correct, button_pressed = display_question_and_get_response(question, answers, Q2_correct)&amp;#10;    print(f&quot;Chosen answer for Q2: {chosen_ans}, Correct: {is_correct}&quot;)&amp;#10;    reset_answers(answers)&amp;#10;&amp;#10;    # save data:&amp;#10;    thisExp.addData('global_onset_time', question_time)&amp;#10;    thisExp.addData('onset_time_rel2trigger', onset_time_rel2trigger)&amp;#10;    thisExp.addData('question', 'Q2')&amp;#10;    thisExp.addData('button_pressed', button_pressed)&amp;#10;    thisExp.addData('chosen_ans', chosen_ans)&amp;#10;    thisExp.addData('ans_correct', chosen_ans == Q2_correct)&amp;#10;    thisExp.addData('text_nr', curr_text_nr)&amp;#10;    thisExp.addData('block_nr_exp', exp_block_counter+1)&amp;#10;    thisExp.addData('run_nr', &quot;1&quot;)&amp;#10;    thisExp.addData('block_nr_run', run1_block_counter+1)&amp;#10;    thisExp.addData('block_name', curr_block)&amp;#10;    thisExp.addData('n-back_level', curr_nback_cond)&amp;#10;&amp;#10;    # start a new row in the csv&amp;#10;    thisExp.nextEntry()&amp;#10;&amp;#10;    # Setup for Q3&amp;#10;    Q3_text = locals()[curr_text_nr + &quot;_Q3&quot;]&amp;#10;    Q3_answers = locals()[curr_text_nr + &quot;_Q3_ans&quot;]&amp;#10;    Q3_correct = locals()[curr_text_nr + &quot;_Q3_corr&quot;]&amp;#10;&amp;#10;    question, answers = setup_question(Q3_text, Q3_answers)&amp;#10;    question_time, onset_time_rel2trigger, chosen_ans, is_correct, button_pressed = display_question_and_get_response(question, answers, Q3_correct)&amp;#10;    print(f&quot;Chosen answer for Q3: {chosen_ans}, Correct: {is_correct}&quot;)&amp;#10;    reset_answers(answers)&amp;#10;&amp;#10;    # save data:&amp;#10;    thisExp.addData('global_onset_time', question_time)&amp;#10;    thisExp.addData('onset_time_rel2trigger', onset_time_rel2trigger)&amp;#10;    thisExp.addData('question', 'Q3')&amp;#10;    thisExp.addData('button_pressed', button_pressed)&amp;#10;    thisExp.addData('chosen_ans', chosen_ans)&amp;#10;    thisExp.addData('ans_correct', chosen_ans == Q3_correct)&amp;#10;    thisExp.addData('text_nr', curr_text_nr)&amp;#10;    thisExp.addData('block_nr_exp', exp_block_counter+1)&amp;#10;    thisExp.addData('run_nr', &quot;1&quot;)&amp;#10;    thisExp.addData('block_nr_run', run1_block_counter+1)&amp;#10;    thisExp.addData('block_name', curr_block)&amp;#10;    thisExp.addData('n-back_level', curr_nback_cond)&amp;#10;&amp;#10;    # start a new row in the csv&amp;#10;    thisExp.nextEntry()&amp;#10;&amp;#10;    # go to next block!&amp;#10;    exp_block_counter += 1&amp;#10;    run1_block_counter += 1&amp;#10;    print(f&quot;Going to block {exp_block_counter + 1}/10 in the experiment now!&quot;)&amp;#10;    print(f&quot;Going to block {run1_block_counter + 1}/2 in run 1 now!&quot;)&amp;#10;    continueRoutine = False&amp;#10;&amp;#10;    # If there are still blocks left, go to next one.&amp;#10;    # If not, end loop here:&amp;#10;    if run1_block_counter == 2:&amp;#10;        loop_run1_single_reading.finished = True" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="questions" valType="code" updates="None" name="name"/>
      </CodeComponent>
      <CodeComponent name="code" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="skip_questions_paced = true;&amp;#10;exp_block_counter = 2;&amp;#10;" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="skip_questions_paced = True&amp;#10;exp_block_counter = 2" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Auto-&gt;JS" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="True" valType="bool" updates="None" name="disabled"/>
        <Param val="code" valType="code" updates="None" name="name"/>
      </CodeComponent>
    </Routine>
    <Routine name="run_finished">
      <CodeComponent name="finished_run" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="#################################################&amp;#10;#                  Finished run                 #&amp;#10;#################################################&amp;#10;&amp;#10;# light background&amp;#10;win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;win.flip()&amp;#10;&amp;#10;if exp_block_counter == 2 or exp_block_counter == 6:&amp;#10;&amp;#10;    # reset (local) trigger counter since new run starts from 0&amp;#10;    trigger_count = 0&amp;#10;&amp;#10;    run_finished_text = &quot;Diese Runde des Experiments ist nun zu Ende. Bitte bleiben Sie ruhig liegen, es geht gleich weiter.&quot;&amp;#10;    # set text&amp;#10;    instr_text = run_finished_text&amp;#10;    # create text box&amp;#10;    instr_text_stim = visual.TextStim(win,&amp;#10;                                      text=instr_text,&amp;#10;                                      height=0.04,&amp;#10;                                      pos=(0, 0),&amp;#10;                                      color=&quot;black&quot;)&amp;#10;&amp;#10;    # display the text on screen until Space is pressed&amp;#10;    while True:&amp;#10;        # keep background ivory&amp;#10;        win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;        instr_text_stim.draw()&amp;#10;        win.flip()&amp;#10;        # end screen if participant presses space&amp;#10;        if 'return' in event.getKeys():&amp;#10;            print(&quot;\tMoving on to next run!&quot;)&amp;#10;            break&amp;#10;        # If esc is pressed, end the experiment:&amp;#10;        elif 'escape' in event.getKeys():&amp;#10;            et_abort_exp()  # shut down eyetrigger and download incremental data&amp;#10;            # close trigger &amp; close experiment&amp;#10;            core.wait(0.5)&amp;#10;            core.quit()&amp;#10;            break" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="finished_run" valType="code" updates="None" name="name"/>
      </CodeComponent>
    </Routine>
    <Routine name="single_nback">
      <CodeComponent name="blocks_single_nback" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="# ################################################&amp;#10;#         Blocks w/o text – single n-back        #&amp;#10;# ################################################&amp;#10;# this routine is for all blocks where there are coloured rectangles&amp;#10;# instead of words and participants are presented with a paced version, i.e., rectangles are presented based on their&amp;#10;# reaction times in the training before scanning&amp;#10;&amp;#10;if 2 &lt;= exp_block_counter &lt;= 5:&amp;#10;&amp;#10;    event. Mouse(visible=False)&amp;#10;&amp;#10;    # clear buffer of all previously recorded key events:&amp;#10;    event.clearEvents()&amp;#10;&amp;#10;    ### Prepare stimuli:&amp;#10;&amp;#10;    RT_per_rectangle_oneback_single = int(expInfo['RT_per_rectangle_oneback_single'])&amp;#10;    RT_per_rectangle_twoback_single = int(expInfo['RT_per_rectangle_twoback_single'])&amp;#10;&amp;#10;    # get block kind&amp;#10;    curr_block = run2_blocks[run2_block_counter]&amp;#10;&amp;#10;    if curr_block in [&quot;1back_single_main_no_click&quot;, &quot;2back_single_main_no_click&quot;]:&amp;#10;        print(f&quot;Start preparing block {curr_block}&quot;)&amp;#10;        if curr_block == &quot;1back_single_main_no_click&quot;:&amp;#10;            print(&quot;Using RT_per_rectangle_oneback for this block:&quot;, RT_per_rectangle_oneback_single)&amp;#10;&amp;#10;        elif curr_block == &quot;2back_single_main_no_click&quot;:&amp;#10;            print(&quot;Using RT_per_rectangle_twoback for this block:&quot;, RT_per_rectangle_twoback_single)&amp;#10;&amp;#10;        # light background&amp;#10;        win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;        win.flip()&amp;#10;&amp;#10;        ### Show instructions&amp;#10;        # if it's the first block of this run, wait for the first scanner trigger before moving on&amp;#10;        if exp_block_counter == 2:&amp;#10;&amp;#10;            # set instruction text&amp;#10;            instr_text = locals()[&quot;instr_&quot; + curr_block]&amp;#10;            instr_pic = locals()[&quot;instr_pic_&quot; + curr_block]&amp;#10;&amp;#10;            first_trigger_time, trigger_count = log_trigger(instr_text, instr_pic, trigger_count)&amp;#10;&amp;#10;        else:&amp;#10;            # set instruction text&amp;#10;            instr_text = locals()[&quot;instr_&quot; + curr_block]&amp;#10;            # create text box&amp;#10;            instr_text_stim = visual.TextStim(win,&amp;#10;                                              text=instr_text,&amp;#10;                                              height=0.03,  # font height relative to height of screen&amp;#10;                                              pos=(0, 0.2),  # move up a bit&amp;#10;                                              color=&quot;black&quot;,&amp;#10;                                              wrapWidth=1)&amp;#10;            # instr_text_stim = visual.TextBox2(win,&amp;#10;            #                                   text=instr_text,&amp;#10;            #                                   letterHeight=0.03,  # font height relative to height of screen&amp;#10;            #                                   pos=(0, 0.2),  # move up a bit&amp;#10;            #                                   color=&quot;black&quot;)&amp;#10;            #                                   #wrapwidth = 1.5)&amp;#10;            # create ImageStim object&amp;#10;            curr_instr_pic = visual.ImageStim(win,&amp;#10;                                              size=(0.8, 0.3),&amp;#10;                                              pos=(0, -0.2),&amp;#10;                                              image=locals()[&quot;instr_pic_&quot; + curr_block])  # set path to image here&amp;#10;&amp;#10;            # show instructions on screen&amp;#10;            instr_text_stim.draw()&amp;#10;            curr_instr_pic.draw()&amp;#10;            win.flip()&amp;#10;            core.wait(8.75)  # wait for 3s before starting response window&amp;#10;            # If esc is pressed, end the experiment:&amp;#10;            if 'escape' in event.getKeys():&amp;#10;                et_abort_exp()  # shut down eyetrigger and download incremental data&amp;#10;                # close trigger &amp; close experiment&amp;#10;                core.wait(0.5)&amp;#10;                core.quit()&amp;#10;&amp;#10;        ### change background colour&amp;#10;        win.setColor(dark_bg_col, colorSpace='rgb')&amp;#10;        win.flip()&amp;#10;&amp;#10;        # get n-back condition:&amp;#10;        curr_nback_cond = curr_block[0]  # get first character of block name&amp;#10;&amp;#10;        # if it is a 1 or a 2, set that as current n-back level:&amp;#10;        if curr_nback_cond in ['1', '2']:&amp;#10;            curr_nback_cond == int(curr_nback_cond)&amp;#10;        # if it's neither 1 nor 2, it has to be a block without n-back,&amp;#10;        # so set curr_nback_cond to None&amp;#10;        else:&amp;#10;            curr_nback_cond = None&amp;#10;&amp;#10;        print(f&quot;\tcurrent n-back condition: {curr_nback_cond}&quot;)&amp;#10;&amp;#10;        # get list with targets &amp; list with colours&amp;#10;        curr_targets = run2_target_lists[run2_block_counter]&amp;#10;        curr_colours = run2_colour_lists[run2_block_counter]&amp;#10;&amp;#10;        # determine duration per rectangle for this block&amp;#10;        # we use average time per rectangle as duration here and add an increment over the duration of the block&amp;#10;        if curr_block == &quot;1back_single_main_no_click&quot;:&amp;#10;            curr_durations = []&amp;#10;            for rect in curr_targets:&amp;#10;                curr_durations.append(RT_per_rectangle_oneback_single)&amp;#10;&amp;#10;            # Latency factor of an incremental increase (increment per trial = 3 ms) added over duration of entire&amp;#10;            # block assuming that participants get tired over the course of the block and thus need a bit more time:&amp;#10;            increment_per_trial = 3&amp;#10;            maximum_duration = 1500  # 1.5 seconds for 1back&amp;#10;            for i in range(len(curr_durations)):&amp;#10;                # Calculate incremental increase for current trial&amp;#10;                increment = (i + 1) * increment_per_trial&amp;#10;                # Add incremental increase to current trial's duration&amp;#10;                incremented_duration = curr_durations[i] + increment&amp;#10;                # Ensure the duration does not exceed the maximum duration&amp;#10;                curr_durations[i] = min(incremented_duration, maximum_duration)&amp;#10;&amp;#10;        elif curr_block == &quot;2back_single_main_no_click&quot;:&amp;#10;            curr_durations = []&amp;#10;            for rect in curr_targets:&amp;#10;                curr_durations.append(RT_per_rectangle_twoback_single)&amp;#10;&amp;#10;            # Latency factor of an incremental increase (increment per trial = 3 ms) added over duration of entire&amp;#10;            # block assuming that participants get tired over the course of the block and thus need a bit more time:&amp;#10;            increment_per_trial = 3&amp;#10;            maximum_duration = 2000  # 2 seconds for 2back&amp;#10;            for i in range(len(curr_durations)):&amp;#10;                # Calculate incremental increase for current trial&amp;#10;                increment = (i + 1) * increment_per_trial&amp;#10;                # Add incremental increase to current trial's duration&amp;#10;                incremented_duration = curr_durations[i] + increment&amp;#10;                # Ensure the duration does not exceed the maximum duration&amp;#10;                curr_durations[i] = min(incremented_duration, maximum_duration)&amp;#10;&amp;#10;        ### Start block loop&amp;#10;&amp;#10;        # CREATE CLOCKS:&amp;#10;        my_block_clock = core.Clock()&amp;#10;        my_block_clock.reset()  # start block clock&amp;#10;        start_time = my_block_clock.getTime()  # get start time of block&amp;#10;        # also create trial clock&amp;#10;        my_trial_clock = core.Clock()&amp;#10;&amp;#10;        # create empty stimulus&amp;#10;        stim = visual.Rect(win=win,&amp;#10;                           width=0.4,  # width = 3 * 1° visual angle (to make it look rectangle-ish)&amp;#10;                           height=0.15,  # height = 1° visual angle (just like words)&amp;#10;                           # colorSpace = &quot;hex&quot;,&amp;#10;                           pos=(0, 0))  # center stimulus&amp;#10;&amp;#10;        stim.draw()&amp;#10;        win.flip()&amp;#10;&amp;#10;        # clear buffer of all previously recorded key events:&amp;#10;        event.clearEvents()&amp;#10;        defaultKeyboard.clearEvents()&amp;#10;&amp;#10;        # send block onset trigger&amp;#10;        send_trigger(curr_block + &quot;_onset&quot;)&amp;#10;&amp;#10;        # loop colours in current text&amp;#10;        for trial_idx, curr_col in enumerate(curr_colours):&amp;#10;            # print(&quot;current idx: &quot; + str(trial_idx) + &quot;, curr colour:&quot; + curr_col)&amp;#10;&amp;#10;            ### prepare &amp; show current trial:&amp;#10;            my_trial_clock.reset()  # start trial clock&amp;#10;            onset_time = my_trial_clock.getTime()&amp;#10;&amp;#10;            # if it's a block with an n-back task, prepare target list&amp;#10;            if curr_nback_cond != None:&amp;#10;                curr_target = curr_targets[trial_idx]&amp;#10;                saw_target = False&amp;#10;&amp;#10;            # get duration for current trial&amp;#10;            curr_duration = curr_durations[trial_idx] / 1000  # convert ms to seconds&amp;#10;&amp;#10;            # get trial number (start counting from 1, so add 1)&amp;#10;            curr_trial_nr = trial_idx + 1&amp;#10;&amp;#10;            ### ISI: wait for 200 ms&amp;#10;            while my_trial_clock.getTime() &lt; 0.2:&amp;#10;                win.flip()  # don't draw anything&amp;#10;                core.wait(0.005)  # wait 5 ms before next iteration&amp;#10;&amp;#10;            # set current colour as colour of rectangle&amp;#10;            stim.fillColor = curr_col&amp;#10;&amp;#10;            # draw stimulus on screen&amp;#10;            stim.draw()&amp;#10;            win.flip()&amp;#10;&amp;#10;            # show stimulus on screen &amp; send trigger:&amp;#10;            stim.draw()  # draw stimulus on screen&amp;#10;            # update the window to clear the screen and display&amp;#10;            # the stimulus, send trigger on flip&amp;#10;            win.callOnFlip(send_trigger, &quot;trial_onset&quot;)&amp;#10;&amp;#10;            # start trial clock for measuring RTs from stimulus onset&amp;#10;            my_trial_clock.reset()&amp;#10;            onset_time = my_trial_clock.getTime()&amp;#10;            global_onset_time = globalClock.getTime()&amp;#10;            onset_time_rel2trigger = global_onset_time - first_trigger_time&amp;#10;&amp;#10;            ### start recording responses&amp;#10;            # start &quot;endless&quot; while loop that looks for responses&amp;#10;            # --&gt; end while loop only if duration for current word is over&amp;#10;            while my_trial_clock.getTime() &lt; (onset_time + curr_duration):&amp;#10;&amp;#10;                # draw stimulus on screen&amp;#10;                stim.draw()&amp;#10;                win.flip()&amp;#10;&amp;#10;                # check for responses:&amp;#10;                keys = event.getKeys(['1', 'escape'])&amp;#10;                button_pressed = &quot;NA&quot;&amp;#10;&amp;#10;                # check if there was a response. If there wasn't, we can go straight&amp;#10;                # to the next iteration&amp;#10;                for key in keys:&amp;#10;&amp;#10;                    # if participant pressed button &quot;1&quot; for the first time and it's an n-back condition&amp;#10;                    if key == '1' and curr_nback_cond != None and saw_target == False:&amp;#10;                        # get reaction time&amp;#10;                        curr_nback_RT = my_trial_clock.getTime() * 1000&amp;#10;                        # send trigger for response:&amp;#10;                        send_trigger(&quot;response_target&quot;)&amp;#10;                        # only get first target response, we don't care if they press the button more than once:&amp;#10;                        saw_target = True&amp;#10;&amp;#10;                    # If esc is pressed, end the experiment:&amp;#10;                    elif key == 'escape':&amp;#10;                        et_abort_exp()  # shut down eyetrigger and download incremental data&amp;#10;                        # close trigger &amp; close experiment&amp;#10;                        # core.wait(time_after_trigger)&amp;#10;                        # parallel.setData(0)&amp;#10;                        core.wait(0.5)&amp;#10;                        core.quit()&amp;#10;&amp;#10;            ### end trial&amp;#10;            # print(&quot;end paced rect trial&quot;)&amp;#10;&amp;#10;            # stop display of current word &amp; send trial offset trigger&amp;#10;            win.callOnFlip(send_trigger, &quot;trial_offset&quot;)&amp;#10;&amp;#10;            # check whether response was hit, miss, false alarm or correct rejection&amp;#10;            # they saw a target and there was one: hit&amp;#10;            if curr_nback_cond != None:&amp;#10;                if saw_target and curr_target:&amp;#10;                    curr_nback_response = &quot;hit&quot;&amp;#10;                    button_pressed = key&amp;#10;                # they didn't see a target but there was one: miss&amp;#10;                elif saw_target == False and curr_target:&amp;#10;                    curr_nback_response = &quot;miss&quot;&amp;#10;                    curr_nback_RT = None&amp;#10;                # they didn't see a target and there was none: correct rejection&amp;#10;                elif saw_target == False and curr_target == False:&amp;#10;                    curr_nback_response = &quot;correct rejection&quot;&amp;#10;                    curr_nback_RT = None&amp;#10;                # they saw a target but there was none: false alarm&amp;#10;                elif saw_target and curr_target == False:&amp;#10;                    curr_nback_response = &quot;false alarm&quot;&amp;#10;                    button_pressed = key&amp;#10;            # if it wasn't an n-back task block:&amp;#10;            else:&amp;#10;                curr_target = None&amp;#10;                curr_nback_response = None&amp;#10;                curr_nback_RT = None&amp;#10;&amp;#10;            ### save everything in output csv&amp;#10;            thisExp.addData('colour', curr_col)&amp;#10;            thisExp.addData('global_onset_time', global_onset_time)&amp;#10;            thisExp.addData('onset_time_rel2trigger', onset_time_rel2trigger)&amp;#10;            thisExp.addData('target', curr_target)&amp;#10;            thisExp.addData('button_pressed', button_pressed)&amp;#10;            thisExp.addData('nback_response', curr_nback_response)&amp;#10;            thisExp.addData('nback_RT', curr_nback_RT)  # in ms&amp;#10;            thisExp.addData('duration', curr_duration * 1000)  # in ms&amp;#10;            thisExp.addData('trial_nr', curr_trial_nr)&amp;#10;            thisExp.addData('block_nr_exp', exp_block_counter+1)&amp;#10;            thisExp.addData('run_nr', '2')&amp;#10;            thisExp.addData('block_nr_run', run2_block_counter+1)&amp;#10;            thisExp.addData('block_name', curr_block)&amp;#10;            thisExp.addData('n-back_level', curr_nback_cond)&amp;#10;&amp;#10;            # start a new row in the csv&amp;#10;            thisExp.nextEntry()&amp;#10;&amp;#10;            ### IF TESTING MODE ENABLED: end loop after 4 trials&amp;#10;            if expInfo['testing_mode'] == &quot;yes&quot;:&amp;#10;                if trial_idx == 3:&amp;#10;                    break&amp;#10;&amp;#10;        print(&quot;\t\tfinished presenting trials&quot;)&amp;#10;&amp;#10;        # send block offset trigger&amp;#10;        send_trigger(&quot;block_offset&quot;)&amp;#10;&amp;#10;        # add 1 to the block counter to go load the next block&amp;#10;        exp_block_counter += 1&amp;#10;        run2_block_counter += 1&amp;#10;        print(f&quot;Going to block {exp_block_counter + 1}/10 in the experiment now!&quot;)&amp;#10;        continueRoutine = False&amp;#10;&amp;#10;        # If there are still blocks left, go to next one.&amp;#10;        # If not, end loop here:&amp;#10;        if run2_block_counter == 4:&amp;#10;            print(f&quot;Finished block {run2_block_counter}/4 in run 2, moving on to next run!&quot;)&amp;#10;            loop_run2_single_nback.finished = True" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="blocks_single_nback" valType="code" updates="None" name="name"/>
      </CodeComponent>
    </Routine>
    <Routine name="dual_task_block">
      <CodeComponent name="blocks_dual_task" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="/* Syntax Error: Fix Python code */" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="def setup_instructions_and_stimuli(block_config, curr_instr, curr_instr_pic):&amp;#10;    &quot;&quot;&quot;&amp;#10;    Setup and display instructions and stimuli based on the block configuration.&amp;#10;    &quot;&quot;&quot;&amp;#10;    RT_per_letter = block_config['RT_per_letter']&amp;#10;    print(f&quot;Start preparing block {block_config['name']}&quot;)&amp;#10;    print(f&quot;\tUsing RT_per_letter for this block: {RT_per_letter}&quot;)&amp;#10;&amp;#10;    # set light background&amp;#10;    win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;    win.flip()&amp;#10;&amp;#10;    # set instruction text&amp;#10;    # instr_text = curr_instr&amp;#10;    # instr_pic = curr_instr_pic&amp;#10;    # create text box&amp;#10;    instr_text_stim = visual.TextStim(win,&amp;#10;                                      text=curr_instr,&amp;#10;                                      height=0.03,  # font height relative to height of screen&amp;#10;                                      pos=(0, 0.2),  # move up a bit&amp;#10;                                      color=&quot;black&quot;)&amp;#10;&amp;#10;    # create ImageStim object&amp;#10;    instr_pic = visual.ImageStim(win,&amp;#10;                                 size=(0.85, 0.25),&amp;#10;                                 pos=(0, -0.2),&amp;#10;                                 image=curr_instr_pic)&amp;#10;&amp;#10;    # show instructions on screen&amp;#10;    if 6 &lt;= exp_block_counter &lt;= 9:&amp;#10;        # instr_text = locals()[&quot;instr_&quot; + curr_block]&amp;#10;        # instr_pic = locals()[&quot;instr_pic_&quot; + curr_block]&amp;#10;&amp;#10;        first_trigger_time = log_trigger(curr_instr, curr_instr_pic, trigger_count)&amp;#10;&amp;#10;        return first_trigger_time&amp;#10;    else:&amp;#10;        win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;        instr_text_stim.draw()&amp;#10;        instr_pic.draw()&amp;#10;        win.flip()&amp;#10;        core.wait(8.75)  # wait for 3s before starting&amp;#10;        # If esc is pressed, end the experiment:&amp;#10;        if 'escape' in event.getKeys():&amp;#10;            et_abort_exp()  # shut down eyetrigger and download incremental data&amp;#10;            # close trigger &amp; close experiment&amp;#10;            core.wait(0.5)&amp;#10;            core.quit()&amp;#10;&amp;#10;&amp;#10;def calculate_durations(text, block_config):&amp;#10;    &quot;&quot;&quot;&amp;#10;    Calculate word display durations based on the block configuration.&amp;#10;    &quot;&quot;&quot;&amp;#10;    # compute RTs using participant's average reading speed / letter&amp;#10;    # we define a minimum and a maximum duration for each word&amp;#10;    # the minimum is based on 5 x RT per letter in the respective condition&amp;#10;    # the max duration is based on each condition&amp;#10;    RT_per_letter = block_config['RT_per_letter']&amp;#10;    minimum_duration = 5 * RT_per_letter&amp;#10;&amp;#10;    if block_config['name'][0] == '1':&amp;#10;        maximum_duration = 2000  # 2 seconds&amp;#10;    elif block_config['name'][0] == '2':&amp;#10;        maximum_duration = 2500  # 2.5 seconds&amp;#10;&amp;#10;    curr_durations = []&amp;#10;    for i, word in enumerate(curr_text):&amp;#10;        base_duration = RT_per_letter * math.log(len(word)) + 4 * RT_per_letter&amp;#10;        incremented_duration = base_duration + 3 * (i + 1)  # Increment increases with trial number&amp;#10;        if incremented_duration &lt; maximum_duration:&amp;#10;            curr_durations.append(max(incremented_duration, minimum_duration))&amp;#10;        else:&amp;#10;            curr_durations.append(maximum_duration)&amp;#10;&amp;#10;    return curr_durations&amp;#10;&amp;#10;&amp;#10;def process_block(block_config, curr_text, run_nr, block_nr_run, curr_block, curr_targets, curr_colours, curr_instr,&amp;#10;                  curr_instr_pic):&amp;#10;    &quot;&quot;&quot;&amp;#10;    Process each block based on its configuration.&amp;#10;    &quot;&quot;&quot;&amp;#10;    first_trigger_time, trigger_count = setup_instructions_and_stimuli(block_config, curr_instr, curr_instr_pic)&amp;#10;    curr_durations = calculate_durations(curr_text, block_config)&amp;#10;&amp;#10;    ### change background colour&amp;#10;    win.setColor(dark_bg_col, colorSpace='rgb')&amp;#10;    win.flip()&amp;#10;&amp;#10;    # show main block questions&amp;#10;    skip_questions_paced = False&amp;#10;&amp;#10;    # get n-back condition:&amp;#10;    curr_nback_cond = curr_block[0]  # get first character of block name&amp;#10;&amp;#10;    # if it is a 1 or a 2, set that as current n-back level:&amp;#10;    if curr_nback_cond in ['1', '2']:&amp;#10;        curr_nback_cond == int(curr_nback_cond)&amp;#10;    # if it's neither 1 nor 2, it has to be a block without n-back,&amp;#10;    # so set curr_nback_cond to None&amp;#10;    else:&amp;#10;        curr_nback_cond = None&amp;#10;&amp;#10;    print(f&quot;\tCurrent n-back condition: {curr_nback_cond}&quot;)&amp;#10;    print(f&quot;\tCurrent text: {curr_text_nr}&quot;)&amp;#10;&amp;#10;    # create empty text stimulus&amp;#10;    stim = visual.TextStim(win=win,&amp;#10;                           text=&quot; &quot;,&amp;#10;                           pos=(0, 0),  # center stimulus&amp;#10;                           font=&quot;Times New Roman&quot;,&amp;#10;                           height=0.07)&amp;#10;&amp;#10;    stim.draw()&amp;#10;    win.flip()&amp;#10;&amp;#10;    # clear buffer of all previously recorded key events:&amp;#10;    event.clearEvents()&amp;#10;    defaultKeyboard.clearEvents()&amp;#10;&amp;#10;    # CREATE CLOCKS:&amp;#10;    my_block_clock = core.Clock()&amp;#10;    my_block_clock.reset()  # start block clock&amp;#10;    start_time = my_block_clock.getTime()  # get start time of block&amp;#10;    # also create trial clock&amp;#10;    my_trial_clock = core.Clock()&amp;#10;&amp;#10;    # send block onset trigger&amp;#10;    send_trigger(curr_block + &quot;_onset&quot;)&amp;#10;&amp;#10;    # loop words in current text&amp;#10;    for trial_idx, curr_word in enumerate(curr_text):&amp;#10;        # print(&quot;current idx: &quot; + str(trial_idx) + &quot;, curr word:&quot; + curr_word)&amp;#10;&amp;#10;        ### prepare &amp; show current word:&amp;#10;&amp;#10;        # get current colour&amp;#10;        curr_colour = curr_colours[trial_idx]&amp;#10;&amp;#10;        # if it's a block with an n-back task, prepare target list as well&amp;#10;        if curr_nback_cond != None:&amp;#10;            curr_target = curr_targets[trial_idx]&amp;#10;            saw_target = False&amp;#10;&amp;#10;        # get duration for current word&amp;#10;        curr_duration = curr_durations[trial_idx] / 1000  # convert ms to seconds&amp;#10;        # print(&quot;duration for current word (in s):&quot;, curr_duration)&amp;#10;&amp;#10;        # get trial number (start counting from 1, so add 1)&amp;#10;        curr_trial_nr = trial_idx + 1&amp;#10;&amp;#10;        # set current word &amp; colour as content of text stimulus&amp;#10;        stim.color = curr_colour&amp;#10;        stim.text = curr_word&amp;#10;&amp;#10;        # show word on screen&amp;#10;        stim.draw()  # draw word on screen&amp;#10;        # update the window to clear the screen and display&amp;#10;        # the stimulus, send trigger on flip&amp;#10;        win.callOnFlip(send_trigger, &quot;trial_onset&quot;)&amp;#10;&amp;#10;        # start trial clock &amp; record trial onset time&amp;#10;        my_trial_clock.reset()&amp;#10;        global_onset_time = globalClock.getTime()&amp;#10;        onset_time_rel2trigger = global_onset_time - first_trigger_time&amp;#10;&amp;#10;        ### wait for key response:&amp;#10;        # In blocks with n-back task, participants can press &quot;c&quot; to indicate they saw a target colour.&amp;#10;&amp;#10;        ### start recording responses&amp;#10;        # start while loop that looks for responses&amp;#10;        # --&gt; end while loop only if duration for current word is over&amp;#10;        while my_trial_clock.getTime() &lt; (onset_time + curr_duration):&amp;#10;&amp;#10;            stim.draw()&amp;#10;            win.flip()&amp;#10;&amp;#10;            # check for key responses:&amp;#10;            keys = event.getKeys(['1', 'escape'])&amp;#10;            button_pressed = &quot;NA&quot;&amp;#10;&amp;#10;            # if there were, check responses:&amp;#10;            for key in keys:&amp;#10;&amp;#10;                # if participant pressed button &quot;1&quot; for the first time and it's an n-back condition&amp;#10;                # where they're actually supposed to do that (aka not a reading baseline condition)...&amp;#10;                if key == '1' and curr_nback_cond != None and saw_target == False:&amp;#10;                    # get reaction time&amp;#10;                    curr_nback_RT = my_trial_clock.getTime() * 1000&amp;#10;                    # send trigger for response:&amp;#10;                    send_trigger(&quot;response_target&quot;)&amp;#10;                    # only get first target response, we don't care if they press the button more than once:&amp;#10;                    saw_target = True&amp;#10;&amp;#10;                # If esc is pressed, end the experiment:&amp;#10;                elif key == 'escape':&amp;#10;                    et_abort_exp()  # shut down eyetrigger and download incremental data&amp;#10;                    # close trigger &amp; close experiment&amp;#10;                    # core.wait(time_after_trigger)&amp;#10;                    # parallel.setData(0)&amp;#10;                    core.wait(0.5)&amp;#10;                    core.quit()&amp;#10;&amp;#10;        ### end trial&amp;#10;        # print(&quot;\tend paced trial&quot;)&amp;#10;        # stop display of current word &amp; send trial offset trigger&amp;#10;        win.callOnFlip(send_trigger, &quot;trial_offset&quot;)&amp;#10;&amp;#10;        # check whether response was hit, miss, false alarm or correct rejection&amp;#10;        # they saw a target and there was one: hit&amp;#10;        if curr_nback_cond != None:&amp;#10;            if saw_target and curr_target:&amp;#10;                curr_nback_response = &quot;hit&quot;&amp;#10;                button_pressed = key&amp;#10;            # they didn't see a target but there was one: miss&amp;#10;            elif saw_target == False and curr_target:&amp;#10;                curr_nback_response = &quot;miss&quot;&amp;#10;                curr_nback_RT = None&amp;#10;            # they didn't see a target and there was none: correct rejection&amp;#10;            elif saw_target == False and curr_target == False:&amp;#10;                curr_nback_response = &quot;correct rejection&quot;&amp;#10;                curr_nback_RT = None&amp;#10;            # they saw a target but there was none: false alarm&amp;#10;            elif saw_target and curr_target == False:&amp;#10;                curr_nback_response = &quot;false alarm&quot;&amp;#10;                button_pressed = key&amp;#10;        # if it wasn't an n-back task block:&amp;#10;        else:&amp;#10;            curr_target = None&amp;#10;            curr_nback_response = None&amp;#10;            curr_nback_RT = None&amp;#10;&amp;#10;        ### save everything in output csv&amp;#10;        thisExp.addData('colour', curr_colour)&amp;#10;        thisExp.addData('global_onset_time', global_onset_time)&amp;#10;        thisExp.addData('onset_time_rel2trigger', onset_time_rel2trigger)&amp;#10;        thisExp.addData('target', curr_target)&amp;#10;        thisExp.addData('button_pressed', button_pressed)&amp;#10;        thisExp.addData('nback_response', curr_nback_response)&amp;#10;        thisExp.addData('nback_RT', curr_nback_RT)  # in ms&amp;#10;        thisExp.addData('duration', curr_duration * 1000)  # in ms&amp;#10;        thisExp.addData('text_nr', curr_text_nr)&amp;#10;        thisExp.addData('trial_nr', curr_trial_nr)&amp;#10;        thisExp.addData('block_nr_exp', exp_block_counter + 1)&amp;#10;        thisExp.addData('run_nr', run_nr)&amp;#10;        thisExp.addData('block_nr_run', block_nr_run)&amp;#10;        thisExp.addData('block_name', curr_block)&amp;#10;        thisExp.addData('n-back_level', curr_nback_cond)&amp;#10;        # careful, make sure quotes in the strings are escaped using a&amp;#10;        # quote (weird, I know) so it's properly saved in the CSV:&amp;#10;        thisExp.addData('word', escape_quotes(curr_word))&amp;#10;&amp;#10;        # start a new row in the csv&amp;#10;        thisExp.nextEntry()&amp;#10;&amp;#10;        ### IF TESTING MODE ENABLED: end loop after 4 trials&amp;#10;        if expInfo['testing_mode'] == &quot;yes&quot;:&amp;#10;            if trial_idx == 9:&amp;#10;                break&amp;#10;&amp;#10;    print(&quot;finished presenting trials&quot;)&amp;#10;&amp;#10;    # send block offset trigger&amp;#10;    send_trigger(&quot;block_offset&quot;)&amp;#10;&amp;#10;# Block configurations&amp;#10;block_configs = {&amp;#10;    &quot;1back_dual_main_no_click&quot;: {&amp;#10;        &quot;name&quot;: &quot;1back_dual_main_no_click&quot;,&amp;#10;        &quot;RT_per_letter&quot;: int(expInfo['RT_per_letter_oneback_dual']),&amp;#10;        # Add other block-specific configurations or parameters here&amp;#10;    },&amp;#10;    &quot;2back_dual_main_no_click&quot;: {&amp;#10;        &quot;name&quot;: &quot;2back_dual_main_no_click&quot;,&amp;#10;        &quot;RT_per_letter&quot;: int(expInfo['RT_per_letter_twoback_dual']),&amp;#10;        # Add other block-specific configurations or parameters here&amp;#10;    }&amp;#10;}&amp;#10;&amp;#10;if exp_block_counter == 6:&amp;#10;    run_nr = 3&amp;#10;    block_nr_run = run3_block_counter + 1&amp;#10;    curr_block = run3_blocks&amp;#10;    curr_targets = run3_target_lists&amp;#10;    curr_colours = run3_colour_lists&amp;#10;    block_config = block_configs.get(curr_block)&amp;#10;&amp;#10;    if block_config:&amp;#10;        curr_text_nr = all_texts_nrs_list[exp_block_counter]&amp;#10;        curr_text = locals()[curr_text_nr]  # Assuming this retrieves the text for the current block&amp;#10;        curr_instr = locals()[&quot;instr_&quot; + block_config['name']]&amp;#10;        curr_instr_pic = locals()[&quot;instr_pic_&quot; + block_config['name']]  # set path to image here&amp;#10;&amp;#10;        # show main block questions&amp;#10;        skip_questions_paced = False&amp;#10;        process_block(block_config, curr_text, run_nr, block_nr_run, curr_block, curr_targets, curr_colours, curr_instr,&amp;#10;                      curr_instr_pic)&amp;#10;        # continueRoutine = False&amp;#10;    else:&amp;#10;        print(&quot;Error: Block configuration not found.&quot;)&amp;#10;&amp;#10;elif exp_block_counter == 7:&amp;#10;    run_nr = 4&amp;#10;    block_nr_run = run4_block_counter + 1&amp;#10;    curr_block = run4_blocks&amp;#10;    curr_targets = run4_target_lists&amp;#10;    curr_colours = run4_colour_lists&amp;#10;    block_config = block_configs.get(curr_block)&amp;#10;&amp;#10;    if block_config:&amp;#10;        curr_text_nr = all_texts_nrs_list[exp_block_counter]&amp;#10;        curr_text = locals()[curr_text_nr]  # Assuming this retrieves the text for the current block&amp;#10;        curr_instr = locals()[&quot;instr_&quot; + block_config['name']]&amp;#10;        curr_instr_pic = locals()[&quot;instr_pic_&quot; + block_config['name']]  # set path to image here&amp;#10;&amp;#10;        skip_questions_paced = False&amp;#10;        process_block(block_config, curr_text, run_nr, block_nr_run, curr_block, curr_targets, curr_colours, curr_instr,&amp;#10;                      curr_instr_pic)&amp;#10;        # continueRoutine = False&amp;#10;    else:&amp;#10;        print(&quot;Error: Block configuration not found.&quot;)&amp;#10;&amp;#10;elif exp_block_counter == 8:&amp;#10;    run_nr = 5&amp;#10;    block_nr_run = run5_block_counter + 1&amp;#10;    curr_block = run5_blocks&amp;#10;    curr_targets = run5_target_lists&amp;#10;    curr_colours = run5_colour_lists&amp;#10;    block_config = block_configs.get(curr_block)&amp;#10;&amp;#10;    if block_config:&amp;#10;        curr_text_nr = all_texts_nrs_list[exp_block_counter]&amp;#10;        curr_text = locals()[curr_text_nr]  # Assuming this retrieves the text for the current block&amp;#10;        curr_instr = locals()[&quot;instr_&quot; + block_config['name']]&amp;#10;        curr_instr_pic = locals()[&quot;instr_pic_&quot; + block_config['name']]  # set path to image here&amp;#10;&amp;#10;        skip_questions_paced = False&amp;#10;        process_block(block_config, curr_text, run_nr, block_nr_run, curr_block, curr_targets, curr_colours, curr_instr,&amp;#10;                      curr_instr_pic)&amp;#10;        # continueRoutine = False&amp;#10;    else:&amp;#10;        print(&quot;Error: Block configuration not found.&quot;)&amp;#10;&amp;#10;elif exp_block_counter == 9:&amp;#10;    run_nr = 6&amp;#10;    block_nr_run = run6_block_counter + 1&amp;#10;    curr_block = run6_blocks&amp;#10;    curr_targets = run6_target_lists&amp;#10;    curr_colours = run6_colour_lists&amp;#10;    block_config = block_configs.get(curr_block)&amp;#10;&amp;#10;    if block_config:&amp;#10;        curr_text_nr = all_texts_nrs_list[exp_block_counter]&amp;#10;        curr_text = locals()[curr_text_nr]  # Assuming this retrieves the text for the current block&amp;#10;        curr_instr = locals()[&quot;instr_&quot; + block_config['name']]&amp;#10;        curr_instr_pic = locals()[&quot;instr_pic_&quot; + block_config['name']]  # set path to image here&amp;#10;&amp;#10;        skip_questions_paced = False&amp;#10;        process_block(block_config, curr_text, run_nr, block_nr_run, curr_block, curr_targets, curr_colours, curr_instr,&amp;#10;                      curr_instr_pic)&amp;#10;        # continueRoutine = False&amp;#10;    else:&amp;#10;        print(&quot;Error: Block configuration not found.&quot;)" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="blocks_dual_task" valType="code" updates="None" name="name"/>
      </CodeComponent>
      <CodeComponent name="questions_dual_task" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="##########################################################&amp;#10;#              Text Comprehension Questions              #&amp;#10;##########################################################&amp;#10;&amp;#10;def setup_question(question_text, answers_text):&amp;#10;    question = visual.TextStim(win, text=question_text, pos=(0, 0.2), color=&quot;black&quot;, height=0.03, anchorHoriz='center', alignText='center', wrapWidth=1)&amp;#10;    answers = [visual.TextStim(win, text=ans, pos=(0, 0.1 - i * 0.08), color=&quot;black&quot;, height=0.03, wrapWidth=1, anchorHoriz='center', alignText='center') for i, ans in enumerate(answers_text)]&amp;#10;    return question, answers&amp;#10;&amp;#10;from psychopy import visual, core, event&amp;#10;from psychopy.hardware import keyboard&amp;#10;&amp;#10;def display_question_and_get_response(question, answers, correct_answer):&amp;#10;    defaultKeyboard.clearEvents()&amp;#10;    &amp;#10;    # Set-up time to write into logfile&amp;#10;    question_time = globalClock.getTime()&amp;#10;    onset_time_rel2trigger = question_time - first_trigger_time&amp;#10;&amp;#10;    question.autoDraw = True&amp;#10;    for answer in answers:&amp;#10;        answer.autoDraw = True&amp;#10;    instr_text.autoDraw = True&amp;#10;&amp;#10;    countdown_timer = visual.TextStim(win, text='', pos=(0, -0.25), color=&quot;grey&quot;, height=0.02, anchorHoriz='center', alignText='center', wrapWidth=1)&amp;#10;&amp;#10;    # defaultKeyboard = keyboard.Keyboard()&amp;#10;    chosen_ans = &quot;NA&quot;&amp;#10;    is_correct = &quot;NA&quot;&amp;#10;    button_pressed = &quot;NA&quot;&amp;#10;    response_received = False&amp;#10;&amp;#10;    # Start a clock to track response time&amp;#10;    response_clock = core.Clock()&amp;#10;&amp;#10;    # Countdown from 10 seconds&amp;#10;    while response_clock.getTime() &lt; 10:&amp;#10;        remaining_time = 10 - int(response_clock.getTime())&amp;#10;        countdown_timer.text = f&quot;Zeit: {remaining_time}&quot;&amp;#10;        countdown_timer.draw()&amp;#10;        win.flip()&amp;#10;&amp;#10;        keys = defaultKeyboard.getKeys(['1', '2', '3', '4'], waitRelease=False)&amp;#10;        if keys:&amp;#10;            key_name = keys[0].name  # Get the name of the first key pressed&amp;#10;            button_pressed = key_name&amp;#10;&amp;#10;            # Now, use the key_name to determine the action&amp;#10;            if key_name == '1':&amp;#10;                index = 0  # Corresponds to the first choice&amp;#10;            elif key_name == '2':&amp;#10;                index = 1  # Corresponds to the second choice&amp;#10;            elif key_name == '3':&amp;#10;                index = 2  # Corresponds to the third choice&amp;#10;            elif key_name == '4':&amp;#10;                index = 3  # Corresponds to the fourth choice&amp;#10;            else:&amp;#10;                index = None  # Just in case, not really needed if you're sure about the input keys&amp;#10;&amp;#10;            # Proceed with your logic based on the index&amp;#10;            if index is not None:&amp;#10;                chosen_ans = chr(97 + index)  # Convert index to letter ('a', 'b', 'c', 'd')&amp;#10;                is_correct = chosen_ans == correct_answer  # Assuming correct_answer is defined ('a', 'b', 'c', or 'd')&amp;#10;                for i, answer in enumerate(answers):&amp;#10;                    answer.setColor(&quot;green&quot; if i == index else &quot;black&quot;)&amp;#10;                win.flip()&amp;#10;                core.wait(0.5)  # Ensure the color change is visible&amp;#10;                response_received = True&amp;#10;                break&amp;#10;&amp;#10;    # Hide the countdown timer after it finishes&amp;#10;    countdown_timer.text = ''&amp;#10;    countdown_timer.draw()&amp;#10;    win.flip()&amp;#10;&amp;#10;    # If no response is received within 10 seconds, return &quot;NA&quot;&amp;#10;    if not response_received:&amp;#10;        chosen_ans = &quot;NA&quot;&amp;#10;        is_correct = &quot;NA&quot;&amp;#10;        button_pressed = &quot;NA&quot;&amp;#10;&amp;#10;    return question_time, onset_time_rel2trigger, chosen_ans, is_correct, button_pressed&amp;#10;&amp;#10;def reset_answers(answers):&amp;#10;    for answer in answers:&amp;#10;        answer.setColor(&quot;black&quot;)&amp;#10;    question.autoDraw = False&amp;#10;    instr_text.autoDraw = False&amp;#10;    for answer in answers:&amp;#10;        answer.autoDraw = False&amp;#10;&amp;#10;# Set up instructions&amp;#10;win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;win.flip()&amp;#10;instr_text = visual.TextStim(win, text=&quot;(Bitte benutzen Sie die Tasten 1, 2, 3 und 4, um die richtige Antwort auszuwählen.)&quot;, color=&quot;grey&quot;, pos=(0, -0.3), wrapWidth=2, height=0.018)&amp;#10;event.clearEvents()&amp;#10;&amp;#10;# Assuming skip_questions_paced and other variables are defined&amp;#10;if not skip_questions_paced:&amp;#10;    # Setup for Q1&amp;#10;    Q1_text = locals()[curr_text_nr + &quot;_Q1&quot;]&amp;#10;    Q1_answers = locals()[curr_text_nr + &quot;_Q1_ans&quot;]&amp;#10;    Q1_correct = locals()[curr_text_nr + &quot;_Q1_corr&quot;]&amp;#10;&amp;#10;    question, answers = setup_question(Q1_text, Q1_answers)&amp;#10;    question_time, onset_time_rel2trigger, chosen_ans, is_correct, button_pressed = display_question_and_get_response(question, answers, Q1_correct)&amp;#10;    print(f&quot;Chosen answer for Q1: {chosen_ans}, Correct: {is_correct}&quot;)&amp;#10;    reset_answers(answers)&amp;#10;&amp;#10;    # save data:&amp;#10;    thisExp.addData('global_onset_time', question_time)&amp;#10;    thisExp.addData('onset_time_rel2trigger', onset_time_rel2trigger)&amp;#10;    thisExp.addData('question', 'Q1')&amp;#10;    thisExp.addData('button_pressed', button_pressed)&amp;#10;    thisExp.addData('chosen_ans', chosen_ans)&amp;#10;    thisExp.addData('ans_correct', chosen_ans == Q1_correct)&amp;#10;    thisExp.addData('text_nr', curr_text_nr)&amp;#10;    thisExp.addData('block_nr_exp', exp_block_counter+1)&amp;#10;    thisExp.addData('run_nr', '1')&amp;#10;    thisExp.addData('block_nr_run', run1_block_counter+1)&amp;#10;    thisExp.addData('block_name', curr_block)&amp;#10;    thisExp.addData('n-back_level', curr_nback_cond)&amp;#10;&amp;#10;    # start a new row in the csv&amp;#10;    thisExp.nextEntry()&amp;#10;&amp;#10;    # Setup for Q2&amp;#10;    Q2_text = locals()[curr_text_nr + &quot;_Q2&quot;]&amp;#10;    Q2_answers = locals()[curr_text_nr + &quot;_Q2_ans&quot;]&amp;#10;    Q2_correct = locals()[curr_text_nr + &quot;_Q2_corr&quot;]&amp;#10;&amp;#10;    question, answers = setup_question(Q2_text, Q2_answers)&amp;#10;    question_time, onset_time_rel2trigger, chosen_ans, is_correct, button_pressed = display_question_and_get_response(question, answers, Q2_correct)&amp;#10;    print(f&quot;Chosen answer for Q2: {chosen_ans}, Correct: {is_correct}&quot;)&amp;#10;    reset_answers(answers)&amp;#10;&amp;#10;    # save data:&amp;#10;    thisExp.addData('global_onset_time', question_time)&amp;#10;    thisExp.addData('onset_time_rel2trigger', onset_time_rel2trigger)&amp;#10;    thisExp.addData('question', 'Q2')&amp;#10;    thisExp.addData('button_pressed', button_pressed)&amp;#10;    thisExp.addData('chosen_ans', chosen_ans)&amp;#10;    thisExp.addData('ans_correct', chosen_ans == Q2_correct)&amp;#10;    thisExp.addData('text_nr', curr_text_nr)&amp;#10;    thisExp.addData('block_nr_exp', exp_block_counter+1)&amp;#10;    thisExp.addData('run_nr', &quot;1&quot;)&amp;#10;    thisExp.addData('block_nr_run', run1_block_counter+1)&amp;#10;    thisExp.addData('block_name', curr_block)&amp;#10;    thisExp.addData('n-back_level', curr_nback_cond)&amp;#10;&amp;#10;    # start a new row in the csv&amp;#10;    thisExp.nextEntry()&amp;#10;&amp;#10;    # Setup for Q3&amp;#10;    Q3_text = locals()[curr_text_nr + &quot;_Q3&quot;]&amp;#10;    Q3_answers = locals()[curr_text_nr + &quot;_Q3_ans&quot;]&amp;#10;    Q3_correct = locals()[curr_text_nr + &quot;_Q3_corr&quot;]&amp;#10;&amp;#10;    question, answers = setup_question(Q3_text, Q3_answers)&amp;#10;    question_time, onset_time_rel2trigger, chosen_ans, is_correct, button_pressed = display_question_and_get_response(question, answers, Q3_correct)&amp;#10;    print(f&quot;Chosen answer for Q3: {chosen_ans}, Correct: {is_correct}&quot;)&amp;#10;    reset_answers(answers)&amp;#10;&amp;#10;    # save data:&amp;#10;    thisExp.addData('global_onset_time', question_time)&amp;#10;    thisExp.addData('onset_time_rel2trigger', onset_time_rel2trigger)&amp;#10;    thisExp.addData('question', 'Q3')&amp;#10;    thisExp.addData('button_pressed', button_pressed)&amp;#10;    thisExp.addData('chosen_ans', chosen_ans)&amp;#10;    thisExp.addData('ans_correct', chosen_ans == Q3_correct)&amp;#10;    thisExp.addData('text_nr', curr_text_nr)&amp;#10;    thisExp.addData('block_nr_exp', exp_block_counter+1)&amp;#10;    thisExp.addData('run_nr', &quot;1&quot;)&amp;#10;    thisExp.addData('block_nr_run', run1_block_counter+1)&amp;#10;    thisExp.addData('block_name', curr_block)&amp;#10;    thisExp.addData('n-back_level', curr_nback_cond)&amp;#10;    &amp;#10;    # start a new row in the csv&amp;#10;    thisExp.nextEntry()&amp;#10;&amp;#10;    exp_block_counter += 1&amp;#10;    # run3_block_counter += 1&amp;#10;    print(f&quot;Going to block {exp_block_counter + 1}/10 in the experiment now!&quot;)&amp;#10;    continueRoutine = False&amp;#10;&amp;#10;    print(f&quot;Finished this dual task run, moving on to next run!&quot;)&amp;#10;    # loop_dual_task_blocks.finished = True&amp;#10;&amp;#10;    # keep background ivory&amp;#10;    win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;    win.flip()&amp;#10;&amp;#10;    # Show run finished screen in between runs&amp;#10;    if 6 &lt;= exp_block_counter &lt;= 9:&amp;#10;        run_finished_text = &quot;Diese Runde des Experiments ist nun zu Ende. Bitte bleiben Sie ruhig liegen, es geht gleich weiter.&quot;&amp;#10;        # set text&amp;#10;        instr_text = run_finished_text&amp;#10;        # create text box&amp;#10;        instr_text_stim = visual.TextStim(win,&amp;#10;                                          text=instr_text,&amp;#10;                                          height=0.05,&amp;#10;                                          pos=(0, 0),&amp;#10;                                          color=&quot;black&quot;)&amp;#10;&amp;#10;        # display the text on screen until Return is pressed&amp;#10;        while True:&amp;#10;            # keep background ivory&amp;#10;            win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;            instr_text_stim.draw()&amp;#10;            win.flip()&amp;#10;            # end screen if participant presses space&amp;#10;            if 'return' in event.getKeys():&amp;#10;                print(&quot;moving on to next run!&quot;)&amp;#10;                break&amp;#10;            # If esc is pressed, end the experiment:&amp;#10;            elif 'escape' in event.getKeys():&amp;#10;                et_abort_exp()  # shut down eyetrigger and download incremental data&amp;#10;                # close trigger &amp; close experiment&amp;#10;                core.wait(0.5)&amp;#10;                core.quit()&amp;#10;                break&amp;#10;&amp;#10;    # If there are still blocks left, go to next one.&amp;#10;    # If not, end loop here:&amp;#10;    elif exp_block_counter == 10:&amp;#10;        print(f&quot;Finished run 4, finishing experiment!&quot;)&amp;#10;        loop_dual_task_blocks.finished = True" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="questions_dual_task" valType="code" updates="None" name="name"/>
      </CodeComponent>
    </Routine>
    <Routine name="end">
      <CodeComponent name="end_2" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="var _pj;&amp;#10;function _pj_snippets(container) {&amp;#10;    function in_es6(left, right) {&amp;#10;        if (((right instanceof Array) || ((typeof right) === &quot;string&quot;))) {&amp;#10;            return (right.indexOf(left) &gt; (- 1));&amp;#10;        } else {&amp;#10;            if (((right instanceof Map) || (right instanceof Set) || (right instanceof WeakMap) || (right instanceof WeakSet))) {&amp;#10;                return right.has(left);&amp;#10;            } else {&amp;#10;                return (left in right);&amp;#10;            }&amp;#10;        }&amp;#10;    }&amp;#10;    container[&quot;in_es6&quot;] = in_es6;&amp;#10;    return container;&amp;#10;}&amp;#10;_pj = {};&amp;#10;_pj_snippets(_pj);&amp;#10;psychoJS.window.setColor(light_bg_col, {&quot;colorSpace&quot;: &quot;rgb&quot;});&amp;#10;psychoJS.window.flip();&amp;#10;instr_text = &quot;Hervorragend!\n\n\nVielen Dank,\ndas Experiment ist nun zu Ende!&quot;;&amp;#10;instr_text_stim = new visual.TextStim(psychoJS.window, {&quot;text&quot;: instr_text, &quot;height&quot;: 0.05, &quot;pos&quot;: [0, 0], &quot;color&quot;: &quot;black&quot;});&amp;#10;while (true) {&amp;#10;    psychoJS.window.setColor(light_bg_col, {&quot;colorSpace&quot;: &quot;rgb&quot;});&amp;#10;    instr_text_stim.draw();&amp;#10;    psychoJS.window.flip();&amp;#10;    if (_pj.in_es6(&quot;return&quot;, psychoJS.eventManager.getKeys())) {&amp;#10;        console.log(&quot;ending experiment now!&quot;);&amp;#10;        break;&amp;#10;    }&amp;#10;}&amp;#10;" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="### END OF EXPERIMENT:&amp;#10;# keep background ivory&amp;#10;win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;win.flip()&amp;#10;&amp;#10;### Show message&amp;#10;# set text&amp;#10;instr_text = &quot;Hervorragend!\n\n\nVielen Dank,\ndas Experiment ist nun zu Ende!&quot;&amp;#10;&amp;#10;# create text box&amp;#10;instr_text_stim = visual.TextStim(win,&amp;#10;                                  text = instr_text,&amp;#10;                                  height = 0.05,&amp;#10;                                  pos = (0, 0),&amp;#10;                                  color = &quot;black&quot;)&amp;#10;&amp;#10;# display the text on screen until Space is pressed&amp;#10;while True:&amp;#10;    # keep background ivory&amp;#10;    win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;    instr_text_stim.draw()&amp;#10;    win.flip()&amp;#10;    # end screen if participant presses space&amp;#10;    if 'return' in event.getKeys():&amp;#10;        et_abort_exp()  # shut down eyetrigger and download incremental data&amp;#10;        core.wait(0.5)&amp;#10;        # send trigger&amp;#10;        send_trigger(&quot;end_experiment&quot;)&amp;#10;        print(&quot;ending experiment now!&quot;)&amp;#10;        # end experiment&amp;#10;        break" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="end_2" valType="code" updates="None" name="name"/>
      </CodeComponent>
    </Routine>
    <Routine name="eyetr_calibr">
      <CodeComponent name="calib_setup" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="instr_calibr = new visual.TextStim({&quot;win&quot;: psychoJS.window, &quot;text&quot;: &quot;Eyetracker-Kalibrierung. Zum Starten bitte die Leertaste und dann Enter dr\u00fccken!&quot;, &quot;pos&quot;: [0, 0], &quot;color&quot;: &quot;black&quot;, &quot;height&quot;: 0.5, &quot;wrapWidth&quot;: 1600});&amp;#10;while (true) {&amp;#10;    instr_calibr.draw();&amp;#10;    psychoJS.window.flip();&amp;#10;    if (psychoJS.eventManager.getKeys([&quot;space&quot;])) {&amp;#10;        break;&amp;#10;    }&amp;#10;}&amp;#10;psychoJS.window.flip();&amp;#10;genv = new EyeLinkCoreGraphicsPsychoPy(el_tracker, psychoJS.window);&amp;#10;console.log((&quot;version number of EyelinkCoreGraphics library:&quot; + genv.toString()));&amp;#10;foreground_color = [(- 1), (- 1), (- 1)];&amp;#10;background_color = tuple(psychoJS.window.color);&amp;#10;genv.setCalibrationColors(foreground_color, background_color);&amp;#10;genv.setTargetSize(24);&amp;#10;genv.setCalibrationSounds(&quot;&quot;, &quot;&quot;, &quot;&quot;);&amp;#10;pylink.openGraphicsEx(genv);&amp;#10;el_tracker.doTrackerSetup();&amp;#10;el_tracker.startRecording(1, 1, 1, 1);&amp;#10;pylink.pumpDelay(500);&amp;#10;" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="### Calibration/Validation Setup&amp;#10;&amp;#10;# show instruction for starting Calibration / Validation:&amp;#10;instr_calibr = visual.TextStim(win = win, text = &quot;Eyetracker-Kalibrierung. Zum Starten bitte die Leertaste und dann Enter drücken!&quot;, pos = (0,0), color = &quot;black&quot;, height = 0.05, wrapWidth = 1)&amp;#10;while True:&amp;#10;    instr_calibr.draw()&amp;#10;    win.flip()&amp;#10;    if event.getKeys(['space']):&amp;#10;        break&amp;#10;win.flip() # clear screen&amp;#10;&amp;#10;### Configure Graphics ENVironment (= genv) for the tracker calibration:&amp;#10;genv = EyeLinkCoreGraphicsPsychoPy(el_tracker, win)&amp;#10;print(&quot;version number of EyelinkCoreGraphics library:&quot; + str(genv))&amp;#10;&amp;#10;# set colours for the calibratio target&amp;#10;foreground_color = (-1, -1, -1) # black&amp;#10;background_color = tuple(win.color)&amp;#10;genv.setCalibrationColors(foreground_color, background_color)&amp;#10;&amp;#10;# set up the calibration target&amp;#10;&amp;#10;# The target could be: &quot;circle&quot; (default), &quot;picture&quot;, &quot;movie&quot; clip, or a rotating &quot;spiral&quot;&amp;#10;# To change the type of calibration target, set TargetType like so:&amp;#10;# genv.setTargetType(&quot;picture&quot;)&amp;#10;# genv.setPictureTarget(os.path.join(&quot;images&quot;, &quot;fixTarget.bmp&quot;))&amp;#10;&amp;#10;# We use the default circle here.&amp;#10;&amp;#10;# Configure the size of the target in pixels:&amp;#10;# (this is only possible for &quot;circle&quot; and &quot;spiral&quot;)&amp;#10;genv.setTargetSize(24)&amp;#10;&amp;#10;# request pylink to use the PsychoPy window genv we created above for calibration:&amp;#10;pylink.openGraphicsEx(genv)&amp;#10;&amp;#10;# --&gt; Remember we set el_tracker.setOfflineMode()?&amp;#10;#     We didn't set it back to online mode, but the tracker&amp;#10;#     should now switch to online mode automatically as we start the recording.&amp;#10;&amp;#10;### Calibrate the Tracker:&amp;#10;el_tracker.doTrackerSetup()&amp;#10;# This will open a window where the calibration is run.&amp;#10;# After the calibration you'll be asked to run the validation.&amp;#10;&amp;#10;### Start Recording&amp;#10;el_tracker.startRecording(1, # sample_to_file = yes&amp;#10;                          1, # events_to_file = yes&amp;#10;                          1, # sample_over_link = yes&amp;#10;                          1) # event_over_link = yes&amp;#10;&amp;#10;# wait for 500 ms before starting experiment:&amp;#10;pylink.pumpDelay(500)" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="calib_setup" valType="code" updates="None" name="name"/>
      </CodeComponent>
    </Routine>
    <Routine name="triggers">
      <CodeComponent name="set_triggers" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="### Prepare triggers&amp;#10;&amp;#10;time_after_trigger = 0.003  # wait for 3ms after a trigger before clearing the line with the 0 trigger&amp;#10;&amp;#10;### List of Trigger Values&amp;#10;trigger_map = {&amp;#10;    'block_onset': 2,&amp;#10;    'response_target': 4,&amp;#10;    #'response_continue': 6,&amp;#10;    'trial_onset': 8,&amp;#10;    #'click_training_onset': 10,&amp;#10;    'Reading_pseudotext_no_click_onset': 12,&amp;#10;    'Reading_Baseline_main_no_click_onset': 14,&amp;#10;    #'1back_single_training1_onset': 16,&amp;#10;    #'1back_single_training2_onset': 18,&amp;#10;    '1back_single_main_no_click_onset': 20,&amp;#10;    '1back_dual_main_no_click_onset': 22,&amp;#10;    #'2back_single_training1_onset': 24,&amp;#10;    #'2back_single_training2_onset': 26,&amp;#10;    '2back_single_main_no_click_onset': 28,&amp;#10;    '2back_dual_main_no_click_onset': 30,&amp;#10;    #'prediction_tendency_task_onset': 32,&amp;#10;    #'visual_task_main_onset': 34,&amp;#10;    #'visual_task_training_onset': 36,&amp;#10;    'block_offset': 38,&amp;#10;    #'freq_440_onset': 40,&amp;#10;    #'freq_440_offset': 42,&amp;#10;    #'freq_587_onset': 44,&amp;#10;    #'freq_587_offset': 46,&amp;#10;    #'freq_782_onset': 48,&amp;#10;    #'freq_782_offset': 50,&amp;#10;    #'freq_1043_onset': 52,&amp;#10;    #'freq_1043_offset': 54,&amp;#10;    #'ordered_onset': 56,&amp;#10;    #'random_onset': 58,&amp;#10;    'start_experiment': 60,&amp;#10;    'end_experiment': 62,&amp;#10;    'trial_offset': 64,&amp;#10;    'eyetracking_baseline': 66,&amp;#10;    'test_trigger': 68&amp;#10;}&amp;#10;&amp;#10;# Function to send trigger value by specifying event name&amp;#10;def send_trigger(event_name):&amp;#10;    # get corresponding trigger value:&amp;#10;    trigger_value = trigger_map[event_name]&amp;#10;&amp;#10;    # send trigger to Eyetracker:&amp;#10;    el_tracker.sendMessage(event_name)&amp;#10;&amp;#10;send_trigger(event_name='start_experiment')" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="set_triggers" valType="code" updates="None" name="name"/>
      </CodeComponent>
      <CodeComponent name="test_triggers" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="if ((expInfo[&quot;test_triggers&quot;] === &quot;yes&quot;)) {&amp;#10;    psychoJS.window.setColor(dark_bg_col, {&quot;colorSpace&quot;: &quot;rgb&quot;});&amp;#10;    psychoJS.window.flip();&amp;#10;    stim = new visual.Rect({&quot;win&quot;: psychoJS.window, &quot;width&quot;: 6, &quot;height&quot;: 6, &quot;pos&quot;: [0, 0]});&amp;#10;    stim.fillColor = &quot;#FFFFFF&quot;;&amp;#10;    my_trial_clock = new core.Clock();&amp;#10;    for (var test_trial, _pj_c = 0, _pj_a = util.range(1, 21), _pj_b = _pj_a.length; (_pj_c &lt; _pj_b); _pj_c += 1) {&amp;#10;        test_trial = _pj_a[_pj_c];&amp;#10;        console.log(&quot;sound &amp; light flash test - trial&quot;, test_trial, &quot;/ 20&quot;);&amp;#10;        stim.draw();&amp;#10;        psychoJS.window.flip();&amp;#10;        my_trial_clock.reset();&amp;#10;        parallel.setData(68);&amp;#10;        el_tracker.sendMessage(&quot;test_trigger&quot;.toString());&amp;#10;        core.wait(0.003);&amp;#10;        parallel.setData(0);&amp;#10;        while ((my_trial_clock.getTime() &lt; 0.1)) {&amp;#10;            stim.draw();&amp;#10;            psychoJS.window.flip();&amp;#10;        }&amp;#10;        psychoJS.window.flip();&amp;#10;        core.wait(3);&amp;#10;    }&amp;#10;    psychoJS.window.setColor(light_bg_col, {&quot;colorSpace&quot;: &quot;rgb&quot;});&amp;#10;    psychoJS.window.flip();&amp;#10;}&amp;#10;continueRoutine = false;&amp;#10;" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="# This is just for checking if the triggers we send &amp;#10;# are in the correct spot in the data &amp;#10;# (we can only check this roughly, but if there's a &amp;#10;# trigger and we don't see any neural or pupil response #&amp;#10;# afterwards, there's definitely something off)&amp;#10;&amp;#10;# Send 50 light flashes with 3 s in between&amp;#10;&amp;#10;&amp;#10;if expInfo[&quot;test_triggers&quot;] == &quot;yes&quot;: # check if we're in testing mode&amp;#10;    # turn bg dark:&amp;#10;    win.setColor(dark_bg_col, colorSpace='rgb')&amp;#10;    win.flip()&amp;#10;    &amp;#10;    # create empty stimulus &amp;#10;    stim = visual.Rect(win = win,&amp;#10;                 width = 6, # width = 6 * 6° visual angle&amp;#10;                 height = 6, # height = 6° visual angle&amp;#10;                 # colorSpace = &quot;hex&quot;,&amp;#10;                 pos = (0,0)) # center stimulus &amp;#10;    stim.fillColor = &quot;#FFFFFF&quot; # make stimulus white&amp;#10;    &amp;#10;    my_trial_clock = core.Clock() # create trial clock&amp;#10;    &amp;#10;    # do this 20x&amp;#10;    for test_trial in range(1, 21): &amp;#10;        print(&quot;sound &amp; light flash test - trial&quot;, test_trial, &quot;/ 20&quot;)&amp;#10;        &amp;#10;        stim.draw()&amp;#10;        win.flip()&amp;#10;        my_trial_clock.reset() # start trial clock&amp;#10;        &amp;#10;        # send EEG trigger:&amp;#10;        # parallel.setData(68)&amp;#10;&amp;#10;        # send Eyetracker trigger:&amp;#10;        el_tracker.sendMessage(str(&quot;test_trigger&quot;))&amp;#10;        &amp;#10;        # turn off EEG trigger&amp;#10;        # core.wait(0.003)&amp;#10;        # parallel.setData(0)&amp;#10;        &amp;#10;        while my_trial_clock.getTime() &lt; 0.1:&amp;#10;            stim.draw()&amp;#10;            win.flip()&amp;#10;        &amp;#10;        win.flip() # clear screen &amp;#10;        core.wait(3) # wait for 3 s before starting next trial&amp;#10;        &amp;#10;    # turn bg colour light again&amp;#10;    win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;    win.flip()&amp;#10;    &amp;#10;continueRoutine = False # end routine" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="True" valType="bool" updates="None" name="disabled"/>
        <Param val="test_triggers" valType="code" updates="None" name="name"/>
      </CodeComponent>
    </Routine>
    <EyetrackerValidationRoutine name="validation">
      <Param name="borderColor" updates="None" val="black" valType="color"/>
      <Param name="borderWidth" updates="None" val="2" valType="num"/>
      <Param name="colorSpace" updates="None" val="rgb" valType="str"/>
      <Param name="cursorFillColor" updates="None" val="green" valType="color"/>
      <Param name="disabled" updates="None" val="False" valType="bool"/>
      <Param name="expandDur" updates="None" val="1" valType="num"/>
      <Param name="expandScale" updates="None" val="1.5" valType="num"/>
      <Param name="fillColor" updates="None" val="" valType="color"/>
      <Param name="innerBorderColor" updates="None" val="black" valType="color"/>
      <Param name="innerBorderWidth" updates="None" val="2" valType="num"/>
      <Param name="innerFillColor" updates="None" val="green" valType="color"/>
      <Param name="innerRadius" updates="None" val="0.0035" valType="num"/>
      <Param name="movementAnimation" updates="None" val="True" valType="bool"/>
      <Param name="movementDur" updates="None" val="1.0" valType="num"/>
      <Param name="name" updates="None" val="validation" valType="code"/>
      <Param name="outerRadius" updates="None" val="0.01" valType="num"/>
      <Param name="progressMode" updates="None" val="time" valType="str"/>
      <Param name="randomisePos" updates="None" val="True" valType="bool"/>
      <Param name="saveAsImg" updates="None" val="False" valType="bool"/>
      <Param name="showResults" updates="None" val="True" valType="bool"/>
      <Param name="targetDelay" updates="None" val="1.0" valType="num"/>
      <Param name="targetDur" updates="None" val="1.5" valType="num"/>
      <Param name="targetLayout" updates="None" val="NINE_POINTS" valType="str"/>
      <Param name="targetPositions" updates="None" val="NINE_POINTS" valType="list"/>
      <Param name="textColor" updates="None" val="auto" valType="color"/>
      <Param name="units" updates="None" val="from exp settings" valType="str"/>
    </EyetrackerValidationRoutine>
    <Routine name="pupil_measurement">
      <CodeComponent name="pupil_measure" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="start_block_instr = new visual.TextStim({&quot;win&quot;: psychoJS.window, &quot;text&quot;: &quot;Der Block startet in 10 Sekunden. Bitte schauen Sie solange auf das Fixationskreuz.&quot;, &quot;pos&quot;: [0, 0], &quot;color&quot;: &quot;white&quot;, &quot;height&quot;: 0.5, &quot;wrapWidth&quot;: 1600});&amp;#10;my_block_clock = new core.Clock();&amp;#10;my_block_clock.reset();&amp;#10;while ((my_block_clock.getTime() &lt; 3)) {&amp;#10;    start_block_instr.draw();&amp;#10;    psychoJS.window.flip();&amp;#10;    if (psychoJS.eventManager.getKeys([&quot;space&quot;])) {&amp;#10;        break;&amp;#10;    }&amp;#10;}&amp;#10;psychoJS.window.flip();&amp;#10;fix_cross = new visual.TextStim({&quot;win&quot;: psychoJS.window, &quot;text&quot;: &quot;+&quot;, &quot;pos&quot;: [0, 0], &quot;color&quot;: &quot;black&quot;, &quot;height&quot;: 1, &quot;wrapWidth&quot;: 1600});&amp;#10;my_block_clock.reset();&amp;#10;while ((my_block_clock.getTime() &lt; 10)) {&amp;#10;    fix_cross.draw();&amp;#10;    psychoJS.window.flip();&amp;#10;    if (psychoJS.eventManager.getKeys([&quot;escape&quot;])) {&amp;#10;        break;&amp;#10;    }&amp;#10;}&amp;#10;psychoJS.window.flip();&amp;#10;" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="### PUPIL SIZE BASELINE MEASUREMENT BLOCK&amp;#10;print(f&quot;trigger count: {trigger_count}&quot;)&amp;#10;start_block_instr = visual.TextStim(win=win,&amp;#10;                                    text=&quot;Das Experiment startet in 10 Sekunden. Bitte schauen Sie solange auf das Fixationskreuz.&quot;,&amp;#10;                                    pos=(0, 0),&amp;#10;                                    color=&quot;black&quot;,&amp;#10;                                    height=0.03,&amp;#10;                                    wrapWidth=1)&amp;#10;# CREATE CLOCK:&amp;#10;my_block_clock = core.Clock()&amp;#10;my_block_clock.reset()  # start block clock&amp;#10;&amp;#10;while my_block_clock.getTime() &lt; 3:&amp;#10;    start_block_instr.draw()&amp;#10;    win.flip()&amp;#10;    if event.getKeys(['space']):&amp;#10;        break&amp;#10;win.flip()&amp;#10;&amp;#10;# show fixation cross for 10 seconds&amp;#10;fix_cross = visual.TextStim(win=win,&amp;#10;                            text=&quot;+&quot;,&amp;#10;                            pos=(0, 0),&amp;#10;                            color=&quot;black&quot;,&amp;#10;                            height=0.2,&amp;#10;                            wrapWidth=1)&amp;#10;&amp;#10;my_block_clock.reset()  # start block clock&amp;#10;&amp;#10;while my_block_clock.getTime() &lt; 10:&amp;#10;    fix_cross.draw()&amp;#10;    win.flip()&amp;#10;    if event.getKeys(['escape']):&amp;#10;        break&amp;#10;win.flip()  # clear screen again" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="pupil_measure" valType="code" updates="None" name="name"/>
      </CodeComponent>
    </Routine>
  </Routines>
  <Flow>
    <Routine name="settings"/>
    <Routine name="eyetr_calibr"/>
    <Routine name="triggers"/>
    <Routine name="pupil_measurement"/>
    <Routine name="wait_for_scanner"/>
    <LoopInitiator loopType="TrialHandler" name="loop_run1_single_reading">
      <Param name="Selected rows" updates="None" val="" valType="str"/>
      <Param name="conditions" updates="None" val="None" valType="str"/>
      <Param name="conditionsFile" updates="None" val="" valType="file"/>
      <Param name="endPoints" updates="None" val="[0, 1]" valType="num"/>
      <Param name="isTrials" updates="None" val="True" valType="bool"/>
      <Param name="loopType" updates="None" val="sequential" valType="str"/>
      <Param name="nReps" updates="None" val="5" valType="num"/>
      <Param name="name" updates="None" val="loop_run1_single_reading" valType="code"/>
      <Param name="random seed" updates="None" val="" valType="code"/>
    </LoopInitiator>
    <Routine name="single_reading"/>
    <LoopTerminator name="loop_run1_single_reading"/>
    <Routine name="run_finished"/>
    <LoopInitiator loopType="TrialHandler" name="loop_run2_single_nback">
      <Param name="Selected rows" updates="None" val="" valType="str"/>
      <Param name="conditions" updates="None" val="None" valType="str"/>
      <Param name="conditionsFile" updates="None" val="" valType="file"/>
      <Param name="endPoints" updates="None" val="[0, 1]" valType="num"/>
      <Param name="isTrials" updates="None" val="True" valType="bool"/>
      <Param name="loopType" updates="None" val="sequential" valType="str"/>
      <Param name="nReps" updates="None" val="5" valType="num"/>
      <Param name="name" updates="None" val="loop_run2_single_nback" valType="code"/>
      <Param name="random seed" updates="None" val="" valType="code"/>
    </LoopInitiator>
    <Routine name="single_nback"/>
    <LoopTerminator name="loop_run2_single_nback"/>
    <Routine name="run_finished"/>
    <LoopInitiator loopType="TrialHandler" name="loop_dual_task_blocks">
      <Param name="Selected rows" updates="None" val="" valType="str"/>
      <Param name="conditions" updates="None" val="None" valType="str"/>
      <Param name="conditionsFile" updates="None" val="" valType="file"/>
      <Param name="endPoints" updates="None" val="[0, 1]" valType="num"/>
      <Param name="isTrials" updates="None" val="True" valType="bool"/>
      <Param name="loopType" updates="None" val="sequential" valType="str"/>
      <Param name="nReps" updates="None" val="8" valType="num"/>
      <Param name="name" updates="None" val="loop_dual_task_blocks" valType="code"/>
      <Param name="random seed" updates="None" val="" valType="code"/>
    </LoopInitiator>
    <Routine name="dual_task_block"/>
    <LoopTerminator name="loop_dual_task_blocks"/>
    <Routine name="end"/>
  </Flow>
</PsychoPy2experiment>
