<?xml version="1.0" ?>
<PsychoPy2experiment encoding="utf-8" version="2024.1.1">
  <Settings>
    <Param val="3" valType="str" updates="None" name="Audio latency priority"/>
    <Param val="ptb" valType="str" updates="None" name="Audio lib"/>
    <Param val="" valType="str" updates="None" name="Completed URL"/>
    <Param val="tab" valType="str" updates="None" name="Data file delimiter"/>
    <Param val="u'Analysis/Data_EXNAT_3_training/%s_%s_%s' % (expInfo['participant'], expName, expInfo['date'])" valType="code" updates="None" name="Data filename"/>
    <Param val="True" valType="bool" updates="None" name="Enable Escape"/>
    <Param val="" valType="str" updates="None" name="End Message"/>
    <Param val="{'participant': '', 'testing_mode': 'yes'}" valType="code" updates="None" name="Experiment info"/>
    <Param val="True" valType="bool" updates="None" name="Force stereo"/>
    <Param val="True" valType="bool" updates="None" name="Full-screen window"/>
    <Param val="" valType="str" updates="None" name="HTML path"/>
    <Param val="" valType="str" updates="None" name="Incomplete URL"/>
    <Param val="testMonitor" valType="str" updates="None" name="Monitor"/>
    <Param val="[]" valType="list" updates="None" name="Resources"/>
    <Param val="False" valType="bool" updates="None" name="Save csv file"/>
    <Param val="False" valType="bool" updates="None" name="Save excel file"/>
    <Param val="False" valType="bool" updates="None" name="Save hdf5 file"/>
    <Param val="True" valType="bool" updates="None" name="Save log file"/>
    <Param val="True" valType="bool" updates="None" name="Save psydat file"/>
    <Param val="True" valType="bool" updates="None" name="Save wide csv file"/>
    <Param val="1" valType="num" updates="None" name="Screen"/>
    <Param val="True" valType="bool" updates="None" name="Show info dlg"/>
    <Param val="False" valType="bool" updates="None" name="Show mouse"/>
    <Param val="height" valType="str" updates="None" name="Units"/>
    <Param val="2024.1.0" valType="str" updates="None" name="Use version"/>
    <Param val="[1470, 956]" valType="list" updates="None" name="Window size (pixels)"/>
    <Param val="none" valType="str" updates="None" name="backgroundFit"/>
    <Param val="" valType="str" updates="None" name="backgroundImg"/>
    <Param val="avg" valType="str" updates="None" name="blendMode"/>
    <Param val="float" valType="str" updates="None" name="clockFormat"/>
    <Param val="{'thisRow.t': 'priority.CRITICAL', 'expName': 'priority.LOW'}" valType="dict" updates="None" name="colPriority"/>
    <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
    <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
    <Param val="100.1.1.1" valType="str" updates="None" name="elAddress"/>
    <Param val="FILTER_LEVEL_2" valType="str" updates="None" name="elDataFiltering"/>
    <Param val="FILTER_LEVEL_OFF" valType="str" updates="None" name="elLiveFiltering"/>
    <Param val="EYELINK 1000 DESKTOP" valType="str" updates="None" name="elModel"/>
    <Param val="ELLIPSE_FIT" valType="str" updates="None" name="elPupilAlgorithm"/>
    <Param val="PUPIL_AREA" valType="str" updates="None" name="elPupilMeasure"/>
    <Param val="1000" valType="num" updates="None" name="elSampleRate"/>
    <Param val="False" valType="bool" updates="None" name="elSimMode"/>
    <Param val="RIGHT_EYE" valType="str" updates="None" name="elTrackEyes"/>
    <Param val="PUPIL_CR_TRACKING" valType="str" updates="None" name="elTrackingMode"/>
    <Param val="EXNAT_3_training" valType="str" updates="None" name="expName"/>
    <Param val="on Sync" valType="str" updates="None" name="exportHTML"/>
    <Param val="None" valType="str" updates="None" name="eyetracker"/>
    <Param val="" valType="code" updates="None" name="frameRate"/>
    <Param val="Attempting to measure frame rate of screen, please wait..." valType="str" updates="None" name="frameRateMsg"/>
    <Param val="127.0.0.1" valType="str" updates="None" name="gpAddress"/>
    <Param val="4242" valType="num" updates="None" name="gpPort"/>
    <Param val="ioHub" valType="str" updates="None" name="keyboardBackend"/>
    <Param val="error" valType="code" updates="None" name="logging level"/>
    <Param val="False" valType="bool" updates="None" name="measureFrameRate"/>
    <Param val="('MIDDLE_BUTTON',)" valType="list" updates="None" name="mgBlink"/>
    <Param val="CONTINUOUS" valType="str" updates="None" name="mgMove"/>
    <Param val="0.5" valType="num" updates="None" name="mgSaccade"/>
    <Param val="neon.local" valType="str" updates="None" name="plCompanionAddress"/>
    <Param val="8080" valType="num" updates="None" name="plCompanionPort"/>
    <Param val="True" valType="bool" updates="None" name="plCompanionRecordingEnabled"/>
    <Param val="0.6" valType="num" updates="None" name="plConfidenceThreshold"/>
    <Param val="True" valType="bool" updates="None" name="plPupilCaptureRecordingEnabled"/>
    <Param val="" valType="str" updates="None" name="plPupilCaptureRecordingLocation"/>
    <Param val="127.0.0.1" valType="str" updates="None" name="plPupilRemoteAddress"/>
    <Param val="50020" valType="num" updates="None" name="plPupilRemotePort"/>
    <Param val="1000" valType="num" updates="None" name="plPupilRemoteTimeoutMs"/>
    <Param val="False" valType="bool" updates="None" name="plPupillometryOnly"/>
    <Param val="psychopy_iohub_surface" valType="str" updates="None" name="plSurfaceName"/>
    <Param val="1" valType="code" updates="None" name="runMode"/>
    <Param val="False" valType="bool" updates="None" name="rush"/>
    <Param val="time" valType="str" updates="None" name="sortColumns"/>
    <Param val="" valType="str" updates="None" name="tbLicenseFile"/>
    <Param val="" valType="str" updates="None" name="tbModel"/>
    <Param val="60" valType="num" updates="None" name="tbSampleRate"/>
    <Param val="" valType="str" updates="None" name="tbSerialNo"/>
    <Param val="pyglet" valType="str" updates="None" name="winBackend"/>
  </Settings>
  <Routines>
    <Routine name="Settings">
      <RoutineSettingsComponent name="Settings" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="Settings" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <CodeComponent name="functions" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="import {visual} from 'psychopy';&amp;#10;import * as datetime from 'datetime';&amp;#10;import * as np from 'numpy';&amp;#10;import * as random from 'random';&amp;#10;import * as pd from 'pandas';&amp;#10;import * as time from 'time';&amp;#10;import {instr_1back_dual_main, instr_1back_single_main, instr_1back_single_training1, instr_1back_single_training2, instr_2back_dual_main, instr_2back_single_main, instr_2back_single_training1, instr_2back_single_training2, instr_Reading_Baseline_main, instr_Reading_Baseline_training, instr_click_training, instr_pic_1back_dual_main, instr_pic_1back_single_main, instr_pic_1back_single_training1, instr_pic_1back_single_training2, instr_pic_2back_dual_main, instr_pic_2back_single_main, instr_pic_2back_single_training1, instr_pic_2back_single_training2, instr_pic_Reading_Baseline_main, instr_pic_Reading_Baseline_training, instr_pic_click_training, instr_pic_path, instr_pic_vis_task, instr_vis_task_1, instr_vis_task_2, reading_bl_tr_Q1, reading_bl_tr_Q1_ans, reading_bl_tr_Q1_corr, reading_bl_tr_Q2, reading_bl_tr_Q2_ans, reading_bl_tr_Q2_corr, reading_bl_tr_Q3, reading_bl_tr_Q3_ans, reading_bl_tr_Q3_corr, reading_bl_tr_text, text_01, text_01_Q1, text_01_Q1_ans, text_01_Q1_corr, text_01_Q2, text_01_Q2_ans, text_01_Q2_corr, text_01_Q3, text_01_Q3_ans, text_01_Q3_corr, text_02, text_02_Q1, text_02_Q1_ans, text_02_Q1_corr, text_02_Q2, text_02_Q2_ans, text_02_Q2_corr, text_02_Q3, text_02_Q3_ans, text_02_Q3_corr, text_03, text_03_Q1, text_03_Q1_ans, text_03_Q1_corr, text_03_Q2, text_03_Q2_ans, text_03_Q2_corr, text_03_Q3, text_03_Q3_ans, text_03_Q3_corr, text_04, text_04_Q1, text_04_Q1_ans, text_04_Q1_corr, text_04_Q2, text_04_Q2_ans, text_04_Q2_corr, text_04_Q3, text_04_Q3_ans, text_04_Q3_corr, text_05, text_05_Q1, text_05_Q1_ans, text_05_Q1_corr, text_05_Q2, text_05_Q2_ans, text_05_Q2_corr, text_05_Q3, text_05_Q3_ans, text_05_Q3_corr, text_06, text_06_Q1, text_06_Q1_ans, text_06_Q1_corr, text_06_Q2, text_06_Q2_ans, text_06_Q2_corr, text_06_Q3, text_06_Q3_ans, text_06_Q3_corr, text_07, text_07_Q1, text_07_Q1_ans, text_07_Q1_corr, text_07_Q2, text_07_Q2_ans, text_07_Q2_corr, text_07_Q3, text_07_Q3_ans, text_07_Q3_corr, text_08, text_08_Q1, text_08_Q1_ans, text_08_Q1_corr, text_08_Q2, text_08_Q2_ans, text_08_Q2_corr, text_08_Q3, text_08_Q3_ans, text_08_Q3_corr, text_09, text_09_Q1, text_09_Q1_ans, text_09_Q1_corr, text_09_Q2, text_09_Q2_ans, text_09_Q2_corr, text_09_Q3, text_09_Q3_ans, text_09_Q3_corr, text_10, text_10_Q1, text_10_Q1_ans, text_10_Q1_corr, text_10_Q2, text_10_Q2_ans, text_10_Q2_corr, text_10_Q3, text_10_Q3_ans, text_10_Q3_corr, warning_sign} from 'EXNAT2_texts_MC_Qs';&amp;#10;import {change_bg_colour} from 'EXNAT2_study_components';&amp;#10;import {create_0back_stimlist, create_nback_stimlist, draw_without_replacement, get_targets} from 'nback_colour_generator';&amp;#10;[SCN_W, SCN_H] = [1280, 800];&amp;#10;sys.stdout = open(sys.stdout.fileno(), {&quot;mode&quot;: &quot;w&quot;, &quot;encoding&quot;: &quot;utf8&quot;, &quot;buffering&quot;: 1});&amp;#10;console.log(sys.executable);&amp;#10;function flatten_list(nested_list) {&amp;#10;    var flattened_list;&amp;#10;    flattened_list = [];&amp;#10;    for (var item, _pj_c = 0, _pj_a = nested_list, _pj_b = _pj_a.length; (_pj_c &lt; _pj_b); _pj_c += 1) {&amp;#10;        item = _pj_a[_pj_c];&amp;#10;        if ((item instanceof list)) {&amp;#10;            flattened_list.concat(flatten_list(item));&amp;#10;        } else {&amp;#10;            flattened_list.push(item);&amp;#10;        }&amp;#10;    }&amp;#10;    return flattened_list;&amp;#10;}&amp;#10;function escape_quotes(string) {&amp;#10;    return string.replace(&quot;\&quot;&quot;, &quot;\&quot;\&quot;&quot;);&amp;#10;}&amp;#10;psychoJS.window.setMouseVisible(false);&amp;#10;my_timer = new core.CountdownTimer(0.01);&amp;#10;" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="# set screen resolution for eyetracker here:&amp;#10;SCN_W, SCN_H = (1280, 800)&amp;#10;&amp;#10;### import packages:&amp;#10;&amp;#10;# for setting the output encoding to UTF-8&amp;#10;import sys&amp;#10;# --&gt; if you don't do this, German &quot;Umlaute&quot; can't be displayed correctly:&amp;#10;sys.stdout = open(sys.stdout.fileno(), mode='w', encoding='utf8', buffering=1)&amp;#10;# print Python environment psychopy is currently using&amp;#10;print(sys.executable)&amp;#10;&amp;#10;# for showing pictures&amp;#10;from psychopy import visual&amp;#10;# for getting current date &amp; time:&amp;#10;import datetime&amp;#10;# numpy for being able to calculate&amp;#10;import numpy as np&amp;#10;# for random number generator:&amp;#10;import random&amp;#10;# for saving data in csv / working with pd data frames:&amp;#10;import pandas as pd&amp;#10;# additional timing package (I know we have core.wait, but I also want this one)&amp;#10;import time&amp;#10;# math package for log function&amp;#10;import math&amp;#10;# for serial port&amp;#10;#import pyxid&amp;#10;#devices = pyxid.get_xid_devices()&amp;#10;#mybox = devices[0]&amp;#10;#if myBox.is_response_device():&amp;#10;#    myBox.reset_base_timer()&amp;#10;#    myBox.reset_rt_timer()&amp;#10;#    while True:&amp;#10;#        myBox.poll_for_response()&amp;#10;#        if myBox.response_queue_size()&gt;0:&amp;#10;#            response = myBox.get_next_response()&amp;#10;#            print(response)&amp;#10;&amp;#10;# Get functions from my custom scripts:&amp;#10;# import all texts&amp;#10;from EXNAT3_training_texts_MC_Qs import instr_pic_path, instr_Reading_Baseline_training_click, \&amp;#10;    instr_pic_Reading_Baseline_training_click, instr_Reading_pseudotext_no_click, instr_Reading_Baseline_main_click, \&amp;#10;    instr_pic_Reading_Baseline_main_click, instr_Reading_Baseline_main_no_click, instr_click_training, \&amp;#10;    instr_pic_click_training, instr_0back_single_training1, instr_0back_single_training2, instr_pic_0back, instr_0back_dual_main_click1, instr_0back_dual_main_click2, instr_0back_dual_main_no_click1, instr_0back_dual_main_no_click2, instr_1back_single_training1, instr_pic_1back_single_training1, \&amp;#10;    instr_1back_single_training2, instr_pic_1back_single_training2, instr_1back_single_main, \&amp;#10;    instr_pic_1back_single_main, instr_1back_single_main_no_click, instr_pic_1back_single_main_no_click, instr_1back_dual_main_click, instr_pic_1back_dual_main_click, \&amp;#10;    instr_1back_dual_main_no_click, instr_2back_single_training1, instr_pic_2back_single_training1, \&amp;#10;    instr_2back_single_training2, instr_pic_2back_single_training2, instr_2back_single_main, \&amp;#10;    instr_pic_2back_single_main, instr_2back_single_main_no_click, instr_pic_2back_single_main_no_click, instr_2back_dual_main_click, instr_pic_2back_dual_main_click, \&amp;#10;    instr_2back_dual_main_no_click, instr_Reading_Baseline_training_no_click, instr_pic_1back_dual_main_no_click, \&amp;#10;    instr_pic_2back_dual_main_no_click, warning_sign, reading_bl_tr_text, reading_bl_tr_Q1, reading_bl_tr_Q1_ans, \&amp;#10;    reading_bl_tr_Q1_corr, reading_bl_tr_Q2, reading_bl_tr_Q2_ans, reading_bl_tr_Q2_corr, reading_bl_tr_Q3, \&amp;#10;    reading_bl_tr_Q3_ans, reading_bl_tr_Q3_corr, reading_bl_tr_text_no_click, reading_bl_tr_no_click_Q1, \&amp;#10;    reading_bl_tr_no_click_Q1_ans, reading_bl_tr_no_click_Q1_corr, reading_bl_tr_no_click_Q2, \&amp;#10;    reading_bl_tr_no_click_Q2_ans, reading_bl_tr_no_click_Q2_corr, reading_bl_tr_no_click_Q3, \&amp;#10;    reading_bl_tr_no_click_Q3_ans, reading_bl_tr_no_click_Q3_corr, text_01, text_01_Q1, text_01_Q1_ans, text_01_Q1_corr, \&amp;#10;    text_01_Q2, text_01_Q2_ans, text_01_Q2_corr, text_01_Q3, text_01_Q3_ans, text_01_Q3_corr, text_02, text_02_Q1, \&amp;#10;    text_02_Q1_ans, text_02_Q1_corr, text_02_Q2, text_02_Q2_ans, text_02_Q2_corr, text_02_Q3, text_02_Q3_ans, \&amp;#10;    text_02_Q3_corr, text_03, text_03_Q1, text_03_Q1_ans, text_03_Q1_corr, text_03_Q2, text_03_Q2_ans, text_03_Q2_corr, \&amp;#10;    text_03_Q3, text_03_Q3_ans, text_03_Q3_corr, text_04, text_04_Q1, text_04_Q1_ans, text_04_Q1_corr, text_04_Q2, \&amp;#10;    text_04_Q2_ans, text_04_Q2_corr, text_04_Q3, text_04_Q3_ans, text_04_Q3_corr, text_05, text_05_Q1, text_05_Q1_ans, \&amp;#10;    text_05_Q1_corr, text_05_Q2, text_05_Q2_ans, text_05_Q2_corr, text_05_Q3, text_05_Q3_ans, text_05_Q3_corr, text_06, \&amp;#10;    text_06_Q1, text_06_Q1_ans, text_06_Q1_corr, text_06_Q2, text_06_Q2_ans, text_06_Q2_corr, text_06_Q3, \&amp;#10;    text_06_Q3_ans, text_06_Q3_corr, text_07, \&amp;#10;    text_07_Q1, text_07_Q1_ans, text_07_Q1_corr, text_07_Q2, text_07_Q2_ans, text_07_Q2_corr, text_07_Q3, \&amp;#10;    text_07_Q3_ans, text_07_Q3_corr, text_08, \&amp;#10;    text_08_Q1, text_08_Q1_ans, text_08_Q1_corr, text_08_Q2, text_08_Q2_ans, text_08_Q2_corr, text_08_Q3, \&amp;#10;    text_08_Q3_ans, text_08_Q3_corr, reading_ps_text_no_click&amp;#10;&amp;#10;# import some additional functions I wrote for the experiment:&amp;#10;# from EXNAT3_study_components import change_bg_colour&amp;#10;from nback_colour_generator import create_nback_stimlist, draw_without_replacement, get_targets, create_0back_stimlist&amp;#10;&amp;#10;&amp;#10;# build little function to flatten nested lists:&amp;#10;def flatten_list(nested_list):&amp;#10;    flattened_list = []&amp;#10;    for item in nested_list:&amp;#10;        if isinstance(item, list):&amp;#10;            flattened_list.extend(flatten_list(item))&amp;#10;        else:&amp;#10;            flattened_list.append(item)&amp;#10;    return flattened_list&amp;#10;&amp;#10;&amp;#10;# If I try to save strings containing escaped quotes in a csv file,&amp;#10;# the format gets completely messed up. So we need to escape all&amp;#10;# weird characters like quotes and backslashes with quotes (as odd as it sounds).&amp;#10;def escape_quotes(string):&amp;#10;    # escape quotes with quotes instead of backslashes&amp;#10;    return string.replace('&quot;', '&quot;&quot;')&amp;#10;&amp;#10;&amp;#10;# make mouse invisible during experiment&amp;#10;# mouse = io.devices.mouse&amp;#10;# win.setMouseVisible(False)&amp;#10;# mouse = event.Mouse(visible = False) &amp;#10;# mouse.setExclusive(True) # this disables mouse during entire experiment&amp;#10;win.mouseVisible = False&amp;#10;&amp;#10;# create 10 ms timer that we can use instead of core.wait()&amp;#10;my_timer = core.CountdownTimer(0.01)" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="functions" valType="code" updates="None" name="name"/>
      </CodeComponent>
      <CodeComponent name="stimuli" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="### Stimulus settings&amp;#10;import random&amp;#10;&amp;#10;# measure frame rate (in Hz)&amp;#10;# frame_rate = win.getActualFrameRate() # frame rate in Hz&amp;#10;# print(&quot;measured frame rate:&quot;, frame_rate, &quot;Hz&quot;)&amp;#10;# set flicker frequency (in Hz)&amp;#10;# flicker_freq = frame_rate/4 # 60/4 = 15 Hz&amp;#10;&amp;#10;# set colours you want to use for background:&amp;#10;# light_bg_col_hex = &quot;#FDFBF0&quot; # ivory instructions background&amp;#10;# dark_bg_col_hex  = &quot;#505050&quot; # dark grey background for stimuli&amp;#10;light_bg_col = [(x / 127.5) - 1 for x in (253, 251, 240)]  # ivory instructions background (use RGB -1:1)&amp;#10;dark_bg_col = [(x / 127.5) - 1 for x in (80, 80, 80)]  # dark grey background for stimuli (use RGB -1:1)&amp;#10;&amp;#10;# for timing test:&amp;#10;# dark_bg_col = [(x / 127.5) - 1 for x in (255, 255, 255)]&amp;#10;&amp;#10;# make background light for a start - use rgb -1:1 colour codes&amp;#10;win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;&amp;#10;# set colours you want to use for the stimuli:&amp;#10;colours = [&quot;#D292F3&quot;, &quot;#F989A2&quot;, &quot;#2AB7EF&quot;, &quot;#88BA3F&quot;]&amp;#10;print(&quot;Preparing experiment with n-back colours:&quot;, colours)&amp;#10;# for timing test:&amp;#10;# colours = [&quot;#000000&quot;, &quot;#F989A2&quot;, &quot;#2AB7EF&quot;, &quot;#88BA3F&quot;]&amp;#10;&amp;#10;#  #D292F3 = weird lilac with a 2000s vibe&amp;#10;#  #F989A2 = Barbie pink&amp;#10;#  #2AB7EF = Twitter blue&amp;#10;#  #88BA3F = medium grass green&amp;#10;# (#D8A244 = dark curry-ish yellow --&gt; excluded!)&amp;#10;&amp;#10;#   All colours have a luminance of 70 and a chroma of 74.&amp;#10;&amp;#10;#   The colours are selected for distinguishability (is that a word?!)&amp;#10;#   for people with &quot;normal&quot; colour vision as well as for&amp;#10;#   people with protanomaly (red olour vision deficiency (CVD)),&amp;#10;#   deuteranomaly (green CVD) and&amp;#10;#   tritanomaly (blue CVD).&amp;#10;&amp;#10;#   People with a &quot;true&quot; colour blindness&amp;#10;#   (i.e. protanopia, deuteranopia, tritanopia)&amp;#10;#   shouldn't participate in this study. */&amp;#10;&amp;#10;&amp;#10;# ----------------------------------------------&amp;#10;### Shuffle order of texts&amp;#10;print(&quot;shuffle texts&quot;)&amp;#10;# collect the text IDs in lists so I know which text was shown&amp;#10;all_main_texts_nrs_list = [&quot;text_01&quot;, &quot;text_02&quot;, &quot;text_03&quot;, &quot;text_04&quot;, &quot;text_05&quot;, &quot;text_06&quot;, &quot;text_07&quot;, &quot;text_08&quot;]&amp;#10;# shuffle text numbers&amp;#10;random.shuffle(all_main_texts_nrs_list)&amp;#10;&amp;#10;# only get first 9 texts for the main blocks, the last one will be used for the vis task:&amp;#10;# vis_task_text_nr = all_main_texts_nrs_list[-1]&amp;#10;# all_main_texts_nrs_list = all_main_texts_nrs_list[0:-1]&amp;#10;&amp;#10;# append &quot;empty&quot; text numbers to the list where we have blocks that are not main blocks.&amp;#10;all_texts_nrs_list = []&amp;#10;&amp;#10;for t_idx, t in enumerate(all_main_texts_nrs_list):&amp;#10;    # if it's the first text, it's the reading BL main block.&amp;#10;    if t_idx == 0:&amp;#10;        all_texts_nrs_list = all_texts_nrs_list + [&quot;&quot;, t, &quot;&quot;]&amp;#10;    elif t_idx == 1:&amp;#10;        all_texts_nrs_list = all_texts_nrs_list + [t, &quot;&quot;, &quot;&quot;, &quot;&quot;]&amp;#10;    # one text for 0back dual block with click, one text for 0-back no click&amp;#10;    elif t_idx == 2:&amp;#10;        all_texts_nrs_list = all_texts_nrs_list + [t, &quot;&quot;, &quot;&quot;, &quot;&quot;]&amp;#10;    # append one text for self-paced dual block 0-back,&amp;#10;    # then two empty blocks for n-back training, then two blocks for single n-back blocks (self-paced and paced)&amp;#10;    elif t_idx == 3:&amp;#10;        all_texts_nrs_list = all_texts_nrs_list + [t, &quot;&quot;]&amp;#10;    # one text for paced dual block, then again four empty blocks for other n-back condition&amp;#10;    elif t_idx == 4:&amp;#10;        all_texts_nrs_list = all_texts_nrs_list + [t]&amp;#10;    elif t_idx == 5:&amp;#10;        all_texts_nrs_list = all_texts_nrs_list + [t, &quot;&quot;]&amp;#10;    elif t_idx == 6:&amp;#10;        all_texts_nrs_list = all_texts_nrs_list + [t, &quot;&quot;]&amp;#10;    elif t_idx &gt; 6:&amp;#10;        [t]&amp;#10;    # then finally append rest of texts (two texts)&amp;#10;&amp;#10;        all_texts_nrs_list.append(t)&amp;#10;&amp;#10;print(all_texts_nrs_list)&amp;#10;&amp;#10;### Set order of blocks&amp;#10;# Currently 20 blocks in total&amp;#10;print(&quot;set block order&quot;)&amp;#10;&amp;#10;# this always comes first in the experiment&amp;#10;blocks_click = [&quot;Reading_Baseline_training_click&quot;, &quot;Reading_Baseline_main_click&quot;, &quot;0back_single_training&quot;,&amp;#10;                &quot;0back_dual_main_click&quot;, &quot;1back_single_training1&quot;, &quot;1back_single_training2&quot;, &quot;1back_single_main&quot;,&amp;#10;                &quot;1back_dual_main_click&quot;, &quot;2back_single_training1&quot;, &quot;2back_single_training2&quot;, &quot;2back_single_main&quot;,&amp;#10;                &quot;2back_dual_main_click&quot;]&amp;#10;reading_no_click = [&quot;Reading_Baseline_training_no_click&quot;, &quot;Reading_Baseline_main_no_click&quot;, &quot;0back_dual_main_no_click&quot;]&amp;#10;&amp;#10;# then you get both n-back conditions with trainings (which of them is first is randomized)&amp;#10;oneback = [&quot;1back_single_main_no_click&quot;, &quot;1back_dual_main_no_click&quot;]&amp;#10;twoback = [&quot;2back_single_main_no_click&quot;, &quot;2back_dual_main_no_click&quot;]&amp;#10;&amp;#10;# shuffle the order of the 2 lists&amp;#10;blocks_no_click = [oneback, twoback]&amp;#10;random.shuffle(blocks_no_click)&amp;#10;&amp;#10;# flatten nested list&amp;#10;main_blocks = flatten_list(blocks_no_click)&amp;#10;&amp;#10;pseudo_block = [&quot;Reading_pseudotext_no_click&quot;]&amp;#10;&amp;#10;# put them all together:&amp;#10;# global all_blocks&amp;#10;all_blocks = blocks_click + reading_no_click + blocks_no_click + pseudo_block&amp;#10;all_blocks = flatten_list(all_blocks)&amp;#10;print(all_blocks)&amp;#10;&amp;#10;### Create n-back colour lists for all blocks&amp;#10;&amp;#10;print(&quot;create n-back colour lists&quot;)&amp;#10;# The reading bl training text has 55 trials.&amp;#10;# the reading bl main has 91 words&amp;#10;# reading training no click has 58 words&amp;#10;# then main reading bl no click with 91 words&amp;#10;# then 0-back short training with 20 trials&amp;#10;# then 0-back dual self-paced and paced block with 91 trials and 15 targets each&amp;#10;&amp;#10;# Then we have 2 short training blocks à 20 trials each (5 targets) for n-back&amp;#10;# then two single n-back blocks with 90 trials each (15 targets)&amp;#10;# then two dual blocks with 91 trials each (15 targets)&amp;#10;# then again two short training blocks, two single n-back blocks with 90 trials each (15 targets), and two dual blocks with 91 trials (15 targets)&amp;#10;# and finally, one pseudotext block&amp;#10;&amp;#10;# --&gt; all in all, 20 blocks&amp;#10;&amp;#10;# So for every block, build a list with colour codes containing the right amount of targets.&amp;#10;# The function is defined in another script bc it's super long,&amp;#10;# I import it at the beginning of this script.&amp;#10;&amp;#10;# First, create list with length of all texts. The length of the blocks is&amp;#10;# always in the same order, only the conditions change.&amp;#10;&amp;#10;blocks_click = [&quot;Reading_Baseline_training_click&quot;, &quot;Reading_Baseline_main_click&quot;, &quot;0back_single_training&quot;,&amp;#10;                &quot;0back_dual_main_click&quot;, &quot;1back_single_training1&quot;, &quot;1back_single_training2&quot;, &quot;1back_single_main&quot;,&amp;#10;                &quot;1back_dual_main_click&quot;, &quot;2back_single_training1&quot;, &quot;2back_single_training2&quot;, &quot;2back_single_main&quot;,&amp;#10;                &quot;2back_dual_main_click&quot;]&amp;#10;reading_no_click = [&quot;Reading_Baseline_training_no_click&quot;, &quot;Reading_Baseline_main_no_click&quot;, &quot;0back_dual_main_no_click&quot;]&amp;#10;&amp;#10;# then you get both n-back conditions with trainings (which of them is first is randomized)&amp;#10;oneback = [&quot;1back_single_main_no_click&quot;, &quot;1back_dual_main_no_click&quot;]&amp;#10;twoback = [&quot;2back_single_main_no_click&quot;, &quot;2back_dual_main_no_click&quot;]&amp;#10;&amp;#10;blocks_textlen = [60, 91, 20, 91,&amp;#10;                  20, 20, 90, 91,&amp;#10;                  20, 20, 90, 91,&amp;#10;                  60, 91, 91, 90, 91, 90, 91,&amp;#10;                  100]&amp;#10;blocks_target_counts = [15, 15, 5, 15,&amp;#10;                        5, 5, 15, 15,&amp;#10;                        5, 5, 15, 15,&amp;#10;                        15, 15, 15, 15,&amp;#10;                        15, 15, 15, 15]&amp;#10;# Now loop this list. Check which condition we have there and the create colour list for each text.&amp;#10;all_colour_lists = []&amp;#10;all_target_lists = []&amp;#10;target_colours_list = []&amp;#10;# target_colour = np.random.choice(colours)&amp;#10;for block_idx, block_length in enumerate(blocks_textlen):&amp;#10;    # get 1st letter of block name - that tells us the condition&amp;#10;    block_cond = all_blocks[block_idx][0]&amp;#10;&amp;#10;    # for each condition, decide which n-back level we want to assign&amp;#10;    # For all no-n-back blocks, we use 1 (just for the colour list generation)&amp;#10;    # global curr_nback_level&amp;#10;    if block_cond == &quot;R&quot;:&amp;#10;        curr_nback_level = 1&amp;#10;    elif block_cond == &quot;0&quot;:&amp;#10;        curr_nback_level = 0&amp;#10;    elif block_cond == &quot;1&quot;:&amp;#10;        curr_nback_level = 1&amp;#10;    else:&amp;#10;        curr_nback_level = 2&amp;#10;&amp;#10;    # generate colour list for current block&amp;#10;    if curr_nback_level == 0:&amp;#10;        # generate random colour list for 0-back:&amp;#10;        # Filter out the colours that have already been used as target colours&amp;#10;        available_colours = [colour for colour in colours if colour not in target_colours_list]&amp;#10;&amp;#10;        # Shuffle the available colours to randomize the selection&amp;#10;        random.shuffle(available_colours)&amp;#10;&amp;#10;        # Select the first colour from the shuffled available colours as the target colour&amp;#10;        target_colour = available_colours[0]&amp;#10;&amp;#10;        print(&quot;curr target colour:&quot;, target_colour)&amp;#10;        curr_colours = create_0back_stimlist(target_colour=target_colour,&amp;#10;                                             nr_targets=blocks_target_counts[block_idx],&amp;#10;                                             colour_codes=colours,&amp;#10;                                             nr_words=blocks_textlen[block_idx])&amp;#10;        # Get list of targets / non-targets&amp;#10;        curr_targets = [colour == target_colour for colour in curr_colours]&amp;#10;&amp;#10;        # Add the selected target colour to the list of target colours&amp;#10;        target_colours_list.append(target_colour)&amp;#10;&amp;#10;    elif curr_nback_level in [1, 2]:&amp;#10;        # global curr_colours&amp;#10;        curr_colours = create_nback_stimlist(nback_level=curr_nback_level,&amp;#10;                                         colour_codes=colours,&amp;#10;                                         story=[&quot;x&quot;] * block_length,&amp;#10;                                         target_abs_min=blocks_target_counts[block_idx],&amp;#10;                                         target_abs_max=blocks_target_counts[block_idx],&amp;#10;                                         zeroback_target=None)&amp;#10;&amp;#10;        # get list of targets / non-targets&amp;#10;        curr_targets = get_targets(stim_list=curr_colours,&amp;#10;                               nback_level=curr_nback_level)&amp;#10;&amp;#10;    # add to bigger lists&amp;#10;    all_colour_lists.append(curr_colours)&amp;#10;    all_target_lists.append(curr_targets)&amp;#10;&amp;#10;print(&quot;------ finished preparing stimuli! ------&quot;)&amp;#10;&amp;#10;# ------------------------------------------&amp;#10;&amp;#10;# init block counter for the whole experiment&amp;#10;exp_block_counter = 0&amp;#10;&amp;#10;print(&quot;starting experiment now!&quot;)" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="stimuli" valType="code" updates="None" name="name"/>
      </CodeComponent>
    </Routine>
    <Routine name="text_blocks_self_paced">
      <RoutineSettingsComponent name="text_blocks_self_paced" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="text_blocks_self_paced" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <CodeComponent name="text_blocks" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="/* Syntax Error: Fix Python code */" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="#################################################&amp;#10;#           Blocks with text – self-paced       #&amp;#10;#################################################&amp;#10;# this routine is for all blocks with texts that are self-paced&amp;#10;&amp;#10;# keep background ivory&amp;#10;win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;win.flip()&amp;#10;&amp;#10;# clear buffer of all previously recorded key events:&amp;#10;event.clearEvents()&amp;#10;&amp;#10;### specify settings for the current block&amp;#10;&amp;#10;### Prepare stimuli:&amp;#10;&amp;#10;# get block kind&amp;#10;curr_block = all_blocks[exp_block_counter]&amp;#10;# print(&quot;start preparing block &quot; + curr_block)&amp;#10;&amp;#10;# Check whether it's a block that isn't self-paced&amp;#10;# If yes, skip this routine&amp;#10;if curr_block in [&quot;click_training&quot;, &quot;0back_single_training&quot;, &quot;1back_single_training1&quot;, &quot;1back_single_training2&quot;,&amp;#10;                  &quot;1back_single_main&quot;, &quot;2back_single_training1&quot;, &quot;2back_single_training2&quot;, &quot;2back_single_main&quot;,&amp;#10;                  &quot;Reading_Baseline_main_no_click&quot;, &quot;0back_dual_main_no_click&quot;, &quot;1back_dual_main_no_click&quot;, &quot;2back_dual_main_no_click&quot;,&amp;#10;                  &quot;Reading_Baseline_training_no_click&quot;, &quot;1back_single_main_no_click&quot;, &quot;2back_single_main_no_click&quot;]:&amp;#10;    print(f&quot;this is block {curr_block}&quot;)&amp;#10;    print(&quot;\tskipping self-paced text routine&quot;)&amp;#10;    # skip questions &amp; end current routine&amp;#10;    skip_questions = True&amp;#10;    continueRoutine = False&amp;#10;    # break&amp;#10;&amp;#10;# if it's the reading bl training block, prepare training stimuli:&amp;#10;elif curr_block == &quot;Reading_Baseline_training_click&quot;:&amp;#10;    print(f&quot;this is block {curr_block}&quot;)&amp;#10;    print(f&quot;start preparing block {curr_block}&quot;)&amp;#10;&amp;#10;    # keep background ivory&amp;#10;    win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;    win.flip()&amp;#10;&amp;#10;    ### Show instructions&amp;#10;    # set instruction text&amp;#10;    instr_text = locals()[&quot;instr_&quot; + curr_block]&amp;#10;    # create text box&amp;#10;    instr_text_stim = visual.TextStim(win,&amp;#10;                                      text=instr_text,&amp;#10;                                      height=0.025,  # font height relative to height of screen&amp;#10;                                      pos=(0, 0.2),  # move up a bit&amp;#10;                                      color=&quot;black&quot;)&amp;#10;    # create ImageStim object&amp;#10;    curr_instr_pic = visual.ImageStim(win,&amp;#10;                                      size=(0.6, 0.3),&amp;#10;                                      pos=(0, -0.2),&amp;#10;                                      image=locals()[&quot;instr_pic_&quot; + curr_block])  # set path to image here&amp;#10;&amp;#10;    # show instructions on screen&amp;#10;    win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;    instr_text_stim.draw()&amp;#10;    curr_instr_pic.draw()&amp;#10;    win.flip()&amp;#10;    core.wait(3)  # wait for 3s before starting response window&amp;#10;&amp;#10;    # display the text on screen&amp;#10;    while True:&amp;#10;        # keep background ivory&amp;#10;        win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;        instr_text_stim.draw()&amp;#10;        curr_instr_pic.draw()&amp;#10;        win.flip()&amp;#10;        # end showing screen if participant presses space&amp;#10;        if 'space' in event.getKeys():&amp;#10;            break&amp;#10;&amp;#10;    ### get training text&amp;#10;    curr_text = reading_bl_tr_text&amp;#10;    curr_text_nr = &quot;reading_bl_training_text&quot;&amp;#10;    curr_nback_cond = None&amp;#10;    curr_colours = all_colour_lists[0]&amp;#10;    # show training questions&amp;#10;    skip_questions = False&amp;#10;    training_Qs = True&amp;#10;&amp;#10;    # we also need the start time (let's set it as current time&amp;#10;    # at this point in the script):&amp;#10;    start_time = core.getTime()&amp;#10;&amp;#10;    ### change background colour&amp;#10;    win.setColor(dark_bg_col, colorSpace='rgb')&amp;#10;    win.flip()&amp;#10;&amp;#10;    print(f&quot;\tcurrent text: {curr_text_nr}&quot;)&amp;#10;&amp;#10;# if it's one of the &quot;normal&quot; main blocks, prepare main block stimuli:&amp;#10;elif curr_block in [&quot;Reading_Baseline_main_click&quot;, &quot;0back_dual_main_click&quot;, &quot;1back_dual_main_click&quot;, &quot;2back_dual_main_click&quot;]:&amp;#10;    print(f&quot;this is block {curr_block}&quot;)&amp;#10;    print(f&quot;start preparing block {curr_block}&quot;)&amp;#10;&amp;#10;    # keep background ivory&amp;#10;    win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;    win.flip()&amp;#10;&amp;#10;    ### Show instructions&amp;#10;    # set instruction text&amp;#10;    if curr_block == &quot;0back_dual_main_click&quot;:&amp;#10;        # create text boxes&amp;#10;        instr_text_stim1 = visual.TextStim(win,&amp;#10;                                           text=locals()[&quot;instr_0back_dual_main_click1&quot;],&amp;#10;                                           height=0.025,  # font height relative to height of screen&amp;#10;                                           pos=(0, 0.3),  # move instructions up a bit&amp;#10;                                           color=&quot;black&quot;)&amp;#10;        instr_text_stim2 = visual.TextStim(win,&amp;#10;                                           text=locals()[&quot;instr_0back_dual_main_click2&quot;],&amp;#10;                                           height=0.025,  # font height: 5° visual angle&amp;#10;                                           pos=(0, -0.35),  # move instructions down a bit&amp;#10;                                           color=&quot;black&quot;)&amp;#10;        # create &quot;empty&quot; circle as stimulus&amp;#10;        instr_colour_circle_stim = visual.Circle(win=win,&amp;#10;                                                 radius=0.065,&amp;#10;                                                 pos=(0, 0.1))  # move circle slightly down&amp;#10;&amp;#10;        # set current target colour as colour of circle:&amp;#10;        instr_colour_circle_stim.fillColor = target_colours_list[1]&amp;#10;&amp;#10;        # create ImageStim object&amp;#10;        curr_instr_pic = visual.ImageStim(win,&amp;#10;                                          size=(0.55, 0.25),&amp;#10;                                          pos=(0, -0.15),&amp;#10;                                          image=locals()[&quot;instr_pic_0back&quot;])  # set path to image here&amp;#10;&amp;#10;    else:&amp;#10;        instr_text = locals()[&quot;instr_&quot; + curr_block]&amp;#10;        # create text box&amp;#10;        instr_text_stim = visual.TextStim(win,&amp;#10;                                          text=instr_text,&amp;#10;                                          height=0.025,  # font height relative to height of screen&amp;#10;                                          pos=(0, 0.2),  # move up a bit&amp;#10;                                          color=&quot;black&quot;)&amp;#10;        if curr_block == &quot;Reading_Baseline_main_click&quot;:&amp;#10;            # create ImageStim object&amp;#10;            curr_instr_pic = visual.ImageStim(win,&amp;#10;                                              size=(0.6, 0.3),&amp;#10;                                              pos=(0, -0.2),&amp;#10;                                              image=locals()[&quot;instr_pic_&quot; + curr_block])  # set path to image here&amp;#10;        else:&amp;#10;            # create ImageStim object&amp;#10;            curr_instr_pic = visual.ImageStim(win,&amp;#10;                                              size=(0.8, 0.3),&amp;#10;                                              pos=(0, -0.2),&amp;#10;                                              image=locals()[&quot;instr_pic_&quot; + curr_block])  # set path to image here&amp;#10;&amp;#10;    # show instructions&amp;#10;    if curr_block == &quot;0back_dual_main_click&quot;:&amp;#10;        win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;        instr_text_stim1.draw()&amp;#10;        instr_text_stim2.draw()&amp;#10;        instr_colour_circle_stim.draw()&amp;#10;        curr_instr_pic.draw()&amp;#10;        win.flip()&amp;#10;        core.wait(3)  # wait for 3s before starting response window&amp;#10;&amp;#10;        # display the text &amp; the circle on screen until Space is pressed&amp;#10;        while True:&amp;#10;            instr_text_stim1.draw()&amp;#10;            instr_text_stim2.draw()&amp;#10;            instr_colour_circle_stim.draw()&amp;#10;            curr_instr_pic.draw()&amp;#10;            win.flip()&amp;#10;            # end screen if participant presses space&amp;#10;            if event.getKeys(['space']):&amp;#10;                break&amp;#10;&amp;#10;    else:&amp;#10;        win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;        instr_text_stim.draw()&amp;#10;        curr_instr_pic.draw()&amp;#10;        win.flip()&amp;#10;        core.wait(3)  # wait for 3s before starting response window&amp;#10;&amp;#10;        # Display the text on screen&amp;#10;        while True:&amp;#10;            instr_text_stim.draw()&amp;#10;            curr_instr_pic.draw()&amp;#10;            win.flip()&amp;#10;            # end showing screen if participant presses space&amp;#10;            if 'space' in event.getKeys():&amp;#10;                break&amp;#10;&amp;#10;    ### change background colour&amp;#10;    win.setColor(dark_bg_col, colorSpace='rgb')&amp;#10;    win.flip()&amp;#10;&amp;#10;    # show main block questions&amp;#10;    skip_questions = False&amp;#10;    training_Qs = False&amp;#10;&amp;#10;    # get text nr:&amp;#10;    curr_text_nr = all_texts_nrs_list[exp_block_counter]&amp;#10;&amp;#10;    # get n-back condition:&amp;#10;    curr_nback_cond = curr_block[0]  # get first character of block name&amp;#10;&amp;#10;    # if it is a 0, 1 or 2, set that as current n-back level:&amp;#10;    if curr_nback_cond in ['0', '1', '2']:&amp;#10;        curr_nback_cond == int(curr_nback_cond)&amp;#10;    # if it's neither 0, 1 nor 2, it has to be a block without n-back,&amp;#10;    # so set curr_nback_cond to None&amp;#10;    else:&amp;#10;        curr_nback_cond = None&amp;#10;&amp;#10;    print(f&quot;\tcurrent n-back condition: {curr_nback_cond}&quot;)&amp;#10;    print(f&quot;\tcurrent text: {curr_text_nr}&quot;)&amp;#10;&amp;#10;    # get list with targets &amp; list with colours&amp;#10;    curr_targets = all_target_lists[exp_block_counter]&amp;#10;    curr_colours = all_colour_lists[exp_block_counter]&amp;#10;    # for current text nr, get text whose name = current text nr&amp;#10;    curr_text = locals()[curr_text_nr]&amp;#10;&amp;#10;### Start block loop&amp;#10;if curr_block in [&quot;Reading_Baseline_training_click&quot;, &quot;Reading_Baseline_main_click&quot;, &quot;0back_dual_main_click&quot;, &quot;1back_dual_main_click&quot;, &quot;2back_dual_main_click&quot;]:&amp;#10;    # depending on condition, create arrays for saving response&amp;#10;    # times &amp; words - we need that later for the paced reading tasks&amp;#10;    if curr_block == &quot;Reading_Baseline_main_click&quot;:&amp;#10;        BL_paced_durations = []&amp;#10;        BL_paced_words = []&amp;#10;    elif curr_block == &quot;0back_dual_main_click&quot;:&amp;#10;        zeroback_paced_durations = []&amp;#10;        zeroback_paced_words = []&amp;#10;    elif curr_block == &quot;1back_dual_main_click&quot;:&amp;#10;        oneback_paced_durations = []&amp;#10;        oneback_paced_words = []&amp;#10;    elif curr_block == &quot;2back_dual_main_click&quot;:&amp;#10;        twoback_paced_durations = []&amp;#10;        twoback_paced_words = []&amp;#10;&amp;#10;    # create empty text stimulus&amp;#10;    stim = visual.TextStim(win=win,&amp;#10;                           text=&quot; &quot;,&amp;#10;                           pos=(0, 0),  # center stimulus&amp;#10;                           font=&quot;Times New Roman&quot;,&amp;#10;                           height=0.07)&amp;#10;&amp;#10;    stim.draw()&amp;#10;    win.flip()&amp;#10;&amp;#10;    # clear buffer of all previously recorded key events:&amp;#10;    event.clearEvents()&amp;#10;&amp;#10;    # CREATE CLOCKS:&amp;#10;    my_block_clock = core.Clock()&amp;#10;    my_block_clock.reset()  # start block clock&amp;#10;    start_time = my_block_clock.getTime()  # get start time of block&amp;#10;    # also create trial clock&amp;#10;    my_trial_clock = core.Clock()&amp;#10;&amp;#10;    # loop words in current text&amp;#10;    for trial_idx, curr_word in enumerate(curr_text):&amp;#10;        # print(&quot;current idx: &quot; + str(trial_idx) + &quot;, curr word:&quot; + curr_word)&amp;#10;&amp;#10;        ### prepare &amp; show current word:&amp;#10;        # get current colour&amp;#10;        curr_colour = curr_colours[trial_idx]&amp;#10;&amp;#10;        # if it's a block with an n-back task, prepare target list as well&amp;#10;        if curr_nback_cond != None:&amp;#10;            curr_target = curr_targets[trial_idx]&amp;#10;            saw_target = False&amp;#10;&amp;#10;        # get trial number (start counting from 1, so add 1)&amp;#10;        curr_trial_nr = trial_idx + 1&amp;#10;&amp;#10;        # set current word &amp; colour as content of text stimulus&amp;#10;        stim.color = curr_colour&amp;#10;        stim.text = curr_word&amp;#10;&amp;#10;        # show word on screen&amp;#10;        stim.draw()  # draw word on screen&amp;#10;&amp;#10;        # start trial clock&amp;#10;        my_trial_clock.reset()&amp;#10;        onset_time = my_trial_clock.getTime()&amp;#10;&amp;#10;        ### wait for 50 ms&amp;#10;        while my_trial_clock.getTime() &lt; onset_time + 0.05:&amp;#10;&amp;#10;            # draw the stimulus during the waiting period&amp;#10;            stim.draw()  # draw text&amp;#10;            win.flip()&amp;#10;&amp;#10;        ### wait for key response:&amp;#10;        # In blocks with n-back task, participants can press &quot;c&quot; to indicate they saw a target colour and &quot;space&quot; to go to the next word/stimulus.&amp;#10;        # In blocks without n-back task, participants can only press &quot;space&quot; to go to the next word/stimulus.&amp;#10;        # print(&quot;start tracking key responses&quot;)&amp;#10;&amp;#10;        ### start recording responses&amp;#10;        # start &quot;endless&quot; while loop that looks for responses&amp;#10;        continue_trial = True&amp;#10;        trial_start_time = my_trial_clock.getTime()  # Record the start time of the trial&amp;#10;        while continue_trial:&amp;#10;&amp;#10;            # in each iteration, draw word on screen&amp;#10;            stim.draw()&amp;#10;            win.flip()&amp;#10;&amp;#10;            # check for key responses:&amp;#10;            keys = event.getKeys(['space', 'c', 'escape'])&amp;#10;&amp;#10;            # if we recorded a response, check which one.&amp;#10;            # If not, we go  to the next &quot;while&quot; iteration,&amp;#10;            # so I hope this saves us a few dropped frames in the flicker.&amp;#10;            for key in keys:&amp;#10;&amp;#10;                # if participant pressed space bar on their keyboard...&amp;#10;                if key == 'space':&amp;#10;                    # get reaction time&amp;#10;                    curr_duration = my_trial_clock.getTime() * 1000&amp;#10;                    # send trigger for response:&amp;#10;                    # send_trigger(&quot;response_continue&quot;)&amp;#10;                    # break while loop&amp;#10;                    continue_trial = False&amp;#10;&amp;#10;                # if participant pressed button &quot;c&quot; for the first time and it's an n-back condition&amp;#10;                # where they're actually supposed to do that (aka not a reading baseline condition)...&amp;#10;                elif key == 'c' and curr_nback_cond != None and saw_target == False:&amp;#10;                    # get reaction time&amp;#10;                    curr_nback_RT = my_trial_clock.getTime() * 1000&amp;#10;                    # send trigger for response:&amp;#10;                    # send_trigger(&quot;response_target&quot;)&amp;#10;                    # only get first target response, we don't care if they press the button more than once:&amp;#10;                    saw_target = True&amp;#10;&amp;#10;                # If esc is pressed, end the experiment:&amp;#10;                elif key == 'escape':&amp;#10;                    # et_abort_exp()  # shut down eyetrigger and download incremental data&amp;#10;                    # close trigger &amp; close experiment&amp;#10;                    # core.wait(time_after_trigger)&amp;#10;                    # parallel.setData(0)&amp;#10;                    core.wait(0.5)&amp;#10;                    core.quit()&amp;#10;&amp;#10;            # Check for timeout - if more than 1.5, 2 or 2.5 seconds have passed, move to the next trial&amp;#10;            if my_trial_clock.getTime() - trial_start_time &gt;= 1.5 and curr_block in [&quot;Reading_Baseline_training_click&quot;, &quot;Reading_Baseline_main_click&quot;,&amp;#10;                                                                                     &quot;0back_dual_main_click&quot;]:&amp;#10;                curr_duration = 1500&amp;#10;                continue_trial = False&amp;#10;            elif my_trial_clock.getTime() - trial_start_time &gt;= 2 and curr_block == &quot;1back_dual_main_click&quot;:&amp;#10;                curr_duration = 2000&amp;#10;                continue_trial = False&amp;#10;            elif my_trial_clock.getTime() - trial_start_time &gt;= 2.5 and curr_block == &quot;2back_dual_main_click&quot;:&amp;#10;                curr_duration = 2500&amp;#10;                continue_trial = False&amp;#10;&amp;#10;        ### end trial&amp;#10;        # print(&quot;\tend self-paced trial&quot;)&amp;#10;        # stop display of current word &amp; send trial offset trigger&amp;#10;        # win.callOnFlip(send_trigger, &quot;trial_offset&quot;)&amp;#10;&amp;#10;        # check whether response was hit, miss, false alarm or correct rejection&amp;#10;        # they saw a target and there was one: hit&amp;#10;        if curr_nback_cond != None:&amp;#10;            if saw_target and curr_target:&amp;#10;                curr_nback_response = &quot;hit&quot;&amp;#10;            # they didn't see a target but there was one: miss&amp;#10;            elif saw_target == False and curr_target:&amp;#10;                curr_nback_response = &quot;miss&quot;&amp;#10;                curr_nback_RT = None&amp;#10;            # they didn't see a target and there was none: correct rejection&amp;#10;            elif saw_target == False and curr_target == False:&amp;#10;                curr_nback_response = &quot;correct rejection&quot;&amp;#10;                curr_nback_RT = None&amp;#10;            # they saw a target but there was none: false alarm&amp;#10;            elif saw_target and curr_target == False:&amp;#10;                curr_nback_response = &quot;false alarm&quot;&amp;#10;        # if it wasn't an n-back task block:&amp;#10;        else:&amp;#10;            curr_target = None&amp;#10;            curr_nback_response = None&amp;#10;            curr_nback_RT = None&amp;#10;&amp;#10;        ### save everything in output csv&amp;#10;        thisExp.addData('colour', curr_colour)&amp;#10;        thisExp.addData('target', curr_target)&amp;#10;        if curr_block == &quot;0back_dual_main_click&quot;:&amp;#10;            thisExp.addData('curr_0back_target', target_colours_list[1])&amp;#10;        thisExp.addData('nback_response', curr_nback_response)&amp;#10;        thisExp.addData('nback_RT', curr_nback_RT)  # in ms&amp;#10;        thisExp.addData('duration', curr_duration)  # in ms&amp;#10;        thisExp.addData('text_nr', curr_text_nr)&amp;#10;        thisExp.addData('trial_nr', curr_trial_nr)&amp;#10;        thisExp.addData('block_nr', exp_block_counter)&amp;#10;        thisExp.addData('block_name', curr_block)&amp;#10;        thisExp.addData('block_kind', curr_nback_cond)&amp;#10;        # careful, make sure quotes in the strings are escaped using a&amp;#10;        # quote (weird, I know) so it's properly saved in the CSV:&amp;#10;        thisExp.addData('word', escape_quotes(curr_word))&amp;#10;&amp;#10;        # start a new row in the csv&amp;#10;        thisExp.nextEntry()&amp;#10;&amp;#10;        # depending on condition, save response times and words in previously created arrays&amp;#10;        # we need that later for the paced reading tasks&amp;#10;        if curr_block == &quot;Reading_Baseline_main_click&quot;:&amp;#10;            BL_paced_durations.append(curr_duration)&amp;#10;            BL_paced_words.append(curr_word)&amp;#10;        elif curr_block == &quot;0back_dual_main_click&quot;:&amp;#10;            zeroback_paced_durations.append(curr_duration)&amp;#10;            zeroback_paced_words.append(curr_word)&amp;#10;        elif curr_block == &quot;1back_dual_main_click&quot;:&amp;#10;            oneback_paced_durations.append(curr_duration)&amp;#10;            oneback_paced_words.append(curr_word)&amp;#10;        elif curr_block == &quot;2back_dual_main_click&quot;:&amp;#10;            twoback_paced_durations.append(curr_duration)&amp;#10;            twoback_paced_words.append(curr_word)&amp;#10;&amp;#10;        ### IF TESTING MODE ENABLED: end loop after 4 trials&amp;#10;        if expInfo['testing_mode'] == &quot;yes&quot;:&amp;#10;            if trial_idx == 3:&amp;#10;                break&amp;#10;&amp;#10;    print(&quot;finished presenting trials&quot;)&amp;#10;&amp;#10;    # Send end of block trigger:&amp;#10;    # core.wait(time_after_trigger)  # wait 3 ms&amp;#10;    # send block offset trigger&amp;#10;    # send_trigger(&quot;block_offset&quot;)&amp;#10;&amp;#10;    # end current routine&amp;#10;    continueRoutine = False" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="text_blocks" valType="code" updates="None" name="name"/>
      </CodeComponent>
      <CodeComponent name="questions_self_paced" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="##########################################################&amp;#10;#              Text Comprehension Questions              #&amp;#10;##########################################################&amp;#10;&amp;#10;def setup_question(question_text, answers_text):&amp;#10;    question = visual.TextStim(win, text=question_text, pos=(0, 0.2), color=&quot;black&quot;, height=0.03, anchorHoriz='center', alignText='center', wrapWidth=1)&amp;#10;    answers = [visual.TextStim(win, text=ans, pos=(0, 0.1 - i * 0.08), color=&quot;black&quot;, height=0.03, wrapWidth=1, anchorHoriz='center', alignText='center') for i, ans in enumerate(answers_text)]&amp;#10;    return question, answers&amp;#10;&amp;#10;def display_question_and_get_response(question, answers, correct_answer):&amp;#10;    defaultKeyboard.clearEvents()&amp;#10;&amp;#10;    # Set-up time to write into logfile&amp;#10;    question_time = globalClock.getTime()&amp;#10;    &amp;#10;    question.autoDraw = True&amp;#10;    for answer in answers:&amp;#10;        answer.autoDraw = True&amp;#10;    instr_text.autoDraw = True&amp;#10;&amp;#10;    countdown_timer = visual.TextStim(win, text='', pos=(0, -0.25), color=&quot;grey&quot;, height=0.02, anchorHoriz='center', alignText='center', wrapWidth=1)&amp;#10;&amp;#10;    # defaultKeyboard = keyboard.Keyboard()&amp;#10;    chosen_ans = &quot;NA&quot;&amp;#10;    is_correct = &quot;NA&quot;&amp;#10;    button_pressed = &quot;NA&quot;&amp;#10;    response_received = False&amp;#10;&amp;#10;    # Start a clock to track response time&amp;#10;    response_clock = core.Clock()&amp;#10;&amp;#10;    # Countdown from 10 seconds&amp;#10;    while response_clock.getTime() &lt; 10:&amp;#10;        remaining_time = 10 - int(response_clock.getTime())&amp;#10;        countdown_timer.text = f&quot;Zeit: {remaining_time}&quot;&amp;#10;        countdown_timer.draw()&amp;#10;        win.flip()&amp;#10;&amp;#10;        keys = defaultKeyboard.getKeys(['1', '2', '3', '4'], waitRelease=False)&amp;#10;        if keys:&amp;#10;            key_name = keys[0].name  # Get the name of the first key pressed&amp;#10;            button_pressed = key_name&amp;#10;&amp;#10;            # Now, use the key_name to determine the action&amp;#10;            if key_name == '1':&amp;#10;                index = 0  # Corresponds to the first choice&amp;#10;            elif key_name == '2':&amp;#10;                index = 1  # Corresponds to the second choice&amp;#10;            elif key_name == '3':&amp;#10;                index = 2  # Corresponds to the third choice&amp;#10;            elif key_name == '4':&amp;#10;                index = 3  # Corresponds to the fourth choice&amp;#10;            else:&amp;#10;                index = None  # Just in case, not really needed if you're sure about the input keys&amp;#10;&amp;#10;            # Proceed with your logic based on the index&amp;#10;            if index is not None:&amp;#10;                chosen_ans = chr(97 + index)  # Convert index to letter ('a', 'b', 'c', 'd')&amp;#10;                is_correct = chosen_ans == correct_answer  # Assuming correct_answer is defined ('a', 'b', 'c', or 'd')&amp;#10;                for i, answer in enumerate(answers):&amp;#10;                    answer.setColor(&quot;green&quot; if i == index else &quot;black&quot;)&amp;#10;                win.flip()&amp;#10;                core.wait(0.5)  # Ensure the color change is visible&amp;#10;                response_received = True&amp;#10;                break&amp;#10;&amp;#10;    # Hide the countdown timer after it finishes&amp;#10;    countdown_timer.text = ''&amp;#10;    countdown_timer.draw()&amp;#10;    win.flip()&amp;#10;&amp;#10;    # If no response is received within 10 seconds, return &quot;NA&quot;&amp;#10;    if not response_received:&amp;#10;        chosen_ans = &quot;NA&quot;&amp;#10;        is_correct = &quot;NA&quot;&amp;#10;        button_pressed = &quot;NA&quot;&amp;#10;&amp;#10;    return question_time, chosen_ans, is_correct, button_pressed&amp;#10;&amp;#10;def reset_answers(answers):&amp;#10;    for answer in answers:&amp;#10;        answer.setColor(&quot;black&quot;)&amp;#10;    question.autoDraw = False&amp;#10;    instr_text.autoDraw = False&amp;#10;    for answer in answers:&amp;#10;        answer.autoDraw = False&amp;#10;&amp;#10;# Set up instructions&amp;#10;win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;win.flip()&amp;#10;instr_text = visual.TextStim(win, text=&quot;(Bitte benutzen Sie die Tasten 1, 2, 3 und 4, um die richtige Antwort auszuwählen.)&quot;, color=&quot;grey&quot;, pos=(0, -0.3), wrapWidth=2, height=0.018)&amp;#10;event.clearEvents()&amp;#10;&amp;#10;# Assuming skip_questions_paced and other variables are defined&amp;#10;if not skip_questions and training_Qs:&amp;#10;    # Setup for Q1&amp;#10;    Q1_text = reading_bl_tr_Q1&amp;#10;    Q1_answers = reading_bl_tr_Q1_ans&amp;#10;    Q1_correct = reading_bl_tr_Q1_corr&amp;#10;&amp;#10;    question, answers = setup_question(Q1_text, Q1_answers)&amp;#10;    question_time, chosen_ans, is_correct, button_pressed = display_question_and_get_response(question, answers, Q1_correct)&amp;#10;    print(f&quot;Chosen answer for Q1: {chosen_ans}, Correct: {is_correct}&quot;)&amp;#10;    reset_answers(answers)&amp;#10;&amp;#10;    # save data:&amp;#10;    thisExp.addData('global_onset_time', question_time)&amp;#10;    thisExp.addData('question', 'Q1')&amp;#10;    thisExp.addData('button_pressed', button_pressed)&amp;#10;    thisExp.addData('chosen_ans', chosen_ans)&amp;#10;    thisExp.addData('ans_correct', chosen_ans == Q1_correct)&amp;#10;    thisExp.addData('text_nr', curr_text_nr)&amp;#10;    thisExp.addData('block_nr_exp', exp_block_counter+1)&amp;#10;    thisExp.addData('block_name', curr_block)&amp;#10;    thisExp.addData('n-back_level', curr_nback_cond)&amp;#10;&amp;#10;    # start a new row in the csv&amp;#10;    thisExp.nextEntry()&amp;#10;&amp;#10;    # Setup for Q2&amp;#10;    Q2_text = reading_bl_tr_Q2&amp;#10;    Q2_answers = reading_bl_tr_Q2_ans&amp;#10;    Q2_correct = reading_bl_tr_Q2_corr&amp;#10;&amp;#10;    question, answers = setup_question(Q2_text, Q2_answers)&amp;#10;    question_time, chosen_ans, is_correct, button_pressed = display_question_and_get_response(question, answers, Q2_correct)&amp;#10;    print(f&quot;Chosen answer for Q2: {chosen_ans}, Correct: {is_correct}&quot;)&amp;#10;    reset_answers(answers)&amp;#10;&amp;#10;    # save data:&amp;#10;    thisExp.addData('global_onset_time', question_time)&amp;#10;    thisExp.addData('question', 'Q2')&amp;#10;    thisExp.addData('button_pressed', button_pressed)&amp;#10;    thisExp.addData('chosen_ans', chosen_ans)&amp;#10;    thisExp.addData('ans_correct', chosen_ans == Q2_correct)&amp;#10;    thisExp.addData('text_nr', curr_text_nr)&amp;#10;    thisExp.addData('block_nr_exp', exp_block_counter+1)&amp;#10;    thisExp.addData('block_name', curr_block)&amp;#10;    thisExp.addData('n-back_level', curr_nback_cond)&amp;#10;&amp;#10;    # start a new row in the csv&amp;#10;    thisExp.nextEntry()&amp;#10;&amp;#10;    # Setup for Q3&amp;#10;    Q3_text = reading_bl_tr_Q3&amp;#10;    Q3_answers = reading_bl_tr_Q3_ans&amp;#10;    Q3_correct = reading_bl_tr_Q3_corr&amp;#10;&amp;#10;    question, answers = setup_question(Q3_text, Q3_answers)&amp;#10;    question_time, chosen_ans, is_correct, button_pressed = display_question_and_get_response(question, answers, Q3_correct)&amp;#10;    print(f&quot;Chosen answer for Q3: {chosen_ans}, Correct: {is_correct}&quot;)&amp;#10;    reset_answers(answers)&amp;#10;&amp;#10;    # save data:&amp;#10;    thisExp.addData('global_onset_time', question_time)&amp;#10;    thisExp.addData('question', 'Q3')&amp;#10;    thisExp.addData('button_pressed', button_pressed)&amp;#10;    thisExp.addData('chosen_ans', chosen_ans)&amp;#10;    thisExp.addData('ans_correct', chosen_ans == Q3_correct)&amp;#10;    thisExp.addData('text_nr', curr_text_nr)&amp;#10;    thisExp.addData('block_nr_exp', exp_block_counter+1)&amp;#10;    thisExp.addData('block_name', curr_block)&amp;#10;    thisExp.addData('n-back_level', curr_nback_cond)&amp;#10;&amp;#10;    # start a new row in the csv&amp;#10;    thisExp.nextEntry()&amp;#10;&amp;#10;    # go to next block!&amp;#10;    exp_block_counter += 1&amp;#10;    print(f&quot;Going to block {exp_block_counter + 1}/20 now!&quot;)&amp;#10;    continueRoutine = False&amp;#10;&amp;#10;    # If there are still blocks left, go to next one.&amp;#10;    # If not, end loop here:&amp;#10;    if exp_block_counter == 20:&amp;#10;        blocks.finished = True&amp;#10;        &amp;#10;elif not skip_questions and not training_Qs:&amp;#10;    # Setup for Q1&amp;#10;    Q1_text = locals()[curr_text_nr + &quot;_Q1&quot;]&amp;#10;    Q1_answers = locals()[curr_text_nr + &quot;_Q1_ans&quot;]&amp;#10;    Q1_correct = locals()[curr_text_nr + &quot;_Q1_corr&quot;]&amp;#10;&amp;#10;    question, answers = setup_question(Q1_text, Q1_answers)&amp;#10;    question_time, chosen_ans, is_correct, button_pressed = display_question_and_get_response(question, answers, Q1_correct)&amp;#10;    print(f&quot;Chosen answer for Q1: {chosen_ans}, Correct: {is_correct}&quot;)&amp;#10;    reset_answers(answers)&amp;#10;&amp;#10;    # save data:&amp;#10;    thisExp.addData('global_onset_time', question_time)&amp;#10;    thisExp.addData('question', 'Q1')&amp;#10;    thisExp.addData('button_pressed', button_pressed)&amp;#10;    thisExp.addData('chosen_ans', chosen_ans)&amp;#10;    thisExp.addData('ans_correct', chosen_ans == Q1_correct)&amp;#10;    thisExp.addData('text_nr', curr_text_nr)&amp;#10;    thisExp.addData('block_nr_exp', exp_block_counter+1)&amp;#10;    thisExp.addData('block_name', curr_block)&amp;#10;    thisExp.addData('n-back_level', curr_nback_cond)&amp;#10;&amp;#10;    # start a new row in the csv&amp;#10;    thisExp.nextEntry()&amp;#10;&amp;#10;    # Setup for Q2&amp;#10;    Q2_text = locals()[curr_text_nr + &quot;_Q2&quot;]&amp;#10;    Q2_answers = locals()[curr_text_nr + &quot;_Q2_ans&quot;]&amp;#10;    Q2_correct = locals()[curr_text_nr + &quot;_Q2_corr&quot;]&amp;#10;&amp;#10;    question, answers = setup_question(Q2_text, Q2_answers)&amp;#10;    question_time, chosen_ans, is_correct, button_pressed = display_question_and_get_response(question, answers, Q2_correct)&amp;#10;    print(f&quot;Chosen answer for Q2: {chosen_ans}, Correct: {is_correct}&quot;)&amp;#10;    reset_answers(answers)&amp;#10;&amp;#10;    # save data:&amp;#10;    thisExp.addData('global_onset_time', question_time)&amp;#10;    thisExp.addData('question', 'Q2')&amp;#10;    thisExp.addData('button_pressed', button_pressed)&amp;#10;    thisExp.addData('chosen_ans', chosen_ans)&amp;#10;    thisExp.addData('ans_correct', chosen_ans == Q2_correct)&amp;#10;    thisExp.addData('text_nr', curr_text_nr)&amp;#10;    thisExp.addData('block_nr_exp', exp_block_counter+1)&amp;#10;    thisExp.addData('block_name', curr_block)&amp;#10;    thisExp.addData('n-back_level', curr_nback_cond)&amp;#10;&amp;#10;    # start a new row in the csv&amp;#10;    thisExp.nextEntry()&amp;#10;&amp;#10;    # Setup for Q3&amp;#10;    Q3_text = locals()[curr_text_nr + &quot;_Q3&quot;]&amp;#10;    Q3_answers = locals()[curr_text_nr + &quot;_Q3_ans&quot;]&amp;#10;    Q3_correct = locals()[curr_text_nr + &quot;_Q3_corr&quot;]&amp;#10;&amp;#10;    question, answers = setup_question(Q3_text, Q3_answers)&amp;#10;    question_time, chosen_ans, is_correct, button_pressed = display_question_and_get_response(question, answers, Q3_correct)&amp;#10;    print(f&quot;Chosen answer for Q3: {chosen_ans}, Correct: {is_correct}&quot;)&amp;#10;    reset_answers(answers)&amp;#10;&amp;#10;    # save data:&amp;#10;    thisExp.addData('global_onset_time', question_time)&amp;#10;    thisExp.addData('question', 'Q3')&amp;#10;    thisExp.addData('button_pressed', button_pressed)&amp;#10;    thisExp.addData('chosen_ans', chosen_ans)&amp;#10;    thisExp.addData('ans_correct', chosen_ans == Q3_correct)&amp;#10;    thisExp.addData('text_nr', curr_text_nr)&amp;#10;    thisExp.addData('block_nr_exp', exp_block_counter+1)&amp;#10;    thisExp.addData('block_name', curr_block)&amp;#10;    thisExp.addData('n-back_level', curr_nback_cond)&amp;#10;&amp;#10;    # start a new row in the csv&amp;#10;    thisExp.nextEntry()&amp;#10;&amp;#10;    # go to next block!&amp;#10;    exp_block_counter += 1&amp;#10;    print(f&quot;Going to block {exp_block_counter + 1}/20 now!&quot;)&amp;#10;    continueRoutine = False&amp;#10;&amp;#10;    # If there are still blocks left, go to next one.&amp;#10;    # If not, end loop here:&amp;#10;    if exp_block_counter == 20:&amp;#10;        blocks.finished = True" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="questions_self_paced" valType="code" updates="None" name="name"/>
      </CodeComponent>
    </Routine>
    <Routine name="Questions">
      <RoutineSettingsComponent name="Questions" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="Questions" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <CodeComponent name="Q1_self_paced" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="##########################################################&amp;#10;#            Text Comprehension Questions - Q3           #&amp;#10;##########################################################&amp;#10;&amp;#10;### Settings:&amp;#10;# keep background ivory&amp;#10;win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;win.flip()&amp;#10;&amp;#10;# clear buffer of all previously recorded key events:&amp;#10;event.clearEvents()&amp;#10;&amp;#10;# check which kind of block we have&amp;#10;# if there was no text before, we can skip the questions&amp;#10;if skip_questions:&amp;#10;    continueRoutine = False&amp;#10;# if we have a training text, set training questions&amp;#10;elif skip_questions == False and training_Qs:&amp;#10;    Q3 = reading_bl_tr_Q3&amp;#10;    Q3_answers = reading_bl_tr_Q3_ans&amp;#10;    Q3_corr = reading_bl_tr_Q3_corr&amp;#10;    &amp;#10;# if we have a main text, set regular questions&amp;#10;elif skip_questions == False and training_Qs == False:&amp;#10;    # load first question for current text &amp; their respective answers&amp;#10;    Q3 = locals()[curr_text_nr + &quot;_Q3&quot;]&amp;#10;    Q3_answers = locals()[curr_text_nr + &quot;_Q3_ans&quot;]&amp;#10;    Q3_corr = locals()[curr_text_nr + &quot;_Q3_corr&quot;]&amp;#10;&amp;#10;# Define text positions and formatting&amp;#10;question_pos = (0, 3)&amp;#10;answer_xpos = -7 # move questions a bit to the left &amp;#10;answer_ypos = [ 0, -2, -4, -6] # set the y axis positions of all 4 answers&amp;#10;&amp;#10;# Create text stim for the question:&amp;#10;question = visual.TextStim(win, &amp;#10;                           text = Q3, &amp;#10;                           pos = question_pos,&amp;#10;                           color = &quot;black&quot;,&amp;#10;                           height = 0.5,&amp;#10;                           font = &quot;Bookman Old Style&quot;,&amp;#10;                           anchorHoriz = 'center',&amp;#10;                           alignText = 'center', &amp;#10;                           wrapWidth = 10)&amp;#10;# create 1 text stim for each answer option:&amp;#10;answers = [visual.TextStim(win, &amp;#10;                           text = Q3_answers[i], &amp;#10;                           pos = (answer_xpos, answer_ypos[i]), &amp;#10;                           color = &quot;black&quot;, # set all to black as a default&amp;#10;                           height = 0.5, &amp;#10;                           font = &quot;Bookman Old Style&quot;,&amp;#10;                           wrapWidth = 15,&amp;#10;                           anchorHoriz = 'left', &amp;#10;                           alignText = 'center') for i in range(len(Q3_answers))]&amp;#10;# set up instruction text&amp;#10;instr_text = visual.TextStim(win, &amp;#10;                             text = &quot;(Bitte benutzen Sie die Tasten 1, 2, 3 und 4 um die richtige Antwort auszuwählen. Mit der Leertaste können Sie Ihre Auswahl bestätigen.)&quot;,&amp;#10;                             color = &quot;grey&quot;,&amp;#10;                             pos = (0, -10),&amp;#10;                             wrapWidth = 20,&amp;#10;                             height = 0.4,&amp;#10;                             font = &quot;Bookman Old Style&quot;)&amp;#10;                             &amp;#10;### Show all on screen until I set .autoDraw = False&amp;#10;question.autoDraw = True&amp;#10;instr_text.autoDraw = True&amp;#10;for answer in answers:&amp;#10;    answer.autoDraw = True&amp;#10;win.flip()&amp;#10;&amp;#10;&amp;#10;### Record key responses:&amp;#10;Q3_chosen_ans = None&amp;#10;&amp;#10;while True:        &amp;#10;    # if 1 was pressed...&amp;#10;    if event.getKeys(['1']):&amp;#10;        print('\ta')&amp;#10;        # save Q3 answer as a &amp;#10;        Q3_chosen_ans = &quot;a&quot;&amp;#10;        # set font colour of the first answer (answer a) to &amp;#10;        # green and the rest to black:&amp;#10;        answers[0].setColor(&quot;green&quot;)&amp;#10;        for answer in answers[1:]:&amp;#10;            answer.setColor(&quot;black&quot;)&amp;#10;            # draw updated stimulus:&amp;#10;            win.flip()&amp;#10;    # same procedure for all other answer options:&amp;#10;    if event.getKeys(['2']):&amp;#10;        print('\tb')&amp;#10;        Q3_chosen_ans = &quot;b&quot;&amp;#10;        # set font colour of the second answer (answer b) to &amp;#10;        # green and the rest to black:&amp;#10;        answers[1].setColor(&quot;green&quot;)&amp;#10;        for answer in [answers[0]] + answers[2:]:&amp;#10;            answer.setColor(&quot;black&quot;)&amp;#10;            # draw updated stimulus:&amp;#10;            win.flip()&amp;#10;    if event.getKeys(['3']):&amp;#10;        print('\tc')&amp;#10;        Q3_chosen_ans = &quot;c&quot;&amp;#10;        # set font colour of the third answer (answer c) to &amp;#10;        # green and the rest to black:&amp;#10;        answers[2].setColor(&quot;green&quot;)&amp;#10;        for answer in answers[:2] + answers[3:]:&amp;#10;            answer.setColor(&quot;black&quot;)&amp;#10;        # draw updated stimulus:&amp;#10;        win.flip()&amp;#10;    if event.getKeys(['4']):&amp;#10;        print('\td')&amp;#10;        Q3_chosen_ans = &quot;d&quot;&amp;#10;        # set font colour of the fourth answer (answer d) to &amp;#10;        # green and the rest to black:&amp;#10;        answers[3].setColor(&quot;green&quot;)&amp;#10;        for answer in answers[:-1]:&amp;#10;            answer.setColor(&quot;black&quot;)&amp;#10;        # draw updated stimulus &amp;#10;        win.flip()&amp;#10;    # if participant pressed &quot;space&quot;, check whether they chose an answer.&amp;#10;    # if yes, end this routine and go to next question, if not, wait for valid answer.&amp;#10;    elif event.getKeys(['space']) and Q3_chosen_ans != None:&amp;#10;        break&amp;#10;&amp;#10;# print chosen answer for Q3&amp;#10;print(&quot;answer for Q3:&quot; + str(Q3_chosen_ans))&amp;#10;&amp;#10;# check if answer was correct:&amp;#10;if Q3_chosen_ans == Q3_corr: &amp;#10;    print(&quot;\tanswer correct!&quot;)&amp;#10;else: &amp;#10;    print(&quot;\tanswer incorrect!&quot;)&amp;#10;    &amp;#10;# save data:&amp;#10;thisExp.addData('question', 'Q3')&amp;#10;thisExp.addData('chosen_ans', Q3_chosen_ans)&amp;#10;thisExp.addData('ans_correct', Q3_chosen_ans == Q3_corr)&amp;#10;thisExp.addData('text_nr', curr_text_nr)&amp;#10;thisExp.addData('block_nr', exp_block_counter)&amp;#10;thisExp.addData('block_name', curr_block)&amp;#10;thisExp.addData('block_kind', curr_nback_cond)&amp;#10;&amp;#10;# start a new row in the csv&amp;#10;thisExp.nextEntry()&amp;#10;&amp;#10;### End Q3: Set .autoDraw = False to stop showing question &amp; answers&amp;#10;question.autoDraw = False&amp;#10;instr_text.autoDraw = False&amp;#10;for answer in answers:&amp;#10;    answer.autoDraw = False&amp;#10;&amp;#10;# go to next block!&amp;#10;exp_block_counter += 1&amp;#10;print(&quot;Going to block &quot; + str(exp_block_counter + 1) + &quot;/16 now!&quot;)&amp;#10;continueRoutine = False&amp;#10;&amp;#10;# If there are still blocks left, go to next one.&amp;#10;# If not, end loop here:&amp;#10;if exp_block_counter == 16:&amp;#10;    blocks.finished = True&amp;#10;&amp;#10;# when text rating is included, only use this instead of &quot;go to next block&quot;:&amp;#10;# end current routine&amp;#10;#continueRoutine = False" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="##########################################################&amp;#10;#            Text Comprehension Questions - Q3           #&amp;#10;##########################################################&amp;#10;&amp;#10;### Settings:&amp;#10;# keep background ivory&amp;#10;win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;win.flip()&amp;#10;&amp;#10;# clear buffer of all previously recorded key events:&amp;#10;event.clearEvents()&amp;#10;&amp;#10;# check which kind of block we have&amp;#10;# if there was no text before, we can skip the questions&amp;#10;if skip_questions:&amp;#10;    continueRoutine = False&amp;#10;# if we have a training text, set training questions&amp;#10;elif skip_questions == False and training_Qs:&amp;#10;    Q3 = reading_bl_tr_Q3&amp;#10;    Q3_answers = reading_bl_tr_Q3_ans&amp;#10;    Q3_corr = reading_bl_tr_Q3_corr&amp;#10;    &amp;#10;# if we have a main text, set regular questions&amp;#10;elif skip_questions == False and training_Qs == False:&amp;#10;    # load first question for current text &amp; their respective answers&amp;#10;    Q3 = locals()[curr_text_nr + &quot;_Q3&quot;]&amp;#10;    Q3_answers = locals()[curr_text_nr + &quot;_Q3_ans&quot;]&amp;#10;    Q3_corr = locals()[curr_text_nr + &quot;_Q3_corr&quot;]&amp;#10;&amp;#10;if not skip_questions:&amp;#10;    # Define text positions and formatting&amp;#10;    question_pos = (0, 3)&amp;#10;    answer_xpos = -7 # move questions a bit to the left &amp;#10;    answer_ypos = [ 0, -2, -4, -6] # set the y axis positions of all 4 answers&amp;#10;&amp;#10;    # Create text stim for the question:&amp;#10;    question = visual.TextStim(win, &amp;#10;                               text = Q3, &amp;#10;                               pos = question_pos,&amp;#10;                               color = &quot;black&quot;,&amp;#10;                               height = 0.5,&amp;#10;                               font = &quot;Bookman Old Style&quot;,&amp;#10;                               anchorHoriz = 'center',&amp;#10;                               alignText = 'center', &amp;#10;                               wrapWidth = 10)&amp;#10;    # create 1 text stim for each answer option:&amp;#10;    answers = [visual.TextStim(win, &amp;#10;                               text = Q3_answers[i], &amp;#10;                               pos = (answer_xpos, answer_ypos[i]), &amp;#10;                               color = &quot;black&quot;, # set all to black as a default&amp;#10;                               height = 0.5, &amp;#10;                               font = &quot;Bookman Old Style&quot;,&amp;#10;                               wrapWidth = 15,&amp;#10;                               anchorHoriz = 'left', &amp;#10;                               alignText = 'center') for i in range(len(Q3_answers))]&amp;#10;    # set up instruction text&amp;#10;    instr_text = visual.TextStim(win, &amp;#10;                                 text = &quot;(Bitte benutzen Sie die Tasten 1, 2, 3 und 4 um die richtige Antwort auszuwählen. Mit der Leertaste können Sie Ihre Auswahl bestätigen.)&quot;,&amp;#10;                                 color = &quot;grey&quot;,&amp;#10;                                 pos = (0, -10),&amp;#10;                                 wrapWidth = 20,&amp;#10;                                 height = 0.4,&amp;#10;                                 font = &quot;Bookman Old Style&quot;)&amp;#10;                                 &amp;#10;    ### Show all on screen until I set .autoDraw = False&amp;#10;    question.autoDraw = True&amp;#10;    instr_text.autoDraw = True&amp;#10;    for answer in answers:&amp;#10;        answer.autoDraw = True&amp;#10;    win.flip()&amp;#10;&amp;#10;&amp;#10;    ### Record key responses:&amp;#10;    Q3_chosen_ans = None&amp;#10;&amp;#10;    while True:        &amp;#10;        # if 1 was pressed...&amp;#10;        if event.getKeys(['1']):&amp;#10;            print('\ta')&amp;#10;            # save Q3 answer as a &amp;#10;            Q3_chosen_ans = &quot;a&quot;&amp;#10;            # set font colour of the first answer (answer a) to &amp;#10;            # green and the rest to black:&amp;#10;            answers[0].setColor(&quot;green&quot;)&amp;#10;            for answer in answers[1:]:&amp;#10;                answer.setColor(&quot;black&quot;)&amp;#10;                # draw updated stimulus:&amp;#10;                win.flip()&amp;#10;        # same procedure for all other answer options:&amp;#10;        if event.getKeys(['2']):&amp;#10;            print('\tb')&amp;#10;            Q3_chosen_ans = &quot;b&quot;&amp;#10;            # set font colour of the second answer (answer b) to &amp;#10;            # green and the rest to black:&amp;#10;            answers[1].setColor(&quot;green&quot;)&amp;#10;            for answer in [answers[0]] + answers[2:]:&amp;#10;                answer.setColor(&quot;black&quot;)&amp;#10;                # draw updated stimulus:&amp;#10;                win.flip()&amp;#10;        if event.getKeys(['3']):&amp;#10;            print('\tc')&amp;#10;            Q3_chosen_ans = &quot;c&quot;&amp;#10;            # set font colour of the third answer (answer c) to &amp;#10;            # green and the rest to black:&amp;#10;            answers[2].setColor(&quot;green&quot;)&amp;#10;            for answer in answers[:2] + answers[3:]:&amp;#10;                answer.setColor(&quot;black&quot;)&amp;#10;            # draw updated stimulus:&amp;#10;            win.flip()&amp;#10;        if event.getKeys(['4']):&amp;#10;            print('\td')&amp;#10;            Q3_chosen_ans = &quot;d&quot;&amp;#10;            # set font colour of the fourth answer (answer d) to &amp;#10;            # green and the rest to black:&amp;#10;            answers[3].setColor(&quot;green&quot;)&amp;#10;            for answer in answers[:-1]:&amp;#10;                answer.setColor(&quot;black&quot;)&amp;#10;            # draw updated stimulus &amp;#10;            win.flip()&amp;#10;        # if participant pressed &quot;space&quot;, check whether they chose an answer.&amp;#10;        # if yes, end this routine and go to next question, if not, wait for valid answer.&amp;#10;        elif event.getKeys(['space']) and Q3_chosen_ans != None:&amp;#10;            break&amp;#10;&amp;#10;    # print chosen answer for Q3&amp;#10;    print(&quot;answer for Q3:&quot; + str(Q3_chosen_ans))&amp;#10;&amp;#10;    # check if answer was correct:&amp;#10;    if Q3_chosen_ans == Q3_corr: &amp;#10;        print(&quot;\tanswer correct!&quot;)&amp;#10;    else: &amp;#10;        print(&quot;\tanswer incorrect!&quot;)&amp;#10;        &amp;#10;    # save data:&amp;#10;    thisExp.addData('question', 'Q3')&amp;#10;    thisExp.addData('chosen_ans', Q3_chosen_ans)&amp;#10;    thisExp.addData('ans_correct', Q3_chosen_ans == Q3_corr)&amp;#10;    thisExp.addData('text_nr', curr_text_nr)&amp;#10;    thisExp.addData('block_nr', exp_block_counter)&amp;#10;    thisExp.addData('block_name', curr_block)&amp;#10;    thisExp.addData('block_kind', curr_nback_cond)&amp;#10;&amp;#10;    # start a new row in the csv&amp;#10;    thisExp.nextEntry()&amp;#10;&amp;#10;    ### End Q3: Set .autoDraw = False to stop showing question &amp; answers&amp;#10;    question.autoDraw = False&amp;#10;    instr_text.autoDraw = False&amp;#10;    for answer in answers:&amp;#10;        answer.autoDraw = False&amp;#10;&amp;#10;    # go to next block!&amp;#10;    exp_block_counter += 1&amp;#10;    print(&quot;Going to block &quot; + str(exp_block_counter + 1) + &quot;/16 now!&quot;)&amp;#10;    continueRoutine = False&amp;#10;&amp;#10;    # If there are still blocks left, go to next one.&amp;#10;    # If not, end loop here:&amp;#10;    if exp_block_counter == 16:&amp;#10;        blocks.finished = True&amp;#10;&amp;#10;# when text rating is included, only use this instead of &quot;go to next block&quot;:&amp;#10;# end current routine&amp;#10;#continueRoutine = False" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="True" valType="bool" updates="None" name="disabled"/>
        <Param val="Q1_self_paced" valType="code" updates="None" name="name"/>
      </CodeComponent>
    </Routine>
    <Routine name="warning_task_change">
      <RoutineSettingsComponent name="warning_task_change" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="warning_task_change" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <CodeComponent name="warning_sign" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="### Show warning sign if task changes&amp;#10;&amp;#10;# If task in last block (curr_block) is not the same as the next one, show warning.&amp;#10;&amp;#10;# To check this, we compare the first letter in the block names.&amp;#10;# I won't show a warning if it switches from rectangles to words,&amp;#10;# I think people will notice it's different.&amp;#10;&amp;#10;if exp_block_counter &lt; 16: # if there are still blocks left&amp;#10;    if curr_block[0] != all_blocks[exp_block_counter][0]:&amp;#10;&amp;#10;        # create ImageStim object&amp;#10;        curr_instr_pic = visual.ImageStim(win, &amp;#10;                                      size = (10, 10),&amp;#10;                                      pos = (0, 0),&amp;#10;                                      image = warning_sign) # set path to image here&amp;#10;&amp;#10;        # draw image on screen&amp;#10;        curr_instr_pic.draw()&amp;#10;        win.flip()&amp;#10;&amp;#10;        # Wait for 4 seconds&amp;#10;        core.wait(4)&amp;#10;        win.flip()&amp;#10;else: print(&quot;task in current block&quot;, curr_block, &quot;is the same as in next block - skipping warning sign!&quot;)&amp;#10;&amp;#10;# go to next slide&amp;#10;continueRoutine = False" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="True" valType="bool" updates="None" name="disabled"/>
        <Param val="warning_sign" valType="code" updates="None" name="name"/>
      </CodeComponent>
    </Routine>
    <Routine name="text_blocks_paced">
      <RoutineSettingsComponent name="text_blocks_paced" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="text_blocks_paced" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <CodeComponent name="paced_blocks" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="#################################################&amp;#10;#            Blocks with text – paced           #&amp;#10;#################################################&amp;#10;# this routine is for all blocks with texts that are paced, i.e., visually presented without space bar&amp;#10;&amp;#10;#---------- Calculate duration of words based on previous block ----------&amp;#10;# We collected RTs &amp; words from the self-paced block of each condition&amp;#10;# for the training, we only use data from the reading BL since there is no separate training for 1- and 2-back&amp;#10;&amp;#10;# we calculate letter duration based on condition since participants need more time for n-back tasks than for baseline reading&amp;#10;# BL reading blocks are based on duration during self-paced BL reading&amp;#10;# 1- and 2-back blocks are based on their respective self-paced version&amp;#10;&amp;#10;# get block kind&amp;#10;curr_block = all_blocks[exp_block_counter]&amp;#10;&amp;#10;if curr_block in [&quot;Reading_Baseline_main_no_click&quot;, &quot;Reading_Baseline_training_no_click&quot;]:&amp;#10;&amp;#10;    # exclude all RTs where participant was way too fast (&lt; 50 ms) or&amp;#10;    # too slow (&gt; 2s)&amp;#10;    #print(&quot;\tBL_paced_durations:&quot;, BL_paced_durations)&amp;#10;    #print(&quot;\tBL_paced_words:&quot;, BL_paced_words)&amp;#10;&amp;#10;    filtered_durations_BL = []&amp;#10;    filtered_words_BL = []&amp;#10;    for duration, word in zip(BL_paced_durations, BL_paced_words):&amp;#10;        if 50 &lt;= duration &lt;= 1500:&amp;#10;            filtered_durations_BL.append(duration)&amp;#10;            filtered_words_BL.append(word)&amp;#10;    # print(&quot;\tfiltered_durations_BL:&quot;, filtered_durations_BL)&amp;#10;    # print(&quot;\tfiltered_words_BL:&quot;, filtered_words_BL)&amp;#10;&amp;#10;    # Now get number of letters (not words, I want to know how fast they read 1 letter on average!):&amp;#10;    letters_total_BL = sum(len(word) for word in filtered_words_BL)&amp;#10;    # print(&quot;\tletters_total_BL:&quot;, letters_total_BL)&amp;#10;    # also get time it took in total to read them all:&amp;#10;    reading_time_total_BL = sum(filtered_durations_BL)  # in ms&amp;#10;&amp;#10;    # Now check how many words / min they read on average.&amp;#10;    # reading_speed_wpm = words_total / (reading_time_total/60000)&amp;#10;    # print(&quot;reading speed in words / min:&quot; + str(reading_speed_wpm))&amp;#10;&amp;#10;    # Check average RT / letter&amp;#10;    RT_per_letter_baseline = reading_time_total_BL / letters_total_BL&amp;#10;    print(&quot;\taverage RT per letter in ms:&quot;, RT_per_letter_baseline)&amp;#10;&amp;#10;    # save this in the output csv:&amp;#10;    thisExp.addData('RT_per_letter_baseline', RT_per_letter_baseline)&amp;#10;&amp;#10;elif curr_block in [&quot;0back_dual_main_no_click&quot;]:&amp;#10;&amp;#10;    # exclude all RTs where participant was way too fast (&lt; 50 ms) or&amp;#10;    # too slow (&gt; 2s)&amp;#10;    # print(&quot;\t0back_paced_durations:&quot;, zeroback_paced_durations)&amp;#10;    # print(&quot;\t0back_paced_words:&quot;, zeroback_paced_words)&amp;#10;&amp;#10;    filtered_durations_0back = []&amp;#10;    filtered_words_0back = []&amp;#10;    for duration, word in zip(zeroback_paced_durations, zeroback_paced_words):&amp;#10;        if 50 &lt;= duration &lt;= 1500:&amp;#10;            filtered_durations_0back.append(duration)&amp;#10;            filtered_words_0back.append(word)&amp;#10;    # print(&quot;\tfiltered_durations_BL:&quot;, filtered_durations_BL)&amp;#10;    # print(&quot;\tfiltered_words_BL:&quot;, filtered_words_BL)&amp;#10;&amp;#10;    # Now get number of letters (not words, I want to know how fast they read 1 letter on average!):&amp;#10;    letters_total_0back = sum(len(word) for word in filtered_words_0back)&amp;#10;    # print(&quot;\tletters_total_0back:&quot;, letters_total_0back)&amp;#10;    # also get time it took in total to read them all:&amp;#10;    reading_time_total_0back = sum(filtered_durations_0back)  # in ms&amp;#10;&amp;#10;    # Now check how many words / min they read on average.&amp;#10;    # reading_speed_wpm = words_total / (reading_time_total/60000)&amp;#10;    # print(&quot;reading speed in words / min:&quot; + str(reading_speed_wpm))&amp;#10;&amp;#10;    # Check average RT / letter&amp;#10;    RT_per_letter_0back = reading_time_total_0back / letters_total_0back&amp;#10;    print(&quot;\taverage RT per letter in ms 0-back:&quot;, RT_per_letter_0back)&amp;#10;&amp;#10;    # save this in the output csv:&amp;#10;    thisExp.addData('RT_per_letter_0back', RT_per_letter_0back)&amp;#10;&amp;#10;elif curr_block in [&quot;1back_dual_main_no_click&quot;]:&amp;#10;&amp;#10;    # exclude all RTs where participant was way too fast (&lt; 50 ms) or&amp;#10;    # way too slow (&gt; 2s), also remove the corresponding words from vis_task_words&amp;#10;    # print(&quot;\t1back_paced_durations:&quot;, oneback_paced_durations)&amp;#10;    # print(&quot;\t1back_paced_words:&quot;, oneback_paced_words)&amp;#10;&amp;#10;    filtered_durations_1bck = []&amp;#10;    filtered_words_1bck = []&amp;#10;    for duration, word in zip(oneback_paced_durations, oneback_paced_words):&amp;#10;        if 50 &lt;= duration &lt;= 2000:&amp;#10;            filtered_durations_1bck.append(duration)&amp;#10;            filtered_words_1bck.append(word)&amp;#10;    # print(&quot;\tfiltered_durations_1bck:&quot;, filtered_durations_1bck)&amp;#10;    # print(&quot;\tfiltered_words_1bck:&quot;, filtered_words_1bck)&amp;#10;&amp;#10;    # Now get number of letters (not words, I want to know how fast they read 1 letter on average!):&amp;#10;    letters_total_1bck = sum(len(word) for word in filtered_words_1bck)&amp;#10;    # print(&quot;\tletters_total_1bck:&quot;, letters_total_1bck)&amp;#10;    # also get time it took in total to read them all:&amp;#10;    reading_time_total_1bck = sum(filtered_durations_1bck)  # in ms&amp;#10;&amp;#10;    # Now check how many words / min they read on average.&amp;#10;    # reading_speed_wpm = words_total / (reading_time_total/60000)&amp;#10;    # print(&quot;reading speed in words / min:&quot; + str(reading_speed_wpm))&amp;#10;&amp;#10;    # Check average RT / letter&amp;#10;    RT_per_letter_1bck = reading_time_total_1bck / letters_total_1bck&amp;#10;    print(&quot;\taverage RT per letter in ms:&quot;, RT_per_letter_1bck)&amp;#10;&amp;#10;    # save this in the output csv:&amp;#10;    thisExp.addData('RT_per_letter_1bck', RT_per_letter_1bck)&amp;#10;&amp;#10;elif curr_block in [&quot;2back_dual_main_no_click&quot;]:&amp;#10;&amp;#10;    # exclude all RTs where participant was way too fast (&lt; 50 ms) or&amp;#10;    # way too slow (&gt; 2s), also remove the corresponding words from vis_task_words&amp;#10;    # print(&quot;\t2back_paced_durations:&quot;, twoback_paced_durations)&amp;#10;    # print(&quot;\t2back_paced_words:&quot;, twoback_paced_words)&amp;#10;&amp;#10;    filtered_durations_2bck = []&amp;#10;    filtered_words_2bck = []&amp;#10;    for duration, word in zip(twoback_paced_durations, twoback_paced_words):&amp;#10;        if 50 &lt;= duration &lt;= 2500:&amp;#10;            filtered_durations_2bck.append(duration)&amp;#10;            filtered_words_2bck.append(word)&amp;#10;    # print(&quot;\tfiltered_durations_2bck:&quot;, filtered_durations_2bck)&amp;#10;    # print(&quot;\tfiltered_words_2bck:&quot;, filtered_words_2bck)&amp;#10;&amp;#10;    # Now get number of letters (not words, I want to know how fast they read 1 letter on average!):&amp;#10;    letters_total_2bck = sum(len(word) for word in filtered_words_2bck)&amp;#10;    # print(&quot;\tletters_total_2bck:&quot;, letters_total_2bck)&amp;#10;    # also get time it took in total to read them all:&amp;#10;    reading_time_total_2bck = sum(filtered_durations_2bck)  # in ms&amp;#10;&amp;#10;    # Now check how many words / min they read on average.&amp;#10;    # reading_speed_wpm = words_total / (reading_time_total/60000)&amp;#10;    # print(&quot;reading speed in words / min:&quot; + str(reading_speed_wpm))&amp;#10;&amp;#10;    # Check average RT / letter&amp;#10;    RT_per_letter_2bck = reading_time_total_2bck / letters_total_2bck&amp;#10;    print(&quot;\taverage RT per letter in ms:&quot;, RT_per_letter_2bck)&amp;#10;&amp;#10;    # save this in the output csv:&amp;#10;    thisExp.addData('RT_per_letter_2bck', RT_per_letter_2bck)&amp;#10;&amp;#10;# keep background ivory&amp;#10;win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;win.flip()&amp;#10;&amp;#10;# ----------------------------------&amp;#10;&amp;#10;# clear buffer of all previously recorded key events:&amp;#10;event.clearEvents()&amp;#10;&amp;#10;### Prepare stimuli:&amp;#10;&amp;#10;# Check whether it's a block that is self-paced&amp;#10;# Also, if current block is a non-text block, skip this routine.&amp;#10;if curr_block in [&quot;click_training&quot;, &quot;1back_single_training1&quot;, &quot;1back_single_training2&quot;,&amp;#10;                  &quot;2back_single_training1&quot;, &quot;2back_single_training2&quot;,&amp;#10;                  &quot;Reading_Baseline_main_click&quot;, &quot;1back_dual_main_click&quot;, &quot;2back_dual_main_click&quot;, &quot;Reading_Baseline_training_click&quot;,&amp;#10;                  &quot;1back_single_main_no_click&quot;, &quot;2back_single_main_no_click&quot;, &quot;0back_single_training&quot;, &quot;0back_dual_main_click&quot;]:&amp;#10;    print(f&quot;this is block {curr_block}&quot;)&amp;#10;    print(&quot;\tskipping paced text routine&quot;)&amp;#10;    # skip questions &amp; end current routine&amp;#10;    skip_questions_paced = True&amp;#10;    continueRoutine = False&amp;#10;    # break&amp;#10;&amp;#10;# if it's the paced reading training block, prepare training stimuli:&amp;#10;elif curr_block == &quot;Reading_Baseline_training_no_click&quot;:&amp;#10;    print(f&quot;start preparing block {curr_block}&quot;)&amp;#10;&amp;#10;    # keep background ivory&amp;#10;    win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;    win.flip()&amp;#10;&amp;#10;    ### Show instructions&amp;#10;    # set instruction text&amp;#10;    instr_text = locals()[&quot;instr_&quot; + curr_block]&amp;#10;    # create text box&amp;#10;    instr_text_stim = visual.TextStim(win,&amp;#10;                                      text=instr_text,&amp;#10;                                      height=0.025,  # font height relative to height of screen&amp;#10;                                      pos=(0, 0),  # move up a bit&amp;#10;                                      color=&quot;black&quot;)&amp;#10;&amp;#10;    # show instructions on screen&amp;#10;    win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;    instr_text_stim.draw()&amp;#10;    win.flip()&amp;#10;    core.wait(3)  # wait for 3s before starting response window&amp;#10;&amp;#10;    # display the text on screen&amp;#10;    while True:&amp;#10;        # keep background ivory&amp;#10;        win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;        instr_text_stim.draw()&amp;#10;        win.flip()&amp;#10;        # end showing screen if participant presses space&amp;#10;        if 'space' in event.getKeys():&amp;#10;            break&amp;#10;&amp;#10;    # clear buffer of all previously recorded key events:&amp;#10;    event.clearEvents()&amp;#10;&amp;#10;    ### get training text&amp;#10;    curr_text_training = reading_bl_tr_text_no_click&amp;#10;    curr_text_nr = &quot;Reading_Baseline_training_no_click&quot;&amp;#10;    curr_text = curr_text_training&amp;#10;    curr_nback_cond = None&amp;#10;    # show training questions&amp;#10;    skip_questions_paced = False&amp;#10;    training_Qs_paced = True&amp;#10;&amp;#10;    # get list with targets &amp; list with colours&amp;#10;    curr_targets = all_target_lists[exp_block_counter]&amp;#10;    curr_colours = all_colour_lists[exp_block_counter]&amp;#10;&amp;#10;    # compute RTs using participant's average reading speed / letter – old, based on linear increase of RTs,&amp;#10;    # feels very unnatural however&amp;#10;    # curr_durations = [len(word) * RT_per_letter_baseline for word in curr_text]  # in ms&amp;#10;&amp;#10;    # compute RTs using participant's average reading speed / letter&amp;#10;    # we define a minimum and a maximum duration for each word&amp;#10;    # the minimum is based on 5 x RT per letter in the respective condition&amp;#10;    # the max duration is based on a time-out of 1.5 s in the reading baseline condition&amp;#10;    minimum_duration = 5 * RT_per_letter_baseline&amp;#10;    maximum_duration = 1500&amp;#10;    curr_durations = []&amp;#10;    for word in curr_text:&amp;#10;        # this is an absolute value based on estimates of how long you need to feel comfortable reading a word on&amp;#10;        # screen in a paced task&amp;#10;        # duration = RT_per_letter_baseline * math.log((len(word))) + 300&amp;#10;        # more flexible solution:&amp;#10;        duration = RT_per_letter_baseline * math.log((len(word))) + 4 * RT_per_letter_baseline&amp;#10;        if duration &lt; maximum_duration:&amp;#10;            curr_durations.append(max(duration, minimum_duration))&amp;#10;        else:&amp;#10;            curr_durations.append(maximum_duration)&amp;#10;&amp;#10;    # print(f&quot;\tdurations for paced task training block: {curr_durations}&quot;)&amp;#10;&amp;#10;    # we also need the start time (let's set it as current time&amp;#10;    # at this point in the script):&amp;#10;    start_time = core.getTime()&amp;#10;&amp;#10;    ### change background colour&amp;#10;    win.setColor(dark_bg_col, colorSpace='rgb')&amp;#10;    win.flip()&amp;#10;&amp;#10;# if it's one of the &quot;normal&quot; main blocks, prepare main block stimuli:&amp;#10;elif curr_block in [&quot;Reading_Baseline_main_no_click&quot;, &quot;0back_dual_main_no_click&quot;,&amp;#10;                    &quot;1back_dual_main_no_click&quot;, &quot;2back_dual_main_no_click&quot;]:&amp;#10;    print(f&quot;start preparing block {curr_block}&quot;)&amp;#10;&amp;#10;    # keep background ivory&amp;#10;    win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;    win.flip()&amp;#10;&amp;#10;    ### Show instructions&amp;#10;    # only add image, if it's a 0-, 1- or 2-back block where participants have to press &quot;c&quot;&amp;#10;    if curr_block == &quot;Reading_Baseline_main_no_click&quot;:&amp;#10;&amp;#10;        # set instruction text&amp;#10;        instr_text = locals()[&quot;instr_&quot; + curr_block]&amp;#10;        # create text box&amp;#10;        instr_text_stim = visual.TextStim(win,&amp;#10;                                          text=instr_text,&amp;#10;                                          height=0.025,  # font height relative to height of screen&amp;#10;                                          pos=(0, 0),  # move up a bit&amp;#10;                                          color=&quot;black&quot;)&amp;#10;&amp;#10;        # show instructions on screen&amp;#10;        win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;        instr_text_stim.draw()&amp;#10;        win.flip()&amp;#10;        core.wait(3)  # wait for 3s before starting response window&amp;#10;&amp;#10;        # Display the text on screen&amp;#10;        while True:&amp;#10;            instr_text_stim.draw()&amp;#10;            win.flip()&amp;#10;            # end showing screen if participant presses space&amp;#10;            if 'space' in event.getKeys():&amp;#10;                break&amp;#10;&amp;#10;        # get text nr:&amp;#10;        curr_text_nr = all_texts_nrs_list[exp_block_counter]&amp;#10;        curr_text = locals()[curr_text_nr]&amp;#10;&amp;#10;        # compute RTs using participant's average reading speed / letter – old, based on linear increase of RTs,&amp;#10;        # feels very unnatural however&amp;#10;        # curr_durations = [len(word) * RT_per_letter_baseline for word in curr_text]  # in ms&amp;#10;&amp;#10;        # compute RTs using participant's average reading speed / letter&amp;#10;        # we define a minimum and a maximum duration for each word&amp;#10;        # the minimum is based on 5 x RT per letter in the respective condition&amp;#10;        # the max duration is based on a time-out of 1.5 s in the reading baseline condition&amp;#10;        minimum_duration = 5 * RT_per_letter_baseline&amp;#10;        maximum_duration = 1500&amp;#10;        curr_durations = []&amp;#10;        for word in curr_text:&amp;#10;            # this is an absolute value based on estimates of how long you need to feel comfortable reading a word on&amp;#10;            # screen in a paced task&amp;#10;            # duration = RT_per_letter_baseline * math.log((len(word))) + 300&amp;#10;            # more flexible solution:&amp;#10;            duration = RT_per_letter_baseline * math.log((len(word))) + 4 * RT_per_letter_baseline&amp;#10;            if duration &lt; maximum_duration:&amp;#10;                curr_durations.append(max(duration, minimum_duration))&amp;#10;            else:&amp;#10;                curr_durations.append(maximum_duration)&amp;#10;&amp;#10;        # print(f&quot;\tdurations for paced baseline block: {curr_durations}&quot;)&amp;#10;&amp;#10;        ### change background colour&amp;#10;        win.setColor(dark_bg_col, colorSpace='rgb')&amp;#10;        win.flip()&amp;#10;&amp;#10;    elif curr_block == &quot;0back_dual_main_no_click&quot;:&amp;#10;        # create text boxes&amp;#10;        instr_text_stim1 = visual.TextStim(win,&amp;#10;                                           text=locals()[&quot;instr_0back_dual_main_no_click1&quot;],&amp;#10;                                           height=0.025,&amp;#10;                                           pos=(0, 0.3),  # move instructions up a bit&amp;#10;                                           color=&quot;black&quot;)&amp;#10;        instr_text_stim2 = visual.TextStim(win,&amp;#10;                                           text=locals()[&quot;instr_0back_dual_main_no_click2&quot;],&amp;#10;                                           height=0.025,&amp;#10;                                           pos=(0, -0.35),  # move instructions down a bit&amp;#10;                                           color=&quot;black&quot;)&amp;#10;        # create &quot;empty&quot; circle as stimulus&amp;#10;        instr_colour_circle_stim = visual.Circle(win=win,&amp;#10;                                                 radius=0.065,&amp;#10;                                                 pos=(0, 0.1))  # move circle slightly down&amp;#10;&amp;#10;        # set current target colour as colour of circle:&amp;#10;        instr_colour_circle_stim.fillColor = target_colours_list[2]&amp;#10;&amp;#10;        # create ImageStim object&amp;#10;        curr_instr_pic = visual.ImageStim(win,&amp;#10;                                          size=(0.55, 0.25),&amp;#10;                                          pos=(0, -0.15),&amp;#10;                                          image=locals()[&quot;instr_pic_0back&quot;])  # set path to image here&amp;#10;&amp;#10;        # show instructions&amp;#10;        win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;        instr_text_stim1.draw()&amp;#10;        instr_text_stim2.draw()&amp;#10;        instr_colour_circle_stim.draw()&amp;#10;        curr_instr_pic.draw()&amp;#10;        win.flip()&amp;#10;        core.wait(3)  # wait for 3s before starting response window&amp;#10;&amp;#10;        # display the text &amp; the circle on screen until Space is pressed&amp;#10;        while True:&amp;#10;            instr_text_stim1.draw()&amp;#10;            instr_text_stim2.draw()&amp;#10;            instr_colour_circle_stim.draw()&amp;#10;            curr_instr_pic.draw()&amp;#10;            win.flip()&amp;#10;            # end screen if participant presses space&amp;#10;            if event.getKeys(['space']):&amp;#10;                break&amp;#10;&amp;#10;        # get text nr:&amp;#10;        curr_text_nr = all_texts_nrs_list[exp_block_counter]&amp;#10;        curr_text = locals()[curr_text_nr]&amp;#10;&amp;#10;        # compute RTs using participant's average reading speed / letter&amp;#10;        # we define a minimum and a maximum duration for each word&amp;#10;        # the minimum is based on 5 x RT per letter in the respective condition&amp;#10;        # the max duration is based on a time-out of 1.5 s in the 0-back condition&amp;#10;        minimum_duration = 5 * RT_per_letter_0back&amp;#10;        maximum_duration = 1500&amp;#10;        curr_durations = []&amp;#10;        for word in curr_text:&amp;#10;            # this is an absolute value based on estimates of how long you need to feel comfortable reading a&amp;#10;            # word on screen in a paced task&amp;#10;            # duration = RT_per_letter_baseline * math.log((len(word))) + 300 more&amp;#10;            # more flexible solution:&amp;#10;            duration = RT_per_letter_0back * math.log((len(word))) + 4 * RT_per_letter_0back&amp;#10;            if duration &lt; maximum_duration:&amp;#10;                curr_durations.append(max(duration, minimum_duration))&amp;#10;            else:&amp;#10;                curr_durations.append(maximum_duration)&amp;#10;&amp;#10;        # Latency factor of an incremental increase (increment per trial = 3 ms) added over duration of entire&amp;#10;        # block assuming that participants get tired of the course of a 300 words block and thus need a bit more&amp;#10;        # time:&amp;#10;        # Increment of 3 ms per trial&amp;#10;        increment_per_trial = 3&amp;#10;        for i in range(len(curr_durations)):&amp;#10;            # Calculate incremental increase for current trial&amp;#10;            increment = i * increment_per_trial&amp;#10;            # Add incremental increase to current trial's duration&amp;#10;            curr_durations[i] += increment&amp;#10;&amp;#10;        ### change background colour&amp;#10;        win.setColor(dark_bg_col, colorSpace='rgb')&amp;#10;        win.flip()&amp;#10;&amp;#10;    elif curr_block in [&quot;1back_dual_main_no_click&quot;, &quot;2back_dual_main_no_click&quot;]:&amp;#10;&amp;#10;        # set instruction text&amp;#10;        instr_text = locals()[&quot;instr_&quot; + curr_block]&amp;#10;        # create text box&amp;#10;        instr_text_stim = visual.TextStim(win,&amp;#10;                                          text=instr_text,&amp;#10;                                          height=0.025,  # font height relative to height of screen&amp;#10;                                          pos=(0, 0.2),  # move up a bit&amp;#10;                                          color=&quot;black&quot;)&amp;#10;        # create ImageStim object&amp;#10;        curr_instr_pic = visual.ImageStim(win,&amp;#10;                                          size=(0.8, 0.3),&amp;#10;                                          pos=(0, -0.2),&amp;#10;                                          image=locals()[&quot;instr_pic_&quot; + curr_block])  # set path to image here&amp;#10;&amp;#10;        # show instructions on screen&amp;#10;        win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;        instr_text_stim.draw()&amp;#10;        curr_instr_pic.draw()&amp;#10;        win.flip()&amp;#10;        core.wait(3)  # wait for 3s before starting response window&amp;#10;&amp;#10;        # Display the text on screen&amp;#10;        while True:&amp;#10;            instr_text_stim.draw()&amp;#10;            curr_instr_pic.draw()&amp;#10;            win.flip()&amp;#10;            # end showing screen if participant presses space&amp;#10;            if 'space' in event.getKeys():&amp;#10;                break&amp;#10;&amp;#10;        # get text nr:&amp;#10;        curr_text_nr = all_texts_nrs_list[exp_block_counter]&amp;#10;        curr_text = locals()[curr_text_nr]&amp;#10;        # compute RTs using participant's average reading speed / letter&amp;#10;        if curr_block == &quot;1back_dual_main_no_click&quot;:&amp;#10;            # curr_durations = [len(word) * RT_per_letter_1bck for word in curr_text]  # in ms&amp;#10;&amp;#10;            # compute RTs using participant's average reading speed / letter&amp;#10;            # we define a minimum and a maximum duration for each word&amp;#10;            # the minimum is based on 5 x RT per letter in the respective condition&amp;#10;            # the max duration is based on a time-out of 2 s in the 1-back condition&amp;#10;            minimum_duration = 5 * RT_per_letter_1bck&amp;#10;            maximum_duration = 2000&amp;#10;            curr_durations = []&amp;#10;            for word in curr_text:&amp;#10;                # this is an absolute value based on estimates of how long you need to feel comfortable reading a&amp;#10;                # word on screen in a paced task&amp;#10;                # duration = RT_per_letter_baseline * math.log((len(word))) + 300 more&amp;#10;                # more flexible solution:&amp;#10;                duration = RT_per_letter_1bck * math.log((len(word))) + 4 * RT_per_letter_1bck&amp;#10;                if duration &lt; maximum_duration:&amp;#10;                    curr_durations.append(max(duration, minimum_duration))&amp;#10;                else:&amp;#10;                    curr_durations.append(maximum_duration)&amp;#10;&amp;#10;            # Latency factor of an incremental increase (increment per trial = 3 ms) added over duration of entire&amp;#10;            # block assuming that participants get tired of the course of a 300 words block and thus need a bit more&amp;#10;            # time:&amp;#10;            # Increment of 3 ms per trial&amp;#10;            increment_per_trial = 3&amp;#10;            for i in range(len(curr_durations)):&amp;#10;                # Calculate incremental increase for current trial&amp;#10;                increment = i * increment_per_trial&amp;#10;                # Add incremental increase to current trial's duration&amp;#10;                curr_durations[i] += increment&amp;#10;&amp;#10;        elif curr_block == &quot;2back_dual_main_no_click&quot;:&amp;#10;            minimum_duration = 5 * RT_per_letter_2bck&amp;#10;            maximum_duration = 2000&amp;#10;            curr_durations = []&amp;#10;            for word in curr_text:&amp;#10;                # this is an absolute value based on estimates of how long you need to feel comfortable reading a word on&amp;#10;                # screen in a paced task&amp;#10;                # duration = RT_per_letter_baseline * math.log((len(word))) + 300&amp;#10;                # more flexible solution:&amp;#10;                duration = RT_per_letter_2bck * math.log((len(word))) + 4 * RT_per_letter_2bck&amp;#10;                if duration &lt; maximum_duration:&amp;#10;                    curr_durations.append(max(duration, minimum_duration))&amp;#10;                else:&amp;#10;                    curr_durations.append(maximum_duration)&amp;#10;&amp;#10;            # Add increment of 3 ms per trial&amp;#10;            increment_per_trial = 3&amp;#10;            for i in range(len(curr_durations)):&amp;#10;                # Calculate incremental increase for current trial&amp;#10;                increment = i * increment_per_trial&amp;#10;                # Add incremental increase to current trial's duration&amp;#10;                curr_durations[i] += increment&amp;#10;&amp;#10;        # print(f&quot;\tdurations for paced n-back block: {curr_durations}&quot;)&amp;#10;&amp;#10;        ### change background colour&amp;#10;        win.setColor(dark_bg_col, colorSpace='rgb')&amp;#10;        win.flip()&amp;#10;&amp;#10;    # show main block questions&amp;#10;    skip_questions_paced = False&amp;#10;    training_Qs_paced = False&amp;#10;&amp;#10;    # get n-back condition:&amp;#10;    curr_nback_cond = curr_block[0]  # get first character of block name&amp;#10;&amp;#10;    # if it is a 0, 1 or 2, set that as current n-back level:&amp;#10;    if curr_nback_cond in ['0', '1', '2']:&amp;#10;        curr_nback_cond == int(curr_nback_cond)&amp;#10;    # if it's neither 1 nor 2, it has to be a block without n-back,&amp;#10;    # so set curr_nback_cond to None&amp;#10;    else:&amp;#10;        curr_nback_cond = None&amp;#10;&amp;#10;    print(f&quot;\tcurrent n-back condition: {curr_nback_cond}&quot;)&amp;#10;    print(f&quot;\tcurrent text: {curr_text_nr}&quot;)&amp;#10;&amp;#10;    # get list with targets &amp; list with colours&amp;#10;    curr_targets = all_target_lists[exp_block_counter]&amp;#10;    curr_colours = all_colour_lists[exp_block_counter]&amp;#10;    # for current text nr, get text whose name = current text nr&amp;#10;    # curr_text = locals()[curr_text_nr]&amp;#10;&amp;#10;### Start block loop&amp;#10;if curr_block in [&quot;Reading_Baseline_training_no_click&quot;, &quot;Reading_Baseline_main_no_click&quot;, &quot;0back_dual_main_no_click&quot;,&amp;#10;                  &quot;1back_dual_main_no_click&quot;, &quot;2back_dual_main_no_click&quot;]:&amp;#10;&amp;#10;    if curr_block == &quot;0back_dual_main_no_click&quot;:&amp;#10;        zeroback_n_hits = 0&amp;#10;        zeroback_n_misses = 0&amp;#10;        zeroback_n_false_alarms = 0&amp;#10;        zeroback_n_correct_rejections = 0&amp;#10;    elif curr_block == &quot;1back_dual_main_no_click&quot;:&amp;#10;        oneback_n_hits = 0&amp;#10;        oneback_n_misses = 0&amp;#10;        oneback_n_false_alarms = 0&amp;#10;        oneback_n_correct_rejections = 0&amp;#10;    elif curr_block == &quot;2back_dual_main_no_click&quot;:&amp;#10;        twoback_n_hits = 0&amp;#10;        twoback_n_misses = 0&amp;#10;        twoback_n_false_alarms = 0&amp;#10;        twoback_n_correct_rejections = 0&amp;#10;&amp;#10;    # create empty text stimulus&amp;#10;    stim = visual.TextStim(win=win,&amp;#10;                           text=&quot; &quot;,&amp;#10;                           pos=(0, 0),  # center stimulus&amp;#10;                           font=&quot;Times New Roman&quot;,&amp;#10;                           height=0.07)&amp;#10;&amp;#10;    stim.draw()&amp;#10;    win.flip()&amp;#10;&amp;#10;    # clear buffer of all previously recorded key events:&amp;#10;    event.clearEvents()&amp;#10;&amp;#10;    # CREATE CLOCKS:&amp;#10;    my_block_clock = core.Clock()&amp;#10;    my_block_clock.reset()  # start block clock&amp;#10;    start_time = my_block_clock.getTime()  # get start time of block&amp;#10;    # also create trial clock&amp;#10;    my_trial_clock = core.Clock()&amp;#10;&amp;#10;    # loop words in current text&amp;#10;    for trial_idx, curr_word in enumerate(curr_text):&amp;#10;        # print(&quot;current idx: &quot; + str(trial_idx) + &quot;, curr word:&quot; + curr_word)&amp;#10;&amp;#10;        ### prepare &amp; show current word:&amp;#10;&amp;#10;        # get current colour&amp;#10;        curr_colour = curr_colours[trial_idx]&amp;#10;&amp;#10;        # if it's a block with an n-back task, prepare target list as well&amp;#10;        if curr_nback_cond != None:&amp;#10;            curr_target = curr_targets[trial_idx]&amp;#10;            saw_target = False&amp;#10;&amp;#10;        # get duration for current word&amp;#10;        curr_duration = curr_durations[trial_idx] / 1000  # convert ms to seconds&amp;#10;        # print(&quot;duration for current word (in s):&quot;, curr_duration)&amp;#10;&amp;#10;        # get trial number (start counting from 1, so add 1)&amp;#10;        curr_trial_nr = trial_idx + 1&amp;#10;&amp;#10;        # set current word &amp; colour as content of text stimulus&amp;#10;        stim.color = curr_colour&amp;#10;        stim.text = curr_word&amp;#10;&amp;#10;        # show word on screen&amp;#10;        stim.draw()  # draw word on screen&amp;#10;&amp;#10;        # start trial clock &amp; record trial onset time&amp;#10;        my_trial_clock.reset()&amp;#10;        onset_time = my_trial_clock.getTime()&amp;#10;&amp;#10;        ### wait for key response:&amp;#10;        # In blocks with n-back task, participants can press &quot;c&quot; to indicate they saw a target colour.&amp;#10;&amp;#10;        ### start recording responses&amp;#10;        # start while loop that looks for responses&amp;#10;        # --&gt; end while loop only if duration for current word is over&amp;#10;        while my_trial_clock.getTime() &lt; (onset_time + curr_duration):&amp;#10;&amp;#10;            stim.draw()&amp;#10;            win.flip()&amp;#10;&amp;#10;            # check for key responses:&amp;#10;            keys = event.getKeys(['c', 'escape'])&amp;#10;&amp;#10;            # if there were, check responses:&amp;#10;            for key in keys:&amp;#10;&amp;#10;                # if participant pressed button &quot;c&quot; for the first time and it's an n-back condition&amp;#10;                # where they're actually supposed to do that (aka not a reading baseline condition)...&amp;#10;                if key == 'c' and curr_nback_cond != None and saw_target == False:&amp;#10;                    # get reaction time&amp;#10;                    curr_nback_RT = my_trial_clock.getTime() * 1000&amp;#10;                    # send trigger for response:&amp;#10;                    # send_trigger(&quot;response_target&quot;)&amp;#10;                    # only get first target response, we don't care if they press the button more than once:&amp;#10;                    saw_target = True&amp;#10;&amp;#10;                # If esc is pressed, end the experiment:&amp;#10;                elif key == 'escape':&amp;#10;                    # et_abort_exp()  # shut down eyetrigger and download incremental data&amp;#10;                    # close trigger &amp; close experiment&amp;#10;                    # core.wait(time_after_trigger)&amp;#10;                    # parallel.setData(0)&amp;#10;                    core.wait(0.5)&amp;#10;                    core.quit()&amp;#10;&amp;#10;        ### end trial&amp;#10;        # print(&quot;\tend paced trial&quot;)&amp;#10;        # stop display of current word &amp; send trial offset trigger&amp;#10;        # win.callOnFlip(send_trigger, &quot;trial_offset&quot;)&amp;#10;&amp;#10;        # check whether response was hit, miss, false alarm or correct rejection&amp;#10;        # they saw a target and there was one: hit&amp;#10;        if curr_nback_cond != None:&amp;#10;            if saw_target and curr_target:&amp;#10;                curr_nback_response = &quot;hit&quot;&amp;#10;            # they didn't see a target but there was one: miss&amp;#10;            elif saw_target == False and curr_target:&amp;#10;                curr_nback_response = &quot;miss&quot;&amp;#10;                curr_nback_RT = None&amp;#10;            # they didn't see a target and there was none: correct rejection&amp;#10;            elif saw_target == False and curr_target == False:&amp;#10;                curr_nback_response = &quot;correct rejection&quot;&amp;#10;                curr_nback_RT = None&amp;#10;            # they saw a target but there was none: false alarm&amp;#10;            elif saw_target and curr_target == False:&amp;#10;                curr_nback_response = &quot;false alarm&quot;&amp;#10;        # if it wasn't an n-back task block:&amp;#10;        else:&amp;#10;            curr_target = None&amp;#10;            curr_nback_response = None&amp;#10;            curr_nback_RT = None&amp;#10;&amp;#10;        ### save everything in output csv&amp;#10;        thisExp.addData('colour', curr_colour)&amp;#10;        thisExp.addData('target', curr_target)&amp;#10;        if curr_block == &quot;0back_dual_main_no_click&quot;:&amp;#10;            thisExp.addData('curr_0back_target', target_colours_list[2])&amp;#10;        thisExp.addData('nback_response', curr_nback_response)&amp;#10;        thisExp.addData('nback_RT', curr_nback_RT)  # in ms&amp;#10;        thisExp.addData('duration', curr_duration * 1000)  # in ms&amp;#10;        thisExp.addData('text_nr', curr_text_nr)&amp;#10;        thisExp.addData('trial_nr', curr_trial_nr)&amp;#10;        thisExp.addData('block_nr', exp_block_counter)&amp;#10;        thisExp.addData('block_name', curr_block)&amp;#10;        thisExp.addData('block_kind', curr_nback_cond)&amp;#10;        # careful, make sure quotes in the strings are escaped using a&amp;#10;        # quote (weird, I know) so it's properly saved in the CSV:&amp;#10;        thisExp.addData('word', escape_quotes(curr_word))&amp;#10;&amp;#10;        # start a new row in the csv&amp;#10;        thisExp.nextEntry()&amp;#10;&amp;#10;        if curr_block == &quot;0back_dual_main_no_click&quot;:&amp;#10;            if curr_nback_response == &quot;hit&quot;:&amp;#10;                zeroback_n_hits += 1&amp;#10;            elif curr_nback_response == &quot;miss&quot;:&amp;#10;                zeroback_n_misses += 1&amp;#10;            elif curr_nback_response == &quot;false alarm&quot;:&amp;#10;                zeroback_n_false_alarms += 1&amp;#10;            elif curr_nback_response == &quot;correct rejection&quot;:&amp;#10;                zeroback_n_correct_rejections += 1&amp;#10;        elif curr_block == &quot;1back_dual_main_no_click&quot;:&amp;#10;            if curr_nback_response == &quot;hit&quot;:&amp;#10;                oneback_n_hits += 1&amp;#10;            elif curr_nback_response == &quot;miss&quot;:&amp;#10;                oneback_n_misses += 1&amp;#10;            elif curr_nback_response == &quot;false alarm&quot;:&amp;#10;                oneback_n_false_alarms += 1&amp;#10;            elif curr_nback_response == &quot;correct rejection&quot;:&amp;#10;                oneback_n_correct_rejections += 1&amp;#10;        elif curr_block == &quot;2back_dual_main_no_click&quot;:&amp;#10;            if curr_nback_response == &quot;hit&quot;:&amp;#10;                twoback_n_hits += 1&amp;#10;            elif curr_nback_response == &quot;miss&quot;:&amp;#10;                twoback_n_misses += 1&amp;#10;            elif curr_nback_response == &quot;false alarm&quot;:&amp;#10;                twoback_n_false_alarms += 1&amp;#10;            elif curr_nback_response == &quot;correct rejection&quot;:&amp;#10;                twoback_n_correct_rejections += 1&amp;#10;&amp;#10;        ### IF TESTING MODE ENABLED: end loop after 4 trials&amp;#10;        if expInfo['testing_mode'] == &quot;yes&quot;:&amp;#10;            if trial_idx == 3:&amp;#10;                break&amp;#10;&amp;#10;    print(&quot;finished presenting trials&quot;)&amp;#10;&amp;#10;    # Send end of block trigger:&amp;#10;    # core.wait(time_after_trigger)  # wait 3 ms&amp;#10;    # send block offset trigger&amp;#10;    # send_trigger(&quot;block_offset&quot;)&amp;#10;&amp;#10;# end current routine&amp;#10;# continueRoutine = False" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="paced_blocks" valType="code" updates="None" name="name"/>
      </CodeComponent>
      <CodeComponent name="questions_paced" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="##########################################################&amp;#10;#              Text Comprehension Questions              #&amp;#10;##########################################################&amp;#10;&amp;#10;def setup_question(question_text, answers_text):&amp;#10;    question = visual.TextStim(win, text=question_text, pos=(0, 0.2), color=&quot;black&quot;, height=0.03, anchorHoriz='center',&amp;#10;                               alignText='center', wrapWidth=1)&amp;#10;    answers = [visual.TextStim(win, text=ans, pos=(0, 0.1 - i * 0.08), color=&quot;black&quot;, height=0.03, wrapWidth=1,&amp;#10;                               anchorHoriz='center', alignText='center') for i, ans in enumerate(answers_text)]&amp;#10;    return question, answers&amp;#10;&amp;#10;&amp;#10;def display_question_and_get_response(question, answers, correct_answer):&amp;#10;    defaultKeyboard.clearEvents()&amp;#10;&amp;#10;    # Set-up time to write into logfile&amp;#10;    question_time = globalClock.getTime()&amp;#10;&amp;#10;    question.autoDraw = True&amp;#10;    for answer in answers:&amp;#10;        answer.autoDraw = True&amp;#10;    instr_text.autoDraw = True&amp;#10;&amp;#10;    countdown_timer = visual.TextStim(win, text='', pos=(0, -0.25), color=&quot;grey&quot;, height=0.02, anchorHoriz='center',&amp;#10;                                      alignText='center', wrapWidth=1)&amp;#10;&amp;#10;    # defaultKeyboard = keyboard.Keyboard()&amp;#10;    chosen_ans = &quot;NA&quot;&amp;#10;    is_correct = &quot;NA&quot;&amp;#10;    button_pressed = &quot;NA&quot;&amp;#10;    response_received = False&amp;#10;&amp;#10;    # Start a clock to track response time&amp;#10;    response_clock = core.Clock()&amp;#10;&amp;#10;    # Countdown from 10 seconds&amp;#10;    while response_clock.getTime() &lt; 10:&amp;#10;        remaining_time = 10 - int(response_clock.getTime())&amp;#10;        countdown_timer.text = f&quot;Zeit: {remaining_time}&quot;&amp;#10;        countdown_timer.draw()&amp;#10;        win.flip()&amp;#10;&amp;#10;        keys = defaultKeyboard.getKeys(['1', '2', '3', '4'], waitRelease=False)&amp;#10;        if keys:&amp;#10;            key_name = keys[0].name  # Get the name of the first key pressed&amp;#10;            button_pressed = key_name&amp;#10;&amp;#10;            # Now, use the key_name to determine the action&amp;#10;            if key_name == '1':&amp;#10;                index = 0  # Corresponds to the first choice&amp;#10;            elif key_name == '2':&amp;#10;                index = 1  # Corresponds to the second choice&amp;#10;            elif key_name == '3':&amp;#10;                index = 2  # Corresponds to the third choice&amp;#10;            elif key_name == '4':&amp;#10;                index = 3  # Corresponds to the fourth choice&amp;#10;            else:&amp;#10;                index = None  # Just in case, not really needed if you're sure about the input keys&amp;#10;&amp;#10;            # Proceed with your logic based on the index&amp;#10;            if index is not None:&amp;#10;                chosen_ans = chr(97 + index)  # Convert index to letter ('a', 'b', 'c', 'd')&amp;#10;                is_correct = chosen_ans == correct_answer  # Assuming correct_answer is defined ('a', 'b', 'c', or 'd')&amp;#10;                for i, answer in enumerate(answers):&amp;#10;                    answer.setColor(&quot;green&quot; if i == index else &quot;black&quot;)&amp;#10;                win.flip()&amp;#10;                core.wait(0.5)  # Ensure the color change is visible&amp;#10;                response_received = True&amp;#10;                break&amp;#10;&amp;#10;    # Hide the countdown timer after it finishes&amp;#10;    countdown_timer.text = ''&amp;#10;    countdown_timer.draw()&amp;#10;    win.flip()&amp;#10;&amp;#10;    # If no response is received within 10 seconds, return &quot;NA&quot;&amp;#10;    if not response_received:&amp;#10;        chosen_ans = &quot;NA&quot;&amp;#10;        is_correct = &quot;NA&quot;&amp;#10;        button_pressed = &quot;NA&quot;&amp;#10;&amp;#10;    return question_time, chosen_ans, is_correct, button_pressed&amp;#10;&amp;#10;&amp;#10;def reset_answers(answers):&amp;#10;    for answer in answers:&amp;#10;        answer.setColor(&quot;black&quot;)&amp;#10;    question.autoDraw = False&amp;#10;    instr_text.autoDraw = False&amp;#10;    for answer in answers:&amp;#10;        answer.autoDraw = False&amp;#10;&amp;#10;&amp;#10;# Set up instructions&amp;#10;win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;win.flip()&amp;#10;instr_text = visual.TextStim(win,&amp;#10;                             text=&quot;(Bitte benutzen Sie die Tasten 1, 2, 3 und 4, um die richtige Antwort auszuwählen.)&quot;,&amp;#10;                             color=&quot;grey&quot;, pos=(0, -0.3), wrapWidth=2, height=0.018)&amp;#10;event.clearEvents()&amp;#10;&amp;#10;# Assuming skip_questions_paced and other variables are defined&amp;#10;if not skip_questions_paced and training_Qs_paced:&amp;#10;    # Setup for Q1&amp;#10;    Q1_text = reading_bl_tr_no_click_Q1&amp;#10;    Q1_answers = reading_bl_tr_no_click_Q1_ans&amp;#10;    Q1_correct = reading_bl_tr_no_click_Q1_corr&amp;#10;&amp;#10;    question, answers = setup_question(Q1_text, Q1_answers)&amp;#10;    question_time, chosen_ans, is_correct, button_pressed = display_question_and_get_response(question, answers,&amp;#10;                                                                                              Q1_correct)&amp;#10;    print(f&quot;Chosen answer for Q1: {chosen_ans}, Correct: {is_correct}&quot;)&amp;#10;    reset_answers(answers)&amp;#10;&amp;#10;    # save data:&amp;#10;    thisExp.addData('global_onset_time', question_time)&amp;#10;    thisExp.addData('question', 'Q1')&amp;#10;    thisExp.addData('button_pressed', button_pressed)&amp;#10;    thisExp.addData('chosen_ans', chosen_ans)&amp;#10;    thisExp.addData('ans_correct', chosen_ans == Q1_correct)&amp;#10;    thisExp.addData('text_nr', curr_text_nr)&amp;#10;    thisExp.addData('block_nr_exp', exp_block_counter + 1)&amp;#10;    thisExp.addData('block_name', curr_block)&amp;#10;    thisExp.addData('n-back_level', curr_nback_cond)&amp;#10;&amp;#10;    # start a new row in the csv&amp;#10;    thisExp.nextEntry()&amp;#10;&amp;#10;    # Setup for Q2&amp;#10;    Q2_text = reading_bl_tr_no_click_Q2&amp;#10;    Q2_answers = reading_bl_tr_no_click_Q2_ans&amp;#10;    Q2_correct = reading_bl_tr_no_click_Q2_corr&amp;#10;&amp;#10;    question, answers = setup_question(Q2_text, Q2_answers)&amp;#10;    question_time, chosen_ans, is_correct, button_pressed = display_question_and_get_response(question, answers,&amp;#10;                                                                                              Q2_correct)&amp;#10;    print(f&quot;Chosen answer for Q2: {chosen_ans}, Correct: {is_correct}&quot;)&amp;#10;    reset_answers(answers)&amp;#10;&amp;#10;    # save data:&amp;#10;    thisExp.addData('global_onset_time', question_time)&amp;#10;    thisExp.addData('question', 'Q2')&amp;#10;    thisExp.addData('button_pressed', button_pressed)&amp;#10;    thisExp.addData('chosen_ans', chosen_ans)&amp;#10;    thisExp.addData('ans_correct', chosen_ans == Q2_correct)&amp;#10;    thisExp.addData('text_nr', curr_text_nr)&amp;#10;    thisExp.addData('block_nr_exp', exp_block_counter + 1)&amp;#10;    thisExp.addData('block_name', curr_block)&amp;#10;    thisExp.addData('n-back_level', curr_nback_cond)&amp;#10;&amp;#10;    # start a new row in the csv&amp;#10;    thisExp.nextEntry()&amp;#10;&amp;#10;    # Setup for Q3&amp;#10;    Q3_text = reading_bl_tr_no_click_Q3&amp;#10;    Q3_answers = reading_bl_tr_no_click_Q3_ans&amp;#10;    Q3_correct = reading_bl_tr_no_click_Q3_corr&amp;#10;&amp;#10;    question, answers = setup_question(Q3_text, Q3_answers)&amp;#10;    question_time, chosen_ans, is_correct, button_pressed = display_question_and_get_response(question, answers,&amp;#10;                                                                                              Q3_correct)&amp;#10;    print(f&quot;Chosen answer for Q3: {chosen_ans}, Correct: {is_correct}&quot;)&amp;#10;    reset_answers(answers)&amp;#10;&amp;#10;    # save data:&amp;#10;    thisExp.addData('global_onset_time', question_time)&amp;#10;    thisExp.addData('question', 'Q3')&amp;#10;    thisExp.addData('button_pressed', button_pressed)&amp;#10;    thisExp.addData('chosen_ans', chosen_ans)&amp;#10;    thisExp.addData('ans_correct', chosen_ans == Q3_correct)&amp;#10;    thisExp.addData('text_nr', curr_text_nr)&amp;#10;    thisExp.addData('block_nr_exp', exp_block_counter + 1)&amp;#10;    thisExp.addData('block_name', curr_block)&amp;#10;    thisExp.addData('n-back_level', curr_nback_cond)&amp;#10;&amp;#10;    # start a new row in the csv&amp;#10;    thisExp.nextEntry()&amp;#10;&amp;#10;    # go to next block!&amp;#10;    exp_block_counter += 1&amp;#10;    print(f&quot;Going to block {exp_block_counter + 1}/20 now!&quot;)&amp;#10;    continueRoutine = False&amp;#10;&amp;#10;    # If there are still blocks left, go to next one.&amp;#10;    # If not, end loop here:&amp;#10;    if exp_block_counter == 20:&amp;#10;        blocks.finished = True&amp;#10;&amp;#10;elif not skip_questions_paced and not training_Qs_paced:&amp;#10;    # Save n of correct questions in variables for output at the end of the training&amp;#10;    if curr_block == &quot;0back_dual_main_no_click&quot;:&amp;#10;        zeroback_correct_answers = 0&amp;#10;    elif curr_block == &quot;1back_dual_main_no_click&quot;:&amp;#10;        oneback_correct_answers = 0&amp;#10;    elif curr_block == &quot;2back_dual_main_no_click&quot;:&amp;#10;        twoback_correct_answers = 0&amp;#10;&amp;#10;    # Setup for Q1&amp;#10;    Q1_text = locals()[curr_text_nr + &quot;_Q1&quot;]&amp;#10;    Q1_answers = locals()[curr_text_nr + &quot;_Q1_ans&quot;]&amp;#10;    Q1_correct = locals()[curr_text_nr + &quot;_Q1_corr&quot;]&amp;#10;&amp;#10;    question, answers = setup_question(Q1_text, Q1_answers)&amp;#10;    question_time, chosen_ans, is_correct, button_pressed = display_question_and_get_response(question, answers,&amp;#10;                                                                                              Q1_correct)&amp;#10;    print(f&quot;Chosen answer for Q1: {chosen_ans}, Correct: {is_correct}&quot;)&amp;#10;    if curr_block == &quot;0back_dual_main_no_click&quot; and is_correct:&amp;#10;        zeroback_correct_answers += 1&amp;#10;    elif curr_block == &quot;1back_dual_main_no_click&quot; and is_correct:&amp;#10;        oneback_correct_answers += 1&amp;#10;    elif curr_block == &quot;2back_dual_main_no_click&quot; and is_correct:&amp;#10;        twoback_correct_answers += 1&amp;#10;    reset_answers(answers)&amp;#10;&amp;#10;    # save data:&amp;#10;    thisExp.addData('global_onset_time', question_time)&amp;#10;    thisExp.addData('question', 'Q1')&amp;#10;    thisExp.addData('button_pressed', button_pressed)&amp;#10;    thisExp.addData('chosen_ans', chosen_ans)&amp;#10;    thisExp.addData('ans_correct', chosen_ans == Q1_correct)&amp;#10;    thisExp.addData('text_nr', curr_text_nr)&amp;#10;    thisExp.addData('block_nr_exp', exp_block_counter + 1)&amp;#10;    thisExp.addData('block_name', curr_block)&amp;#10;    thisExp.addData('n-back_level', curr_nback_cond)&amp;#10;&amp;#10;    # start a new row in the csv&amp;#10;    thisExp.nextEntry()&amp;#10;&amp;#10;    # Setup for Q2&amp;#10;    Q2_text = locals()[curr_text_nr + &quot;_Q2&quot;]&amp;#10;    Q2_answers = locals()[curr_text_nr + &quot;_Q2_ans&quot;]&amp;#10;    Q2_correct = locals()[curr_text_nr + &quot;_Q2_corr&quot;]&amp;#10;&amp;#10;    question, answers = setup_question(Q2_text, Q2_answers)&amp;#10;    question_time, chosen_ans, is_correct, button_pressed = display_question_and_get_response(question, answers,&amp;#10;                                                                                              Q2_correct)&amp;#10;    print(f&quot;Chosen answer for Q2: {chosen_ans}, Correct: {is_correct}&quot;)&amp;#10;    if curr_block == &quot;0back_dual_main_no_click&quot; and is_correct:&amp;#10;        zeroback_correct_answers += 1&amp;#10;    elif curr_block == &quot;1back_dual_main_no_click&quot; and is_correct:&amp;#10;        oneback_correct_answers += 1&amp;#10;    elif curr_block == &quot;2back_dual_main_no_click&quot; and is_correct:&amp;#10;        twoback_correct_answers += 1&amp;#10;    reset_answers(answers)&amp;#10;&amp;#10;    # save data:&amp;#10;    thisExp.addData('global_onset_time', question_time)&amp;#10;    thisExp.addData('question', 'Q2')&amp;#10;    thisExp.addData('button_pressed', button_pressed)&amp;#10;    thisExp.addData('chosen_ans', chosen_ans)&amp;#10;    thisExp.addData('ans_correct', chosen_ans == Q2_correct)&amp;#10;    thisExp.addData('text_nr', curr_text_nr)&amp;#10;    thisExp.addData('block_nr_exp', exp_block_counter + 1)&amp;#10;    thisExp.addData('block_name', curr_block)&amp;#10;    thisExp.addData('n-back_level', curr_nback_cond)&amp;#10;&amp;#10;    # start a new row in the csv&amp;#10;    thisExp.nextEntry()&amp;#10;&amp;#10;    # Setup for Q3&amp;#10;    Q3_text = locals()[curr_text_nr + &quot;_Q3&quot;]&amp;#10;    Q3_answers = locals()[curr_text_nr + &quot;_Q3_ans&quot;]&amp;#10;    Q3_correct = locals()[curr_text_nr + &quot;_Q3_corr&quot;]&amp;#10;&amp;#10;    question, answers = setup_question(Q3_text, Q3_answers)&amp;#10;    question_time, chosen_ans, is_correct, button_pressed = display_question_and_get_response(question, answers,&amp;#10;                                                                                              Q3_correct)&amp;#10;    print(f&quot;Chosen answer for Q3: {chosen_ans}, Correct: {is_correct}&quot;)&amp;#10;    if curr_block == &quot;0back_dual_main_no_click&quot; and is_correct:&amp;#10;        zeroback_correct_answers += 1&amp;#10;    elif curr_block == &quot;1back_dual_main_no_click&quot; and is_correct:&amp;#10;        oneback_correct_answers += 1&amp;#10;    elif curr_block == &quot;2back_dual_main_no_click&quot; and is_correct:&amp;#10;        twoback_correct_answers += 1&amp;#10;    reset_answers(answers)&amp;#10;&amp;#10;    # save data:&amp;#10;    thisExp.addData('global_onset_time', question_time)&amp;#10;    thisExp.addData('question', 'Q3')&amp;#10;    thisExp.addData('button_pressed', button_pressed)&amp;#10;    thisExp.addData('chosen_ans', chosen_ans)&amp;#10;    thisExp.addData('ans_correct', chosen_ans == Q3_correct)&amp;#10;    thisExp.addData('text_nr', curr_text_nr)&amp;#10;    thisExp.addData('block_nr_exp', exp_block_counter + 1)&amp;#10;    thisExp.addData('block_name', curr_block)&amp;#10;    thisExp.addData('n-back_level', curr_nback_cond)&amp;#10;&amp;#10;    # start a new row in the csv&amp;#10;    thisExp.nextEntry()&amp;#10;&amp;#10;    # go to next block!&amp;#10;    exp_block_counter += 1&amp;#10;    print(f&quot;Going to block {exp_block_counter + 1}/20 now!&quot;)&amp;#10;    continueRoutine = False&amp;#10;&amp;#10;    # If there are still blocks left, go to next one.&amp;#10;    # If not, end loop here:&amp;#10;    if exp_block_counter == 20:&amp;#10;        blocks.finished = True" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="questions_paced" valType="code" updates="None" name="name"/>
      </CodeComponent>
    </Routine>
    <Routine name="text_blocks_paced_training">
      <RoutineSettingsComponent name="text_blocks_paced_training" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="text_blocks_paced_training" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <CodeComponent name="paced_training" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="##########################################################&amp;#10;#                 VISUAL TASK: TRAINING BLOCK            #&amp;#10;##########################################################&amp;#10;&amp;#10;# In this task, we present a new text, but the text proceeds&amp;#10;# automatically without the participant having to press the Space bar.&amp;#10;# To make sure the words are not presented too fast,&amp;#10;# we compute the average reading speed per letter and compute &quot;reading speeds&quot;&amp;#10;# for each word in the new text.&amp;#10;&amp;#10;# Put differently: We take the words &amp; the measured reading times for each&amp;#10;# word all BL main blocks and compute an average reading time / letter.&amp;#10;# Then we show a new text, using the reading time / letter to generate&amp;#10;# durations so the text can proceed automatically.&amp;#10;&amp;#10;# First things first: Compute average reading time / letter:&amp;#10;&amp;#10;# For testing purposes, I created the option to skip all main blocks.&amp;#10;# In this case we don't have any data from previous BL blocks,&amp;#10;# so we have to invent some reading times in order to test this part of the script.&amp;#10;if expInfo[&quot;testing_mode&quot;] == &quot;yes&quot;:&amp;#10;    BL_paced_durations = [332, 10, 104.778, 98.9, 3000,&amp;#10;                          440]  # in ms - I included a longer break and a very short RT as a test case for the data cleaning part later&amp;#10;    BL_paced_words = [&quot;Hallo,&quot;, &quot;das&quot;, &quot;ist&quot;, &quot;nur&quot;, &quot;ein&quot;, &quot;Beispiel.&quot;]&amp;#10;&amp;#10;# We collected RTs &amp; words from the self-paced block of each condition&amp;#10;# for the training, we only use data from the reading BL since there is no separate training for 1- and 2-back&amp;#10;&amp;#10;# exclude all RTs where participant was way too fast (&lt; 50 ms) or&amp;#10;# way too slow (&gt; 2s), also remove the corresponding words from vis_task_words&amp;#10;print(&quot;BL_paced_durations:&quot;, BL_paced_durations)&amp;#10;print(&quot;BL_paced_words:&quot;, BL_paced_words)&amp;#10;&amp;#10;filtered_durations = []&amp;#10;filtered_words = []&amp;#10;for duration, word in zip(BL_paced_durations, BL_paced_words):&amp;#10;    if 50 &lt;= duration &lt;= 2000:&amp;#10;        filtered_durations.append(duration)&amp;#10;        filtered_words.append(word)&amp;#10;print(&quot;filtered_durations:&quot;, filtered_durations)&amp;#10;print(&quot;filtered_words:&quot;, filtered_words)&amp;#10;&amp;#10;# Now get number of letters (not words, I want to know how fast they read 1 letter on average!):&amp;#10;letters_total = sum(len(word) for word in filtered_words)&amp;#10;print(&quot;letters_total:&quot;, letters_total)&amp;#10;# also get time it took in total to read them all:&amp;#10;reading_time_total = sum(filtered_durations)  # in ms&amp;#10;&amp;#10;# Now check how many words / min they read on average.&amp;#10;# reading_speed_wpm = words_total / (reading_time_total/60000)&amp;#10;# print(&quot;reading speed in words / min:&quot; + str(reading_speed_wpm))&amp;#10;&amp;#10;# Check average RT / letter&amp;#10;RT_per_letter = reading_time_total / letters_total&amp;#10;print(&quot;average RT per letter in ms:&quot;, RT_per_letter)&amp;#10;&amp;#10;# choose 1 target colour &amp; generate 0-back colour list&amp;#10;target_colour = random.choice(colours)&amp;#10;&amp;#10;# save this in the output csv:&amp;#10;thisExp.addData('vistask_RT_per_letter', RT_per_letter)&amp;#10;thisExp.addData('vistask_target', target_colour)&amp;#10;thisExp.addData('block_cond', 'None')&amp;#10;thisExp.addData('block_name', 'visual_task_training')&amp;#10;&amp;#10;# keep background ivory&amp;#10;win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;win.flip()&amp;#10;&amp;#10;# ----------------------------------&amp;#10;&amp;#10;### VISUAL TASK TRAINING&amp;#10;&amp;#10;# Show instructions&amp;#10;&amp;#10;# clear buffer of all previously recorded key events:&amp;#10;event.clearEvents()&amp;#10;&amp;#10;# create text boxes&amp;#10;instr_text_stim1 = visual.TextStim(win,&amp;#10;                                   text=locals()[&quot;instr_vis_task_1&quot;],&amp;#10;                                   height=0.5,  # font height: 5° visual angle&amp;#10;                                   #font=&quot;Bookman Old Style&quot;,&amp;#10;                                   pos=(0, 4),  # move instructions up a bit&amp;#10;                                   color=&quot;black&quot;)&amp;#10;instr_text_stim2 = visual.TextStim(win,&amp;#10;                                   text=locals()[&quot;instr_vis_task_2&quot;],&amp;#10;                                   height=0.5,  # font height: 5° visual angle&amp;#10;                                   #font=&quot;Bookman Old Style&quot;,&amp;#10;                                   pos=(0, 0),  # move instructions down a bit&amp;#10;                                   color=&quot;black&quot;)&amp;#10;&amp;#10;# show instructions on screen&amp;#10;win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;instr_text_stim1.draw()&amp;#10;instr_text_stim2.draw()&amp;#10;win.flip()&amp;#10;core.wait(3)  # wait for 3s before starting response window&amp;#10;&amp;#10;# display the text &amp; the circle on screen until Space is pressed&amp;#10;while True:&amp;#10;    # keep background ivory&amp;#10;    win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;    instr_text_stim1.draw()&amp;#10;    instr_text_stim2.draw()&amp;#10;    win.flip()&amp;#10;    # end screen if participant presses space&amp;#10;    if 'space' in event.getKeys():&amp;#10;        break&amp;#10;&amp;#10;### START VISUAL TASK TRAINING&amp;#10;&amp;#10;# change background colour:&amp;#10;win.setColor(dark_bg_col, colorSpace='rgb')&amp;#10;win.flip()&amp;#10;&amp;#10;# clear buffer of all previously recorded key events:&amp;#10;event.clearEvents()&amp;#10;&amp;#10;# prepare stimuli:&amp;#10;curr_text_training = ['Einen', 'Augenblick', 'herrschte', 'totale', 'Stille.', 'Man', 'hörte', 'plötzlich', 'die',&amp;#10;                      'Wellen', 'rauschen', 'und', 'das', 'Radio', 'aus', 'dem', 'Salon', 'herüberjazzen,', 'man',&amp;#10;                      'vernahm', 'jeden', 'Schritt', 'vom', 'Promenadendeck', 'und', 'das', 'leise,', 'feine', 'Sausen',&amp;#10;                      'des', 'Winds,', 'der', 'durch', 'die', 'Fugen', 'der', 'Fenster', 'fuhr.', 'Keiner', 'von',&amp;#10;                      'uns', 'atmete,', 'es', 'war', 'zu', 'plötzlich', 'gekommen', 'und', 'wir', 'alle', 'noch',&amp;#10;                      'geradezu', 'erschrocken', 'über', 'das', 'Unwahrscheinliche,', 'dass', 'dieser', 'Unbekannte',&amp;#10;                      'dem', 'Weltmeister', 'in', 'einer', 'schon', 'halb', 'verlorenen', 'Partie', 'seinen', 'Willen',&amp;#10;                      'aufgezwungen', 'haben', 'sollte.', 'McConnor', 'lehnte', 'sich', 'mit', 'einem', 'Ruck',&amp;#10;                      'zurück,', 'der', 'zurückgehaltene', 'Atem', 'fuhr', 'ihm', 'hörbar', 'in', 'einem', 'beglückten',&amp;#10;                      &quot;\&quot;Ah!\&quot;&quot;, 'von', 'den', 'Lippen.', 'Ich', 'wiederum', 'beobachtete', 'Czentovic.', 'Schon',&amp;#10;                      'bei', 'den', 'letzten', 'Zügen', 'hatte', 'mir', 'geschienen,', 'als', 'ob', 'er', 'blässer',&amp;#10;                      'geworden', 'sei.', 'Aber', 'er', 'verstand', 'sich', 'gut', 'zusammenzuhalten.', 'Er',&amp;#10;                      'verharrte', 'in', 'seiner', 'scheinbar', 'gleichmütigen', 'Starre', 'und', 'fragte', 'nur', 'in',&amp;#10;                      'lässigster', 'Weise,', 'während', 'er', 'die', 'Figuren', 'mit', 'ruhiger', 'Hand', 'vom',&amp;#10;                      'Brette', 'schob:', &quot;\&quot;Wünschen&quot;, 'die', 'Herren', 'noch', 'eine', 'dritte', 'Partie?\&quot;']&amp;#10;&amp;#10;# compute RTs using participant's average reading speed / letter&amp;#10;curr_durations_training = [len(word) * RT_per_letter for word in curr_text_training]  # in secs&amp;#10;print(&quot;durations for vis task training block:&quot;, curr_durations_training)&amp;#10;&amp;#10;# generate random colour list:&amp;#10;curr_colours_training = create_0back_stimlist(target_colour=target_colour, nr_targets=25, colour_codes=colours,&amp;#10;                                              nr_words=len(curr_text_training))&amp;#10;&amp;#10;# save position of targets as True/False list:&amp;#10;curr_targets_training = [colour == target_colour for colour in curr_colours_training]&amp;#10;&amp;#10;# CREATE CLOCKS:&amp;#10;my_block_clock = core.Clock()&amp;#10;my_block_clock.reset()  # start block clock&amp;#10;start_time = my_block_clock.getTime()  # get start time of block&amp;#10;# also create trial clock&amp;#10;my_trial_clock = core.Clock()&amp;#10;&amp;#10;### start block loop&amp;#10;&amp;#10;# create empty text stimulus&amp;#10;stim = visual.TextStim(win=win,&amp;#10;                       text=&quot; &quot;,&amp;#10;                       pos=(0, 0),  # center stimulus&amp;#10;                       font=&quot;Times New Roman&quot;,&amp;#10;                       height=1)  # font height = 1° visual angle&amp;#10;&amp;#10;&amp;#10;stim.draw()&amp;#10;win.flip()&amp;#10;&amp;#10;# loop words in current text&amp;#10;for trial_idx, curr_word in enumerate(curr_text_training):&amp;#10;    print(&quot;current idx: &quot; + str(trial_idx) + &quot;, curr word:&quot; + curr_word)&amp;#10;&amp;#10;    ### prepare &amp; show current word:&amp;#10;&amp;#10;    # get current colour&amp;#10;    curr_colour = curr_colours_training[trial_idx]&amp;#10;    # check if it's a target&amp;#10;    curr_target = curr_targets_training[trial_idx]&amp;#10;&amp;#10;    # get duration for current word&amp;#10;    curr_duration = curr_durations_training[trial_idx] / 1000  # convert ms to seconds&amp;#10;    print(&quot;duration for current word (in ms):&quot;, curr_duration)&amp;#10;&amp;#10;    # get trial number (start counting from 1, so add 1)&amp;#10;    curr_trial_nr = trial_idx + 1&amp;#10;&amp;#10;    # set current word &amp; colour as content of text stimulus&amp;#10;    stim.color = curr_colour&amp;#10;    stim.text = curr_word&amp;#10;&amp;#10;    # show word on screen&amp;#10;    stim.draw()  # draw word on screen&amp;#10;&amp;#10;    # start trial clock&amp;#10;    my_trial_clock.reset()&amp;#10;    onset_time = my_trial_clock.getTime()&amp;#10;&amp;#10;    ### wait for key response until curr_duration is over:&amp;#10;&amp;#10;    ### start recording responses&amp;#10;    # start while loop that looks for responses&amp;#10;    # --&gt; end while loop only if duration for current word is over&amp;#10;    while my_trial_clock.getTime() &lt; (onset_time + curr_duration):&amp;#10;&amp;#10;        # print(&quot;curr time stamp:&quot;, my_trial_clock.getTime(), &quot;waiting for time stamp:&quot;, onset_time + curr_duration)&amp;#10;        stim.draw()&amp;#10;        win.flip()&amp;#10;&amp;#10;        # check if there were responses:&amp;#10;        keys = event.getKeys(['escape'])&amp;#10;&amp;#10;        # if there were, check responses:&amp;#10;        for key in keys:&amp;#10;            # If esc is pressed, end the experiment:&amp;#10;            if key == 'escape':&amp;#10;                # close parallel port&amp;#10;                parallel.setData(0)&amp;#10;                core.wait(0.5)&amp;#10;                core.quit()&amp;#10;&amp;#10;    ### end trial&amp;#10;&amp;#10;    ### save everything in output csv&amp;#10;    thisExp.addData('colour', curr_colour)&amp;#10;    thisExp.addData('target', curr_target)&amp;#10;    thisExp.addData('duration', curr_duration * 1000)  # convert sec back to ms&amp;#10;    thisExp.addData('text_nr', None)&amp;#10;    thisExp.addData('trial_nr', curr_trial_nr)&amp;#10;    thisExp.addData('block_cond', 'None')&amp;#10;    thisExp.addData('block_nr', exp_block_counter)&amp;#10;    thisExp.addData('block_name', 'BL_paced_training')&amp;#10;    # careful, make sure to escape quotes in the string&amp;#10;    # differently before saving in csv file:&amp;#10;    thisExp.addData('word', escape_quotes(curr_word))&amp;#10;&amp;#10;    # start a new row in the csv&amp;#10;    thisExp.nextEntry()&amp;#10;&amp;#10;    ### IF TESTING MODE ENABLED: end loop after 4 trials&amp;#10;    if expInfo['testing_mode'] == &quot;yes&quot;:&amp;#10;        if trial_idx == 20:&amp;#10;            break&amp;#10;&amp;#10;print(&quot;finished paced task training block&quot;)&amp;#10;&amp;#10;# change background colour from grey to ivory&amp;#10;win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;win.flip()" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="paced_training" valType="code" updates="None" name="name"/>
      </CodeComponent>
    </Routine>
    <Routine name="end">
      <RoutineSettingsComponent name="end" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="end" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <CodeComponent name="end" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="### END OF EXPERIMENT:&amp;#10;# keep background ivory&amp;#10;win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;win.flip()&amp;#10;&amp;#10;### Show message&amp;#10;# set text&amp;#10;instr_text = &quot;Vielen Dank,\ndas Training ist nun zu Ende!\n\n\nIm MRT folgen nun erneut die Blöcke ohne die 'Weiter'-Taste.\nSie drücken also dann nur eine Taste in den Blöcken mit 1- oder 2-Zurück.\n\nViel Spaß!&quot;&amp;#10;&amp;#10;# create text box&amp;#10;instr_text_stim = visual.TextStim(win,&amp;#10;                                  text = instr_text,&amp;#10;                                  height = 0.03,&amp;#10;                                  pos = (0, 0),&amp;#10;                                  color = &quot;black&quot;)&amp;#10;&amp;#10;# display the text on screen until Space is pressed&amp;#10;while True:&amp;#10;    # keep background ivory&amp;#10;    win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;    instr_text_stim.draw()&amp;#10;    win.flip()&amp;#10;    # end screen if participant presses space&amp;#10;    if 'space' in event.getKeys():&amp;#10;        print(f&quot;Ending experiment now!&quot;)&amp;#10;        print(f&quot;This is how participant performed during the paced version:&quot;)&amp;#10;        print(f&quot;\t0-back dual blocks:&quot;)&amp;#10;        print(f&quot;\t\thits: {zeroback_n_hits}&quot;)&amp;#10;        print(f&quot;\t\tmisses: {zeroback_n_misses}&quot;)&amp;#10;        print(f&quot;\t\tfalse alarms: {zeroback_n_false_alarms}&quot;)&amp;#10;        print(f&quot;\t\tcorrect rejections: {zeroback_n_correct_rejections}&quot;)&amp;#10;        print(f&quot;\t\tcorrect answers to questions: {zeroback_correct_answers}&quot;)&amp;#10;        print(f&quot;\t1-back dual blocks:&quot;)&amp;#10;        print(f&quot;\t\thits: {oneback_n_hits}&quot;)&amp;#10;        print(f&quot;\t\tmisses: {oneback_n_misses}&quot;)&amp;#10;        print(f&quot;\t\tfalse alarms: {oneback_n_false_alarms}&quot;)&amp;#10;        print(f&quot;\t\tcorrect rejections: {oneback_n_correct_rejections}&quot;)&amp;#10;        print(f&quot;\t\tcorrect answers to questions: {oneback_correct_answers}&quot;)&amp;#10;        print(f&quot;\t2-back dual blocks:&quot;)&amp;#10;        print(f&quot;\t\thits: {twoback_n_hits}&quot;)&amp;#10;        print(f&quot;\t\tmisses: {twoback_n_misses}&quot;)&amp;#10;        print(f&quot;\t\tfalse alarms: {twoback_n_false_alarms}&quot;)&amp;#10;        print(f&quot;\t\tcorrect rejections: {twoback_n_correct_rejections}&quot;)&amp;#10;        print(f&quot;\t\tcorrect answers to questions: {twoback_correct_answers}&quot;)&amp;#10;        print(f&quot;These are the RTs for the fMRI experiment:&quot;)&amp;#10;        print(f&quot;\tRT_per_letter_baseline: {RT_per_letter_baseline}&quot;)&amp;#10;        print(f&quot;\tRT_per_letter_0back: {RT_per_letter_0back}&quot;)&amp;#10;        print(f&quot;\tRT_per_letter_1back: {RT_per_letter_1bck}&quot;)&amp;#10;        print(f&quot;\tRT_per_letter_2back: {RT_per_letter_2bck}&quot;)&amp;#10;        # end experiment&amp;#10;        break" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="end" valType="code" updates="None" name="name"/>
      </CodeComponent>
    </Routine>
    <Routine name="demographics">
      <RoutineSettingsComponent name="demographics" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="True" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="demographics" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <FormComponent name="demographic_form" plugin="None">
        <Param val="rows" valType="str" updates="constant" name="Data Format"/>
        <Param val="Open Sans" valType="str" updates="constant" name="Font"/>
        <Param val="0.03" valType="num" updates="constant" name="Item Padding"/>
        <Param val="demographics_form.csv" valType="file" updates="constant" name="Items"/>
        <Param val="False" valType="bool" updates="constant" name="Randomize"/>
        <Param val="custom..." valType="str" updates="constant" name="Style"/>
        <Param val="0.03" valType="num" updates="constant" name="Text Height"/>
        <Param val="1.0000, 1.0000, 1.0000" valType="color" updates="constant" name="borderColor"/>
        <Param val="rgb" valType="str" updates="constant" name="colorSpace"/>
        <Param val="1" valType="num" updates="constant" name="contrast"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="1.0000, 1.0000, 1.0000" valType="color" updates="constant" name="fillColor"/>
        <Param val="-1.0000, -1.0000, -1.0000" valType="color" updates="constant" name="itemColor"/>
        <Param val="0.9608, 0.8431, 0.6863" valType="color" updates="constant" name="markerColor"/>
        <Param val="demographic_form" valType="code" updates="None" name="name"/>
        <Param val="" valType="num" updates="constant" name="opacity"/>
        <Param val="(0, 0)" valType="list" updates="constant" name="pos"/>
        <Param val="-1.0000, -1.0000, -1.0000" valType="color" updates="constant" name="responseColor"/>
        <Param val="False" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="(1.3, 0.9)" valType="list" updates="constant" name="size"/>
        <Param val="" valType="code" updates="None" name="startEstim"/>
        <Param val="time (s)" valType="str" updates="None" name="startType"/>
        <Param val="0" valType="code" updates="None" name="startVal"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="True" valType="bool" updates="None" name="syncScreenRefresh"/>
        <Param val="" valType="code" updates="None" name="validator"/>
      </FormComponent>
      <ButtonComponent name="demographic_button" plugin="None">
        <Param val="center" valType="str" updates="constant" name="anchor"/>
        <Param val="True" valType="bool" updates="constant" name="bold"/>
        <Param val="None" valType="color" updates="constant" name="borderColor"/>
        <Param val="0" valType="num" updates="constant" name="borderWidth"/>
        <Param val="" valType="extendedCode" updates="constant" name="callback"/>
        <Param val="white" valType="color" updates="constant" name="color"/>
        <Param val="rgb" valType="str" updates="constant" name="colorSpace"/>
        <Param val="1" valType="num" updates="constant" name="contrast"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="darkgrey" valType="color" updates="constant" name="fillColor"/>
        <Param val="Open Sans" valType="str" updates="constant" name="font"/>
        <Param val="True" valType="bool" updates="constant" name="forceEndRoutine"/>
        <Param val="False" valType="bool" updates="constant" name="italic"/>
        <Param val="0.06" valType="num" updates="constant" name="letterHeight"/>
        <Param val="demographic_button" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="constant" name="oncePerClick"/>
        <Param val="" valType="num" updates="constant" name="opacity"/>
        <Param val="0" valType="num" updates="constant" name="ori"/>
        <Param val="" valType="num" updates="constant" name="padding"/>
        <Param val="(0.3, -0.35)" valType="list" updates="constant" name="pos"/>
        <Param val="none" valType="str" updates="None" name="save"/>
        <Param val="False" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="(0.3, 0.12)" valType="list" updates="constant" name="size"/>
        <Param val="" valType="code" updates="None" name="startEstim"/>
        <Param val="condition" valType="str" updates="None" name="startType"/>
        <Param val="$demographic_form.complete==True" valType="code" updates="None" name="startVal"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="True" valType="bool" updates="None" name="syncScreenRefresh"/>
        <Param val="Weiter" valType="str" updates="constant" name="text"/>
        <Param val="button onset" valType="str" updates="constant" name="timeRelativeTo"/>
        <Param val="from exp settings" valType="str" updates="None" name="units"/>
        <Param val="" valType="code" updates="None" name="validator"/>
      </ButtonComponent>
    </Routine>
    <Routine name="welcome_Ishihara">
      <RoutineSettingsComponent name="welcome_Ishihara" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="True" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="welcome_Ishihara" valType="code" updates="None" name="name"/>
        <Param val="False" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <TextComponent name="instructions" plugin="None">
        <Param val="black" valType="color" updates="constant" name="color"/>
        <Param val="rgb" valType="str" updates="constant" name="colorSpace"/>
        <Param val="1" valType="num" updates="constant" name="contrast"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="None" valType="str" updates="constant" name="flip"/>
        <Param val="Open Sans" valType="str" updates="constant" name="font"/>
        <Param val="LTR" valType="str" updates="None" name="languageStyle"/>
        <Param val="0.035" valType="num" updates="constant" name="letterHeight"/>
        <Param val="instructions" valType="code" updates="None" name="name"/>
        <Param val="" valType="num" updates="constant" name="opacity"/>
        <Param val="0" valType="num" updates="constant" name="ori"/>
        <Param val="(0, 0)" valType="list" updates="constant" name="pos"/>
        <Param val="False" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="None" name="startEstim"/>
        <Param val="time (s)" valType="str" updates="None" name="startType"/>
        <Param val="0.0" valType="code" updates="None" name="startVal"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="True" valType="bool" updates="None" name="syncScreenRefresh"/>
        <Param val="Farbsehtest&amp;#10;&amp;#10;Im Folgenden werden Ihnen nun einige Bilder gezeigt, auf denen jeweils eine Zahl zu sehen ist.&amp;#10;&amp;#10;Bitte geben Sie unter jedem Bild an, welche Zahl Sie sehen. " valType="str" updates="constant" name="text"/>
        <Param val="from exp settings" valType="str" updates="None" name="units"/>
        <Param val="" valType="code" updates="None" name="validator"/>
        <Param val="" valType="num" updates="constant" name="wrapWidth"/>
      </TextComponent>
      <ButtonComponent name="instr_button" plugin="None">
        <Param val="center" valType="str" updates="constant" name="anchor"/>
        <Param val="True" valType="bool" updates="constant" name="bold"/>
        <Param val="None" valType="color" updates="constant" name="borderColor"/>
        <Param val="0" valType="num" updates="constant" name="borderWidth"/>
        <Param val="" valType="extendedCode" updates="constant" name="callback"/>
        <Param val="white" valType="color" updates="constant" name="color"/>
        <Param val="rgb" valType="str" updates="constant" name="colorSpace"/>
        <Param val="1" valType="num" updates="constant" name="contrast"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="darkgrey" valType="color" updates="constant" name="fillColor"/>
        <Param val="Open Sans" valType="str" updates="constant" name="font"/>
        <Param val="True" valType="bool" updates="constant" name="forceEndRoutine"/>
        <Param val="False" valType="bool" updates="constant" name="italic"/>
        <Param val="0.035" valType="num" updates="constant" name="letterHeight"/>
        <Param val="instr_button" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="constant" name="oncePerClick"/>
        <Param val="" valType="num" updates="constant" name="opacity"/>
        <Param val="0" valType="num" updates="constant" name="ori"/>
        <Param val="" valType="num" updates="constant" name="padding"/>
        <Param val="(0.3, -0.35)" valType="list" updates="constant" name="pos"/>
        <Param val="none" valType="str" updates="None" name="save"/>
        <Param val="False" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="(0.3, 0.12)" valType="list" updates="constant" name="size"/>
        <Param val="" valType="code" updates="None" name="startEstim"/>
        <Param val="time (s)" valType="str" updates="None" name="startType"/>
        <Param val="0" valType="code" updates="None" name="startVal"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="True" valType="bool" updates="None" name="syncScreenRefresh"/>
        <Param val="Weiter" valType="str" updates="constant" name="text"/>
        <Param val="button onset" valType="str" updates="constant" name="timeRelativeTo"/>
        <Param val="from exp settings" valType="str" updates="None" name="units"/>
        <Param val="" valType="code" updates="None" name="validator"/>
      </ButtonComponent>
    </Routine>
    <Routine name="Ishihara">
      <RoutineSettingsComponent name="Ishihara" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="True" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="Ishihara" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <ImageComponent name="ishihara_1" plugin="None">
        <Param val="center" valType="str" updates="constant" name="anchor"/>
        <Param val="$[1,1,1]" valType="color" updates="constant" name="color"/>
        <Param val="rgb" valType="str" updates="constant" name="colorSpace"/>
        <Param val="1" valType="num" updates="constant" name="contrast"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="False" valType="bool" updates="constant" name="flipHoriz"/>
        <Param val="False" valType="bool" updates="constant" name="flipVert"/>
        <Param val="$DisplayImage" valType="file" updates="set every repeat" name="image"/>
        <Param val="linear" valType="str" updates="constant" name="interpolate"/>
        <Param val="" valType="str" updates="constant" name="mask"/>
        <Param val="ishihara_1" valType="code" updates="None" name="name"/>
        <Param val="" valType="num" updates="constant" name="opacity"/>
        <Param val="0" valType="num" updates="constant" name="ori"/>
        <Param val="(0, 0.1)" valType="list" updates="constant" name="pos"/>
        <Param val="False" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="(0.5, 0.5)" valType="list" updates="constant" name="size"/>
        <Param val="" valType="code" updates="None" name="startEstim"/>
        <Param val="time (s)" valType="str" updates="None" name="startType"/>
        <Param val="0.0" valType="code" updates="None" name="startVal"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="True" valType="bool" updates="None" name="syncScreenRefresh"/>
        <Param val="128" valType="num" updates="constant" name="texture resolution"/>
        <Param val="from exp settings" valType="str" updates="None" name="units"/>
        <Param val="" valType="code" updates="None" name="validator"/>
      </ImageComponent>
      <TextboxComponent name="ishihara_number" plugin="None">
        <Param val="center" valType="str" updates="constant" name="alignment"/>
        <Param val="center" valType="str" updates="constant" name="anchor"/>
        <Param val="True" valType="bool" updates="constant" name="autoLog"/>
        <Param val="True" valType="bool" updates="constant" name="bold"/>
        <Param val="-1.0000, -1.0000, -1.0000" valType="color" updates="constant" name="borderColor"/>
        <Param val="2" valType="num" updates="constant" name="borderWidth"/>
        <Param val="-1.0000, -1.0000, -1.0000" valType="color" updates="constant" name="color"/>
        <Param val="rgb" valType="str" updates="constant" name="colorSpace"/>
        <Param val="1" valType="num" updates="constant" name="contrast"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="True" valType="bool" updates="constant" name="editable"/>
        <Param val="None" valType="color" updates="constant" name="fillColor"/>
        <Param val="False" valType="bool" updates="constant" name="flipHoriz"/>
        <Param val="False" valType="bool" updates="constant" name="flipVert"/>
        <Param val="Open Sans" valType="str" updates="constant" name="font"/>
        <Param val="False" valType="bool" updates="constant" name="italic"/>
        <Param val="LTR" valType="str" updates="None" name="languageStyle"/>
        <Param val="0.025" valType="num" updates="constant" name="letterHeight"/>
        <Param val="1.0" valType="num" updates="constant" name="lineSpacing"/>
        <Param val="ishihara_number" valType="code" updates="None" name="name"/>
        <Param val="" valType="num" updates="constant" name="opacity"/>
        <Param val="0" valType="num" updates="constant" name="ori"/>
        <Param val="hidden" valType="str" updates="constant" name="overflow"/>
        <Param val="0" valType="num" updates="constant" name="padding"/>
        <Param val="" valType="str" updates="constant" name="placeholder"/>
        <Param val="(0, -0.3)" valType="list" updates="constant" name="pos"/>
        <Param val="False" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="(0.15, 0.1)" valType="list" updates="constant" name="size"/>
        <Param val="" valType="list" updates="constant" name="speechPoint"/>
        <Param val="" valType="code" updates="None" name="startEstim"/>
        <Param val="time (s)" valType="str" updates="None" name="startType"/>
        <Param val="0.0" valType="code" updates="None" name="startVal"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="True" valType="bool" updates="None" name="syncScreenRefresh"/>
        <Param val="" valType="str" updates="set every repeat" name="text"/>
        <Param val="from exp settings" valType="str" updates="None" name="units"/>
        <Param val="" valType="code" updates="None" name="validator"/>
      </TextboxComponent>
      <ButtonComponent name="ishihara_button" plugin="None">
        <Param val="center" valType="str" updates="constant" name="anchor"/>
        <Param val="True" valType="bool" updates="constant" name="bold"/>
        <Param val="None" valType="color" updates="constant" name="borderColor"/>
        <Param val="0" valType="num" updates="constant" name="borderWidth"/>
        <Param val="" valType="extendedCode" updates="constant" name="callback"/>
        <Param val="white" valType="color" updates="constant" name="color"/>
        <Param val="rgb" valType="str" updates="constant" name="colorSpace"/>
        <Param val="1" valType="num" updates="constant" name="contrast"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="darkgrey" valType="color" updates="constant" name="fillColor"/>
        <Param val="Open Sans" valType="str" updates="constant" name="font"/>
        <Param val="True" valType="bool" updates="constant" name="forceEndRoutine"/>
        <Param val="False" valType="bool" updates="constant" name="italic"/>
        <Param val="0.035" valType="num" updates="constant" name="letterHeight"/>
        <Param val="ishihara_button" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="constant" name="oncePerClick"/>
        <Param val="" valType="num" updates="constant" name="opacity"/>
        <Param val="0" valType="num" updates="constant" name="ori"/>
        <Param val="" valType="num" updates="constant" name="padding"/>
        <Param val="(0.3, -0.35)" valType="list" updates="constant" name="pos"/>
        <Param val="none" valType="str" updates="None" name="save"/>
        <Param val="False" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="(0.3, 0.12)" valType="list" updates="constant" name="size"/>
        <Param val="" valType="code" updates="None" name="startEstim"/>
        <Param val="time (s)" valType="str" updates="None" name="startType"/>
        <Param val="0" valType="code" updates="None" name="startVal"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="True" valType="bool" updates="None" name="syncScreenRefresh"/>
        <Param val="Weiter" valType="str" updates="constant" name="text"/>
        <Param val="button onset" valType="str" updates="constant" name="timeRelativeTo"/>
        <Param val="from exp settings" valType="str" updates="None" name="units"/>
        <Param val="" valType="code" updates="None" name="validator"/>
      </ButtonComponent>
    </Routine>
    <Routine name="feedback">
      <RoutineSettingsComponent name="feedback" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="True" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="feedback" valType="code" updates="None" name="name"/>
        <Param val="False" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <CodeComponent name="code" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="if ((ishihara_number.text === corrAns.toString())) {&amp;#10;    thisFeedback = &quot;Korrekt&quot;;&amp;#10;} else {&amp;#10;    thisFeedback = &quot;Falsch&quot;;&amp;#10;}&amp;#10;" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="if ishihara_number.text == str(corrAns):&amp;#10;    thisFeedback = &quot;Korrekt&quot;&amp;#10;else:&amp;#10;    thisFeedback = &quot;Falsch&quot;" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Auto-&gt;JS" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="code" valType="code" updates="None" name="name"/>
      </CodeComponent>
      <TextComponent name="feedback_text" plugin="None">
        <Param val="-1.0000, -1.0000, -1.0000" valType="color" updates="constant" name="color"/>
        <Param val="rgb" valType="str" updates="constant" name="colorSpace"/>
        <Param val="1" valType="num" updates="constant" name="contrast"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="None" valType="str" updates="constant" name="flip"/>
        <Param val="Open Sans" valType="str" updates="constant" name="font"/>
        <Param val="LTR" valType="str" updates="None" name="languageStyle"/>
        <Param val="0.05" valType="num" updates="constant" name="letterHeight"/>
        <Param val="feedback_text" valType="code" updates="None" name="name"/>
        <Param val="" valType="num" updates="constant" name="opacity"/>
        <Param val="0" valType="num" updates="constant" name="ori"/>
        <Param val="(0, 0)" valType="list" updates="constant" name="pos"/>
        <Param val="False" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="None" name="startEstim"/>
        <Param val="time (s)" valType="str" updates="None" name="startType"/>
        <Param val="0.0" valType="code" updates="None" name="startVal"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="1.0" valType="code" updates="constant" name="stopVal"/>
        <Param val="True" valType="bool" updates="None" name="syncScreenRefresh"/>
        <Param val="$thisFeedback" valType="str" updates="set every repeat" name="text"/>
        <Param val="from exp settings" valType="str" updates="None" name="units"/>
        <Param val="" valType="code" updates="None" name="validator"/>
        <Param val="" valType="num" updates="constant" name="wrapWidth"/>
      </TextComponent>
    </Routine>
    <Routine name="pseudotext">
      <RoutineSettingsComponent name="pseudotext" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="pseudotext" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <CodeComponent name="pseudotext_paced_block" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="#################################################&amp;#10;#            Blocks with text – paced           #&amp;#10;#################################################&amp;#10;# this routine is for all blocks with texts that are paced, i.e., visually presented without space bar&amp;#10;&amp;#10;#---------- Calculate duration of words based on previous block ----------&amp;#10;# We collected RTs &amp; words from the self-paced block of each condition&amp;#10;# for the training, we only use data from the reading BL since there is no separate training for 1- and 2-back&amp;#10;&amp;#10;# we calculate letter duration based on condition since participants need more time for n-back tasks than for baseline reading&amp;#10;# BL reading blocks are based on duration during self-paced BL reading&amp;#10;# 1- and 2-back blocks are based on their respective self-paced version&amp;#10;&amp;#10;# get block kind&amp;#10;curr_block = all_blocks[exp_block_counter]&amp;#10;&amp;#10;if curr_block == &quot;Reading_pseudotext_no_click&quot;:&amp;#10;&amp;#10;    # exclude all RTs where participant was way too fast (&lt; 50 ms) or&amp;#10;    # way too slow (&gt; 2s), also remove the corresponding words from vis_task_words&amp;#10;    # print(&quot;\tBL_paced_durations:&quot;, BL_paced_durations)&amp;#10;    # print(&quot;\tBL_paced_words:&quot;, BL_paced_words)&amp;#10;&amp;#10;    filtered_durations_BL = []&amp;#10;    filtered_words_BL = []&amp;#10;    for duration, word in zip(BL_paced_durations, BL_paced_words):&amp;#10;        if 50 &lt;= duration &lt;= 1500:&amp;#10;            filtered_durations_BL.append(duration)&amp;#10;            filtered_words_BL.append(word)&amp;#10;    # print(&quot;\tfiltered_durations_BL:&quot;, filtered_durations_BL)&amp;#10;    # print(&quot;\tfiltered_words_BL:&quot;, filtered_words_BL)&amp;#10;&amp;#10;    # Now get number of letters (not words, I want to know how fast they read 1 letter on average!):&amp;#10;    letters_total_BL = sum(len(word) for word in filtered_words_BL)&amp;#10;    # print(&quot;\tletters_total_BL:&quot;, letters_total_BL)&amp;#10;    # also get time it took in total to read them all:&amp;#10;    reading_time_total_BL = sum(filtered_durations_BL)  # in ms&amp;#10;&amp;#10;    # Now check how many words / min they read on average.&amp;#10;    # reading_speed_wpm = words_total / (reading_time_total/60000)&amp;#10;    # print(&quot;reading speed in words / min:&quot; + str(reading_speed_wpm))&amp;#10;&amp;#10;    # Check average RT / letter&amp;#10;    RT_per_letter_baseline = reading_time_total_BL / letters_total_BL&amp;#10;    print(&quot;\taverage RT per letter in ms:&quot;, RT_per_letter_baseline)&amp;#10;&amp;#10;    # save this in the output csv:&amp;#10;    thisExp.addData('RT_per_letter_baseline', RT_per_letter_baseline)&amp;#10;&amp;#10;# keep background ivory&amp;#10;win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;win.flip()&amp;#10;&amp;#10;# ----------------------------------&amp;#10;&amp;#10;# clear buffer of all previously recorded key events:&amp;#10;event.clearEvents()&amp;#10;&amp;#10;### specify settings for the current block&amp;#10;&amp;#10;### Prepare stimuli:&amp;#10;&amp;#10;# get block kind&amp;#10;curr_block = all_blocks[exp_block_counter]&amp;#10;# print(&quot;start preparing block &quot; + curr_block)&amp;#10;&amp;#10;# if it's the paced reading training block, prepare training stimuli:&amp;#10;if curr_block == &quot;Reading_pseudotext_no_click&quot;:&amp;#10;    print(f&quot;start preparing block {curr_block}&quot;)&amp;#10;&amp;#10;    # keep background ivory&amp;#10;    win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;    win.flip()&amp;#10;&amp;#10;    ### Show instructions&amp;#10;    # set instruction text&amp;#10;    instr_text = locals()[&quot;instr_&quot; + curr_block]&amp;#10;    # create text box&amp;#10;    instr_text_stim = visual.TextStim(win,&amp;#10;                                      text=instr_text,&amp;#10;                                      height=0.025,  # font height relative to height of screen&amp;#10;                                      pos=(0, 0),  # move up a bit&amp;#10;                                      color=&quot;black&quot;)&amp;#10;&amp;#10;    # show instructions on screen&amp;#10;    win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;    instr_text_stim.draw()&amp;#10;    win.flip()&amp;#10;    core.wait(3)  # wait for 3s before starting response window&amp;#10;&amp;#10;    # display the text on screen&amp;#10;    while True:&amp;#10;        # keep background ivory&amp;#10;        win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;        instr_text_stim.draw()&amp;#10;        win.flip()&amp;#10;        # end showing screen if participant presses space&amp;#10;        if 'space' in event.getKeys():&amp;#10;            break&amp;#10;&amp;#10;    # clear buffer of all previously recorded key events:&amp;#10;    event.clearEvents()&amp;#10;&amp;#10;    ### get training text&amp;#10;    curr_text_training = reading_ps_text_no_click&amp;#10;    curr_text_nr = &quot;Reading_pseudotext_no_click&quot;&amp;#10;    curr_text = curr_text_training&amp;#10;    curr_nback_cond = None&amp;#10;    # show training questions&amp;#10;    skip_questions_paced = True&amp;#10;    training_Qs_paced = False&amp;#10;&amp;#10;    # get list with targets &amp; list with colours&amp;#10;    curr_targets = all_target_lists[exp_block_counter]&amp;#10;    curr_colours = all_colour_lists[exp_block_counter]&amp;#10;&amp;#10;    # compute RTs using participant's average reading speed / letter – old, based on linear increase of RTs,&amp;#10;    # feels very unnatural however&amp;#10;    # curr_durations = [len(word) * RT_per_letter_baseline for word in curr_text]  # in ms&amp;#10;&amp;#10;    # compute RTs using participant's average reading speed / letter&amp;#10;    # we define a minimum and a maximum duration for each word&amp;#10;    # the minimum is based on 5 x RT per letter in the respective condition&amp;#10;    # the max duration is based on a time-out of 1.5 s in the reading baseline condition&amp;#10;    minimum_duration = 5 * RT_per_letter_baseline&amp;#10;    maximum_duration = 1500&amp;#10;    curr_durations = []&amp;#10;    for word in curr_text:&amp;#10;        # this is an absolute value based on estimates of how long you need to feel comfortable reading a word on&amp;#10;        # screen in a paced task&amp;#10;        # duration = RT_per_letter_baseline * math.log((len(word))) + 300&amp;#10;        # more flexible solution:&amp;#10;        duration = RT_per_letter_baseline * math.log((len(word))) + 4 * RT_per_letter_baseline&amp;#10;        if duration &lt; maximum_duration:&amp;#10;            curr_durations.append(max(duration, minimum_duration))&amp;#10;        else:&amp;#10;            curr_durations.append(maximum_duration)&amp;#10;&amp;#10;    # print(f&quot;\tdurations for paced task training block: {curr_durations}&quot;)&amp;#10;&amp;#10;    # we also need the start time (let's set it as current time&amp;#10;    # at this point in the script):&amp;#10;    start_time = core.getTime()&amp;#10;&amp;#10;    ### change background colour&amp;#10;    win.setColor(dark_bg_col, colorSpace='rgb')&amp;#10;    win.flip()&amp;#10;&amp;#10;### Start block loop&amp;#10;if curr_block == &quot;Reading_pseudotext_no_click&quot;:&amp;#10;&amp;#10;    # create empty text stimulus&amp;#10;    stim = visual.TextStim(win=win,&amp;#10;                           text=&quot; &quot;,&amp;#10;                           pos=(0, 0),  # center stimulus&amp;#10;                           font=&quot;Times New Roman&quot;,&amp;#10;                           height=0.07)&amp;#10;&amp;#10;    stim.draw()&amp;#10;    win.flip()&amp;#10;&amp;#10;    # clear buffer of all previously recorded key events:&amp;#10;    event.clearEvents()&amp;#10;&amp;#10;    # CREATE CLOCKS:&amp;#10;    my_block_clock = core.Clock()&amp;#10;    my_block_clock.reset()  # start block clock&amp;#10;    start_time = my_block_clock.getTime()  # get start time of block&amp;#10;    # also create trial clock&amp;#10;    my_trial_clock = core.Clock()&amp;#10;&amp;#10;    # loop words in current text&amp;#10;    for trial_idx, curr_word in enumerate(curr_text):&amp;#10;        # print(&quot;current idx: &quot; + str(trial_idx) + &quot;, curr word:&quot; + curr_word)&amp;#10;&amp;#10;        ### prepare &amp; show current word:&amp;#10;&amp;#10;        # get current colour&amp;#10;        curr_colour = curr_colours[trial_idx]&amp;#10;&amp;#10;        # if it's a block with an n-back task, prepare target list as well&amp;#10;        if curr_nback_cond != None:&amp;#10;            curr_target = curr_targets[trial_idx]&amp;#10;            saw_target = False&amp;#10;&amp;#10;        # get duration for current word&amp;#10;        curr_duration = curr_durations[trial_idx] / 1000  # convert ms to seconds&amp;#10;        # print(&quot;duration for current word (in s):&quot;, curr_duration)&amp;#10;&amp;#10;        # get trial number (start counting from 1, so add 1)&amp;#10;        curr_trial_nr = trial_idx + 1&amp;#10;&amp;#10;        # set current word &amp; colour as content of text stimulus&amp;#10;        stim.color = curr_colour&amp;#10;        stim.text = curr_word&amp;#10;&amp;#10;        # show word on screen&amp;#10;        stim.draw()  # draw word on screen&amp;#10;&amp;#10;        # start trial clock &amp; record trial onset time&amp;#10;        my_trial_clock.reset()&amp;#10;        onset_time = my_trial_clock.getTime()&amp;#10;&amp;#10;        ### wait for key response:&amp;#10;        # In blocks with n-back task, participants can press &quot;c&quot; to indicate they saw a target colour.&amp;#10;&amp;#10;        ### start recording responses&amp;#10;        # start while loop that looks for responses&amp;#10;        # --&gt; end while loop only if duration for current word is over&amp;#10;        while my_trial_clock.getTime() &lt; (onset_time + curr_duration):&amp;#10;&amp;#10;            stim.draw()&amp;#10;            win.flip()&amp;#10;&amp;#10;            # check for key responses:&amp;#10;            keys = event.getKeys(['c', 'escape'])&amp;#10;&amp;#10;            # if there were, check responses:&amp;#10;            for key in keys:&amp;#10;&amp;#10;                # if participant pressed button &quot;c&quot; for the first time and it's an n-back condition&amp;#10;                # where they're actually supposed to do that (aka not a reading baseline condition)...&amp;#10;                if key == 'c' and curr_nback_cond != None and saw_target == False:&amp;#10;                    # get reaction time&amp;#10;                    curr_nback_RT = my_trial_clock.getTime() * 1000&amp;#10;                    # send trigger for response:&amp;#10;                    # send_trigger(&quot;response_target&quot;)&amp;#10;                    # only get first target response, we don't care if they press the button more than once:&amp;#10;                    saw_target = True&amp;#10;&amp;#10;                # If esc is pressed, end the experiment:&amp;#10;                elif key == 'escape':&amp;#10;                    # et_abort_exp()  # shut down eyetrigger and download incremental data&amp;#10;                    # close trigger &amp; close experiment&amp;#10;                    # core.wait(time_after_trigger)&amp;#10;                    # parallel.setData(0)&amp;#10;                    core.wait(0.5)&amp;#10;                    core.quit()&amp;#10;&amp;#10;        ### end trial&amp;#10;        print(&quot;\tend paced pseudoword trial&quot;)&amp;#10;        # stop display of current word &amp; send trial offset trigger&amp;#10;        # win.callOnFlip(send_trigger, &quot;trial_offset&quot;)&amp;#10;&amp;#10;        # check whether response was hit, miss, false alarm or correct rejection&amp;#10;        # they saw a target and there was one: hit&amp;#10;        if curr_nback_cond != None:&amp;#10;            if saw_target and curr_target:&amp;#10;                curr_nback_response = &quot;hit&quot;&amp;#10;            # they didn't see a target but there was one: miss&amp;#10;            elif saw_target == False and curr_target:&amp;#10;                curr_nback_response = &quot;miss&quot;&amp;#10;                curr_nback_RT = None&amp;#10;            # they didn't see a target and there was none: correct rejection&amp;#10;            elif saw_target == False and curr_target == False:&amp;#10;                curr_nback_response = &quot;correct rejection&quot;&amp;#10;                curr_nback_RT = None&amp;#10;            # they saw a target but there was none: false alarm&amp;#10;            elif saw_target and curr_target == False:&amp;#10;                curr_nback_response = &quot;false alarm&quot;&amp;#10;        # if it wasn't an n-back task block:&amp;#10;        else:&amp;#10;            curr_target = None&amp;#10;            curr_nback_response = None&amp;#10;            curr_nback_RT = None&amp;#10;&amp;#10;        ### save everything in output csv&amp;#10;        thisExp.addData('colour', curr_colour)&amp;#10;        thisExp.addData('target', curr_target)&amp;#10;        thisExp.addData('nback_response', curr_nback_response)&amp;#10;        thisExp.addData('nback_RT', curr_nback_RT)  # in ms&amp;#10;        thisExp.addData('duration', curr_duration * 1000)  # in ms&amp;#10;        thisExp.addData('text_nr', curr_text_nr)&amp;#10;        thisExp.addData('trial_nr', curr_trial_nr)&amp;#10;        thisExp.addData('block_nr', exp_block_counter)&amp;#10;        thisExp.addData('block_name', curr_block)&amp;#10;        thisExp.addData('block_kind', curr_nback_cond)&amp;#10;        # careful, make sure quotes in the strings are escaped using a&amp;#10;        # quote (weird, I know) so it's properly saved in the CSV:&amp;#10;        thisExp.addData('word', escape_quotes(curr_word))&amp;#10;&amp;#10;        # start a new row in the csv&amp;#10;        thisExp.nextEntry()&amp;#10;&amp;#10;        ### IF TESTING MODE ENABLED: end loop after 4 trials&amp;#10;        if expInfo['testing_mode'] == &quot;yes&quot;:&amp;#10;            if trial_idx == 3:&amp;#10;                break&amp;#10;&amp;#10;    print(&quot;finished presenting trials&quot;)&amp;#10;&amp;#10;    # go to next block!&amp;#10;    exp_block_counter += 1&amp;#10;    print(f&quot;Going to block {exp_block_counter + 1}/20 now!&quot;)&amp;#10;    continueRoutine = False&amp;#10;&amp;#10;    # If there are still blocks left, go to next one.&amp;#10;    # If not, end loop here:&amp;#10;    if exp_block_counter == 20:&amp;#10;        blocks.finished = True&amp;#10;&amp;#10;    # Send end of block trigger:&amp;#10;    # core.wait(time_after_trigger)  # wait 3 ms&amp;#10;    # send block offset trigger&amp;#10;    # send_trigger(&quot;block_offset&quot;)&amp;#10;&amp;#10;# end current routine&amp;#10;# continueRoutine = False" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="pseudotext_paced_block" valType="code" updates="None" name="name"/>
      </CodeComponent>
    </Routine>
    <Routine name="education">
      <RoutineSettingsComponent name="education" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="True" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="education" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <FormComponent name="edu_form" plugin="None">
        <Param val="rows" valType="str" updates="constant" name="Data Format"/>
        <Param val="Open Sans" valType="str" updates="constant" name="Font"/>
        <Param val="0.03" valType="num" updates="constant" name="Item Padding"/>
        <Param val="education_form.csv" valType="file" updates="constant" name="Items"/>
        <Param val="False" valType="bool" updates="constant" name="Randomize"/>
        <Param val="custom..." valType="str" updates="constant" name="Style"/>
        <Param val="0.03" valType="num" updates="constant" name="Text Height"/>
        <Param val="1.0000, 1.0000, 1.0000" valType="color" updates="constant" name="borderColor"/>
        <Param val="rgb" valType="str" updates="constant" name="colorSpace"/>
        <Param val="1" valType="num" updates="constant" name="contrast"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="1.0000, 1.0000, 1.0000" valType="color" updates="constant" name="fillColor"/>
        <Param val="-1.0000, -1.0000, -1.0000" valType="color" updates="constant" name="itemColor"/>
        <Param val="0.9608, 0.8431, 0.6863" valType="color" updates="constant" name="markerColor"/>
        <Param val="edu_form" valType="code" updates="None" name="name"/>
        <Param val="" valType="num" updates="constant" name="opacity"/>
        <Param val="(0, 0)" valType="list" updates="constant" name="pos"/>
        <Param val="-1.0000, -1.0000, -1.0000" valType="color" updates="constant" name="responseColor"/>
        <Param val="False" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="(1.3, 0.9)" valType="list" updates="constant" name="size"/>
        <Param val="" valType="code" updates="None" name="startEstim"/>
        <Param val="time (s)" valType="str" updates="None" name="startType"/>
        <Param val="0" valType="code" updates="None" name="startVal"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="True" valType="bool" updates="None" name="syncScreenRefresh"/>
        <Param val="" valType="code" updates="None" name="validator"/>
      </FormComponent>
      <ButtonComponent name="edu_button" plugin="None">
        <Param val="center" valType="str" updates="constant" name="anchor"/>
        <Param val="True" valType="bool" updates="constant" name="bold"/>
        <Param val="None" valType="color" updates="constant" name="borderColor"/>
        <Param val="0" valType="num" updates="constant" name="borderWidth"/>
        <Param val="" valType="extendedCode" updates="constant" name="callback"/>
        <Param val="white" valType="color" updates="constant" name="color"/>
        <Param val="rgb" valType="str" updates="constant" name="colorSpace"/>
        <Param val="1" valType="num" updates="constant" name="contrast"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="darkgrey" valType="color" updates="constant" name="fillColor"/>
        <Param val="Open Sans" valType="str" updates="constant" name="font"/>
        <Param val="True" valType="bool" updates="constant" name="forceEndRoutine"/>
        <Param val="False" valType="bool" updates="constant" name="italic"/>
        <Param val="0.06" valType="num" updates="constant" name="letterHeight"/>
        <Param val="edu_button" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="constant" name="oncePerClick"/>
        <Param val="" valType="num" updates="constant" name="opacity"/>
        <Param val="0" valType="num" updates="constant" name="ori"/>
        <Param val="" valType="num" updates="constant" name="padding"/>
        <Param val="(0.3, -0.35)" valType="list" updates="constant" name="pos"/>
        <Param val="none" valType="str" updates="None" name="save"/>
        <Param val="False" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="(0.3, 0.12)" valType="list" updates="constant" name="size"/>
        <Param val="" valType="code" updates="None" name="startEstim"/>
        <Param val="condition" valType="str" updates="None" name="startType"/>
        <Param val="$edu_form.complete" valType="code" updates="None" name="startVal"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="True" valType="bool" updates="None" name="syncScreenRefresh"/>
        <Param val="Weiter" valType="str" updates="constant" name="text"/>
        <Param val="button onset" valType="str" updates="constant" name="timeRelativeTo"/>
        <Param val="from exp settings" valType="str" updates="None" name="units"/>
        <Param val="" valType="code" updates="None" name="validator"/>
      </ButtonComponent>
    </Routine>
    <Routine name="no_text_blocks_self_paced">
      <RoutineSettingsComponent name="no_text_blocks_self_paced" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="no_text_blocks_self_paced" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <CodeComponent name="no_text_and_training_2" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="/* Syntax Error: Fix Python code */" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="#################################################&amp;#10;#          Blocks w/o text – self-paced         #&amp;#10;#################################################&amp;#10;# this routine is for all blocks where there are&amp;#10;# coloured rectangles instead of words&amp;#10;&amp;#10;# Use loop here that runs the non-text blocks&amp;#10;# until we have to display a main text block (in this case we exit the routine).&amp;#10;&amp;#10;while True:&amp;#10;    event. Mouse(visible=False)&amp;#10;    # keep background ivory&amp;#10;    win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;    win.flip()&amp;#10;&amp;#10;    # clear buffer of all previously recorded key events:&amp;#10;    event.clearEvents()&amp;#10;&amp;#10;    ### specify settings for the current block&amp;#10;&amp;#10;    ### Prepare stimuli:&amp;#10;&amp;#10;    # get block kind&amp;#10;    curr_block = all_blocks[exp_block_counter]&amp;#10;&amp;#10;    # Check whether it's one of the non-text tasks.&amp;#10;    # If current block is a text block, skip this routine and go to the next.&amp;#10;    if curr_block not in [&quot;click_training&quot;, &quot;0back_single_training&quot;, &quot;1back_single_training1&quot;, &quot;1back_single_training2&quot;,&amp;#10;                          &quot;1back_single_main&quot;, &quot;2back_single_training1&quot;, &quot;2back_single_training2&quot;, &quot;2back_single_main&quot;]:&amp;#10;        print(f&quot;this is block {curr_block}&quot;)&amp;#10;        print(f&quot;\tskipping self-paced n-back routine&quot;)&amp;#10;        break&amp;#10;&amp;#10;    # if it's one of the non-text blocks, though, prepare stimuli:&amp;#10;    else:&amp;#10;        print(f&quot;this is block {curr_block}&quot;)&amp;#10;        print(f&quot;\tstart preparing block {curr_block}&quot;)&amp;#10;        # print(&quot;\t&quot; + curr_block + &quot; is not a text block - preparing rect as stim now&quot;)&amp;#10;&amp;#10;        # keep background ivory&amp;#10;        win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;        win.flip()&amp;#10;&amp;#10;        ### Show instructions&amp;#10;        # set instruction text&amp;#10;        if curr_block == &quot;0back_single_training&quot;:&amp;#10;            # create text boxes&amp;#10;            instr_text_stim1 = visual.TextStim(win,&amp;#10;                                               text=locals()[&quot;instr_0back_single_training1&quot;],&amp;#10;                                               height=0.025,  # font height relative to height of screen&amp;#10;                                               pos=(0, 0.30),  # move instructions up a bit&amp;#10;                                               color=&quot;black&quot;)&amp;#10;            instr_text_stim2 = visual.TextStim(win,&amp;#10;                                               text=locals()[&quot;instr_0back_single_training2&quot;],&amp;#10;                                               height=0.025,  # font height: 5° visual angle&amp;#10;                                               pos=(0, -0.35),  # move instructions down a bit&amp;#10;                                               color=&quot;black&quot;)&amp;#10;            # create &quot;empty&quot; circle as stimulus&amp;#10;            instr_colour_circle_stim = visual.Circle(win=win,&amp;#10;                                                     radius=0.065,&amp;#10;                                                     pos=(0, 0.075))  # move circle slightly down&amp;#10;&amp;#10;            # set current target colour as colour of circle:&amp;#10;            instr_colour_circle_stim.fillColor = target_colours_list[0]&amp;#10;&amp;#10;            # create ImageStim object&amp;#10;            curr_instr_pic = visual.ImageStim(win,&amp;#10;                                              size=(0.55, 0.25),&amp;#10;                                              pos=(0, -0.15),&amp;#10;                                              image=locals()[&quot;instr_pic_0back&quot;])  # set path to image here&amp;#10;&amp;#10;        else:&amp;#10;            instr_text = locals()[&quot;instr_&quot; + curr_block]&amp;#10;            # create text box&amp;#10;            instr_text_stim = visual.TextStim(win,&amp;#10;                                              text=instr_text,&amp;#10;                                              height=0.025,  # font height relative to height of screen&amp;#10;                                              pos=(0, 0.2),  # move up a bit&amp;#10;                                              color=&quot;black&quot;)&amp;#10;            # create ImageStim object&amp;#10;            curr_instr_pic = visual.ImageStim(win,&amp;#10;                                              size=(0.8, 0.3),&amp;#10;                                              pos=(0, -0.2),&amp;#10;                                              image=locals()[&quot;instr_pic_&quot; + curr_block])  # set path to image here&amp;#10;&amp;#10;        # display the text &amp; image on screen&amp;#10;        if curr_block == &quot;0back_single_training&quot;:&amp;#10;            # show instructions on screen&amp;#10;            instr_text_stim1.draw()&amp;#10;            instr_text_stim2.draw()&amp;#10;            instr_colour_circle_stim.draw()&amp;#10;            curr_instr_pic.draw()&amp;#10;            win.flip()&amp;#10;            core.wait(3)  # wait for 3s before starting response window&amp;#10;&amp;#10;            # display the text &amp; the circle on screen until Space is pressed&amp;#10;            while True:&amp;#10;                instr_text_stim1.draw()&amp;#10;                instr_text_stim2.draw()&amp;#10;                instr_colour_circle_stim.draw()&amp;#10;                curr_instr_pic.draw()&amp;#10;                win.flip()&amp;#10;                # end screen if participant presses space&amp;#10;                if event.getKeys(['space']):&amp;#10;                    print(&quot;\t\tstart current block&quot;)&amp;#10;                    skip_curr_block = False&amp;#10;                    break&amp;#10;&amp;#10;        elif curr_block in [&quot;1back_single_training2&quot;, &quot;2back_single_training2&quot;]:&amp;#10;            # draw instructions on screen&amp;#10;            instr_text_stim.draw()&amp;#10;            curr_instr_pic.draw()&amp;#10;            win.flip()&amp;#10;            core.wait(3)  # wait for 3 s before starting response window&amp;#10;&amp;#10;            while True:&amp;#10;                instr_text_stim.draw()&amp;#10;                curr_instr_pic.draw()&amp;#10;                win.flip()&amp;#10;                # skip current block (aka the second training block))&amp;#10;                if event.getKeys(['space']):&amp;#10;                    print(&quot;\t\tstart next block - skip second training block&quot;)&amp;#10;                    skip_curr_block = True&amp;#10;                    break&amp;#10;                # repeat training (aka run current block, which is the second training block)&amp;#10;                elif event.getKeys(['w']):&amp;#10;                    print(&quot;\t\trepeat training block&quot;)&amp;#10;                    skip_curr_block = False&amp;#10;                    break&amp;#10;&amp;#10;        # for regular blocks that can't be repeated:&amp;#10;        else:&amp;#10;            while True:&amp;#10;                instr_text_stim.draw()&amp;#10;                curr_instr_pic.draw()&amp;#10;                win.flip()&amp;#10;                # start current block&amp;#10;                if event.getKeys(['space']):&amp;#10;                    print(&quot;\t\tstart current block&quot;)&amp;#10;                    skip_curr_block = False&amp;#10;                    break&amp;#10;&amp;#10;        # only run this if the current block shall not be skipped:&amp;#10;        if skip_curr_block == False:&amp;#10;            ### change background colour&amp;#10;            win.setColor(dark_bg_col, colorSpace='rgb')&amp;#10;            win.flip()&amp;#10;&amp;#10;            # don't show questions&amp;#10;            skip_questions = True&amp;#10;            training_Qs = False&amp;#10;&amp;#10;            # get n-back condition:&amp;#10;            curr_nback_cond = curr_block[0]  # get first character of block name&amp;#10;&amp;#10;            # if it is a 0, 1 or 2, set that as current n-back level:&amp;#10;            if curr_nback_cond in ['0', '1', '2']:&amp;#10;                curr_nback_cond == int(curr_nback_cond)&amp;#10;            # if it's neither 0, 1 nor 2, it has to be a block without n-back,&amp;#10;            # so set curr_nback_cond to None&amp;#10;            else:&amp;#10;                curr_nback_cond = None&amp;#10;&amp;#10;            print(f&quot;\tcurrent n-back condition: {curr_nback_cond}&quot;)&amp;#10;&amp;#10;            # get list with targets &amp; list with colours&amp;#10;            curr_targets = all_target_lists[exp_block_counter]&amp;#10;            curr_colours = all_colour_lists[exp_block_counter]&amp;#10;&amp;#10;            ### Start block loop&amp;#10;            # depending on condition, create arrays for saving response&amp;#10;            # times - we need that later for the paced task of the 1- and 2-back single blocks&amp;#10;            if curr_block == &quot;1back_single_main&quot;:&amp;#10;                oneback_single_paced_durations = []&amp;#10;            elif curr_block == &quot;2back_single_main&quot;:&amp;#10;                twoback_single_paced_durations = []&amp;#10;&amp;#10;            # CREATE CLOCKS:&amp;#10;            my_block_clock = core.Clock()&amp;#10;            my_block_clock.reset()  # start block clock&amp;#10;            start_time = my_block_clock.getTime()  # get start time of block&amp;#10;            # also create trial clock&amp;#10;            my_trial_clock = core.Clock()&amp;#10;&amp;#10;            # create empty stimulus&amp;#10;            stim = visual.Rect(win=win,&amp;#10;                               width=0.4,  # width = 3 * 1° visual angle (to make it look rectangle-ish)&amp;#10;                               height=0.15,  # height = 1° visual angle (just like words)&amp;#10;                               # colorSpace = &quot;hex&quot;,&amp;#10;                               pos=(0, 0))  # center stimulus&amp;#10;&amp;#10;            stim.draw()&amp;#10;            win.flip()&amp;#10;&amp;#10;            # clear buffer of all previously recorded key events:&amp;#10;            event.clearEvents()&amp;#10;&amp;#10;            # loop colours in current text&amp;#10;            for trial_idx, curr_col in enumerate(curr_colours):&amp;#10;                # print(&quot;current idx: &quot; + str(trial_idx) + &quot;, curr colour:&quot; + curr_col)&amp;#10;&amp;#10;                ### prepare &amp; show current trial:&amp;#10;                my_trial_clock.reset()  # start trial clock&amp;#10;                onset_time = my_trial_clock.getTime()&amp;#10;&amp;#10;                # if it's a block with an n-back task, prepare target list&amp;#10;                if curr_nback_cond != None:&amp;#10;                    curr_target = curr_targets[trial_idx]&amp;#10;                    saw_target = False&amp;#10;&amp;#10;                # get trial number (start counting from 1, so add 1)&amp;#10;                curr_trial_nr = trial_idx + 1&amp;#10;&amp;#10;                ### ISI: wait for 200 ms&amp;#10;                while my_trial_clock.getTime() &lt; 0.2:&amp;#10;                    win.flip()  # don't draw anything&amp;#10;                    core.wait(0.005)  # wait 5 ms before next iteration&amp;#10;&amp;#10;                # set current colour as colour of rectangle&amp;#10;                stim.fillColor = curr_col&amp;#10;&amp;#10;                # draw stimulus on screen&amp;#10;                stim.draw()&amp;#10;                win.flip()&amp;#10;&amp;#10;                # show stimulus on screen &amp; send trigger:&amp;#10;                stim.draw()  # draw stimulus on screen&amp;#10;                # update the window to clear the screen and display&amp;#10;                # the stimulus&amp;#10;&amp;#10;                # start trial clock for measuring RTs from stimulus onset&amp;#10;                my_trial_clock.reset()&amp;#10;&amp;#10;                # onset_time = my_trial_clock.getTime()&amp;#10;&amp;#10;                ### wait for key response:&amp;#10;                # In blocks with n-back task, participants can press &quot;c&quot; to indicate they saw a target colour and &quot;space&quot; to go to the next word/stimulus.&amp;#10;                # In blocks without n-back task, participants can only press &quot;space&quot; to go to the next stimulus.&amp;#10;                # print(&quot;start tracking key responses&quot;)&amp;#10;&amp;#10;                ### start recording responses&amp;#10;                # start &quot;endless&quot; while loop that looks for responses&amp;#10;                # in each iteration, draw word on screen&amp;#10;                continue_trial = True&amp;#10;                while continue_trial:&amp;#10;&amp;#10;                    # draw stimulus on screen&amp;#10;                    stim.draw()&amp;#10;                    win.flip()&amp;#10;&amp;#10;                    # check for responses:&amp;#10;                    keys = event.getKeys(['space', 'c', 'escape'])&amp;#10;&amp;#10;                    # check if there was a response. If there wasn't, we can go straight&amp;#10;                    # to the next iteration which will hopefully save us some dropped&amp;#10;                    # frames in the flicker.&amp;#10;                    for key in keys:&amp;#10;&amp;#10;                        # if participant pressed the space bar on their keyboard...&amp;#10;                        if key == 'space':&amp;#10;                            # get reaction time&amp;#10;                            curr_duration = my_trial_clock.getTime() * 1000&amp;#10;                            # send trigger for response:&amp;#10;                            # send_trigger(&quot;response_continue&quot;)&amp;#10;&amp;#10;                            # break while loop to go to next trial&amp;#10;                            continue_trial = False&amp;#10;&amp;#10;                        # if participant pressed button &quot;c&quot; for the first time and it's an n-back condition&amp;#10;                        # where they're actually supposed to do that (aka not a reading baseline condition)...&amp;#10;                        elif key == 'c' and curr_nback_cond != None and saw_target == False:&amp;#10;                            # get reaction time&amp;#10;                            curr_nback_RT = my_trial_clock.getTime() * 1000&amp;#10;&amp;#10;                            # send trigger for response:&amp;#10;                            # send_trigger(&quot;response_target&quot;)&amp;#10;&amp;#10;                            # only get first target response, we don't care if they press the button more than once:&amp;#10;                            saw_target = True&amp;#10;&amp;#10;                        # If esc is pressed, end the experiment:&amp;#10;                        elif key == 'escape':&amp;#10;                            # et_abort_exp()  # shut down eyetrigger and download incremental data&amp;#10;                            # make sure parallel port line is cleared&amp;#10;                            # core.wait(time_after_trigger)&amp;#10;                            # parallel.setData(0)&amp;#10;                            core.wait(0.5)&amp;#10;                            # end experiment&amp;#10;                            core.quit()&amp;#10;&amp;#10;                    # Check for timeout - if more than 1.5 or 2 seconds have passed, move to the next trial&amp;#10;                    if my_trial_clock.getTime() - trial_start_time &gt;= 1.5 and curr_block in [&amp;#10;                        &quot;0back_single_training&quot;, &quot;1back_single_training1&quot;, &quot;1back_single_training2&quot;, &quot;1back_single_main&quot;]:&amp;#10;                        curr_duration = 1500&amp;#10;                        continue_trial = False&amp;#10;                    elif my_trial_clock.getTime() - trial_start_time &gt;= 2 and curr_block in [&amp;#10;                        &quot;2back_single_training1&quot;, &quot;2back_single_training2&quot;, &quot;2back_single_main&quot;]:&amp;#10;                        curr_duration = 2000&amp;#10;                        continue_trial = False&amp;#10;&amp;#10;                ### end trial&amp;#10;                # print(&quot;end trial&quot;)&amp;#10;&amp;#10;                # check whether response was hit, miss, false alarm or correct rejection&amp;#10;                # they saw a target and there was one: hit&amp;#10;                if curr_nback_cond != None:&amp;#10;                    if saw_target and curr_target:&amp;#10;                        curr_nback_response = &quot;hit&quot;&amp;#10;                    # they didn't see a target but there was one: miss&amp;#10;                    elif saw_target == False and curr_target:&amp;#10;                        curr_nback_response = &quot;miss&quot;&amp;#10;                        curr_nback_RT = None&amp;#10;                    # they didn't see a target and there was none: correct rejection&amp;#10;                    elif saw_target == False and curr_target == False:&amp;#10;                        curr_nback_response = &quot;correct rejection&quot;&amp;#10;                        curr_nback_RT = None&amp;#10;                    # they saw a target but there was none: false alarm&amp;#10;                    elif saw_target and curr_target == False:&amp;#10;                        curr_nback_response = &quot;false alarm&quot;&amp;#10;                # if it wasn't an n-back task block:&amp;#10;                else:&amp;#10;                    curr_target = None&amp;#10;                    curr_nback_response = None&amp;#10;                    curr_nback_RT = None&amp;#10;&amp;#10;                ### save everything in output csv&amp;#10;                thisExp.addData('colour', curr_col)&amp;#10;                thisExp.addData('target', curr_target)&amp;#10;                if curr_block == &quot;0back_single_training&quot;:&amp;#10;                    thisExp.addData('curr_0back_target', target_colours_list[0])&amp;#10;                thisExp.addData('nback_response', curr_nback_response)&amp;#10;                thisExp.addData('nback_RT', curr_nback_RT)  # in ms&amp;#10;                thisExp.addData('duration', curr_duration)  # in ms&amp;#10;                thisExp.addData('trial_nr', curr_trial_nr)&amp;#10;                thisExp.addData('block_nr', exp_block_counter)&amp;#10;                thisExp.addData('block_name', curr_block)&amp;#10;                thisExp.addData('block_kind', curr_nback_cond)&amp;#10;&amp;#10;                # start a new row in the csv&amp;#10;                thisExp.nextEntry()&amp;#10;&amp;#10;                # depending on condition, save response times and words in previously created arrays&amp;#10;                # we need that later for the paced reading tasks&amp;#10;                if curr_block == &quot;1back_single_main&quot;:&amp;#10;                    oneback_single_paced_durations.append(curr_duration)&amp;#10;                elif curr_block == &quot;2back_single_main&quot;:&amp;#10;                    twoback_single_paced_durations.append(curr_duration)&amp;#10;&amp;#10;                ### IF TESTING MODE ENABLED: end loop after 4 trials&amp;#10;                if expInfo['testing_mode'] == &quot;yes&quot;:&amp;#10;                    if trial_idx == 3:&amp;#10;                        break&amp;#10;&amp;#10;            print(&quot;\t\tfinished presenting trials&quot;)&amp;#10;&amp;#10;            # change background colour from grey (RGB: 10, 10, 10)&amp;#10;            # to ivory (RGB: 240, 223, 204)&amp;#10;            win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;            win.flip()&amp;#10;&amp;#10;        # add 1 to the block counter to go load the next block&amp;#10;        exp_block_counter = exp_block_counter + 1&amp;#10;        print(f&quot;\tGoing to block {exp_block_counter + 1}/20 now!&quot;)&amp;#10;&amp;#10;# go to next routine&amp;#10;# print(&quot;going to next routine&quot;)&amp;#10;continueRoutine = False" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="no_text_and_training_2" valType="code" updates="None" name="name"/>
      </CodeComponent>
    </Routine>
    <Routine name="no_text_blocks_paced">
      <RoutineSettingsComponent name="no_text_blocks_paced" plugin="None">
        <Param val="none" valType="str" updates="None" name="backgroundFit"/>
        <Param val="" valType="str" updates="None" name="backgroundImg"/>
        <Param val="$[0,0,0]" valType="color" updates="None" name="color"/>
        <Param val="rgb" valType="str" updates="None" name="colorSpace"/>
        <Param val="" valType="str" updates="constant" name="desc"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="" valType="code" updates="None" name="durationEstim"/>
        <Param val="no_text_blocks_paced" valType="code" updates="None" name="name"/>
        <Param val="True" valType="bool" updates="None" name="saveStartStop"/>
        <Param val="" valType="code" updates="constant" name="skipIf"/>
        <Param val="duration (s)" valType="str" updates="None" name="stopType"/>
        <Param val="" valType="code" updates="constant" name="stopVal"/>
        <Param val="False" valType="bool" updates="None" name="useWindowParams"/>
      </RoutineSettingsComponent>
      <CodeComponent name="no_text_no_click" plugin="None">
        <Param val="" valType="extendedCode" updates="constant" name="Before Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Before JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="Begin JS Routine"/>
        <Param val="#################################################&amp;#10;#            Blocks w/o text – paced            #&amp;#10;#################################################&amp;#10;# this routine is for all blocks where there are&amp;#10;# coloured rectangles instead of words and participants are presented with a paced version, i.e., rectangles are presented based on their reaction times in a&amp;#10;&amp;#10;# Use loop here that runs the non-text blocks&amp;#10;# until we have to display a main text block (in this case we exit the routine).&amp;#10;&amp;#10;event. Mouse(visible=False)&amp;#10;# keep background ivory&amp;#10;win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;win.flip()&amp;#10;&amp;#10;# clear buffer of all previously recorded key events:&amp;#10;event.clearEvents()&amp;#10;&amp;#10;### Prepare stimuli:&amp;#10;&amp;#10;# get block kind&amp;#10;curr_block = all_blocks[exp_block_counter]&amp;#10;# print(&quot;start preparing block &quot; + curr_block)&amp;#10;&amp;#10;# Check whether it's one of the non-text tasks.&amp;#10;# If current block is a text block, skip this routine and go to the next.&amp;#10;if curr_block not in [&quot;1back_single_main_no_click&quot;, &quot;2back_single_main_no_click&quot;]:&amp;#10;    print(f&quot;this is block {curr_block}&quot;)&amp;#10;    print(&quot;\tskipping paced non-text routine&quot;)&amp;#10;    # skip questions &amp; end current routine&amp;#10;    # skip_questions = True&amp;#10;    continueRoutine = False&amp;#10;    # break&amp;#10;&amp;#10;else:&amp;#10;    print(f&quot;\tstart preparing block {curr_block}&quot;)&amp;#10;    if curr_block == &quot;1back_single_main_no_click&quot;:&amp;#10;&amp;#10;        # exclude all RTs where participant was way too fast (&lt; 50 ms) or&amp;#10;        # too slow (&gt; 1.5 s)&amp;#10;        # print(&quot;\toneback_single_paced_durations:&quot;, oneback_single_paced_durations)&amp;#10;&amp;#10;        filtered_durations_oneback_single = []&amp;#10;        for duration in oneback_single_paced_durations:&amp;#10;            if 50 &lt;= duration &lt;= 1500:&amp;#10;                filtered_durations_oneback_single.append(duration)&amp;#10;        # count n of trials:&amp;#10;        oneback_single_trials = len(filtered_durations_oneback_single)&amp;#10;        # get time it took in total:&amp;#10;        oneback_single_time_total = sum(filtered_durations_oneback_single)  # in ms&amp;#10;&amp;#10;&amp;#10;        # Check average RT / rectangle&amp;#10;        RT_per_rectangle_oneback_single = oneback_single_time_total / oneback_single_trials&amp;#10;        print(&quot;\taverage RT per rectangle in ms for single 1back:&quot;, RT_per_rectangle_oneback_single)&amp;#10;&amp;#10;        # save this in the output csv:&amp;#10;        thisExp.addData('RT_per_rect_1back_single', RT_per_rectangle_oneback_single)&amp;#10;&amp;#10;    elif curr_block == &quot;2back_single_main_no_click&quot;:&amp;#10;&amp;#10;        # exclude all RTs where participant was way too fast (&lt; 50 ms) or&amp;#10;        # too slow (&gt; 2.0 s)&amp;#10;        # print(&quot;\ttwoback_single_paced_durations:&quot;, twoback_single_paced_durations)&amp;#10;&amp;#10;        filtered_durations_twoback_single = []&amp;#10;        for duration in twoback_single_paced_durations:&amp;#10;            if 50 &lt;= duration &lt;= 2000:&amp;#10;                filtered_durations_twoback_single.append(duration)&amp;#10;        # count n of trials:&amp;#10;        twoback_single_trials = len(filtered_durations_twoback_single)&amp;#10;        # get time it took in total:&amp;#10;        twoback_single_time_total = sum(filtered_durations_twoback_single)  # in ms&amp;#10;&amp;#10;        # Check average RT / rectangle&amp;#10;        RT_per_rectangle_twoback_single = twoback_single_time_total / twoback_single_trials&amp;#10;        print(&quot;\taverage RT per rectangle in ms for single 2back:&quot;, RT_per_rectangle_twoback_single)&amp;#10;&amp;#10;        # save this in the output csv:&amp;#10;        thisExp.addData('RT_per_rect_2back_single', RT_per_rectangle_twoback_single)&amp;#10;&amp;#10;&amp;#10;    # keep background ivory&amp;#10;    win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;    win.flip()&amp;#10;&amp;#10;    ### Show instructions&amp;#10;    # set instruction text&amp;#10;    instr_text = locals()[&quot;instr_&quot; + curr_block]&amp;#10;    # create text box&amp;#10;    instr_text_stim = visual.TextStim(win,&amp;#10;                                      text=instr_text,&amp;#10;                                      height=0.025,  # font height relative to height of screen&amp;#10;                                      pos=(0, 0.2),  # move up a bit&amp;#10;                                      color=&quot;black&quot;)&amp;#10;    # create ImageStim object&amp;#10;    curr_instr_pic = visual.ImageStim(win,&amp;#10;                                      size=(0.8, 0.3),&amp;#10;                                      pos=(0, -0.2),&amp;#10;                                      image=locals()[&quot;instr_pic_&quot; + curr_block])  # set path to image here&amp;#10;&amp;#10;    # show instructions on screen&amp;#10;    instr_text_stim.draw()&amp;#10;    curr_instr_pic.draw()&amp;#10;    win.flip()&amp;#10;    core.wait(3)  # wait for 3s before starting response window&amp;#10;&amp;#10;    # display the text on screen&amp;#10;    while True:&amp;#10;        # keep background ivory&amp;#10;        win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;        instr_text_stim.draw()&amp;#10;        curr_instr_pic.draw()&amp;#10;        win.flip()&amp;#10;        # end showing screen if participant presses space&amp;#10;        if 'space' in event.getKeys():&amp;#10;            break&amp;#10;&amp;#10;    ### change background colour&amp;#10;    win.setColor(dark_bg_col, colorSpace='rgb')&amp;#10;    win.flip()&amp;#10;&amp;#10;    # don't show questions&amp;#10;    skip_questions = True&amp;#10;    training_Qs = False&amp;#10;&amp;#10;    # get n-back condition:&amp;#10;    curr_nback_cond = curr_block[0]  # get first character of block name&amp;#10;&amp;#10;    # if it is a 1 or a 2, set that as current n-back level:&amp;#10;    if curr_nback_cond in ['1', '2']:&amp;#10;        curr_nback_cond == int(curr_nback_cond)&amp;#10;    # if it's neither 1 nor 2, it has to be a block without n-back,&amp;#10;    # so set curr_nback_cond to None&amp;#10;    else:&amp;#10;        curr_nback_cond = None&amp;#10;&amp;#10;    print(f&quot;\tcurrent n-back condition: {curr_nback_cond}&quot;)&amp;#10;&amp;#10;    # get list with targets &amp; list with colours&amp;#10;    curr_targets = all_target_lists[exp_block_counter]&amp;#10;    curr_colours = all_colour_lists[exp_block_counter]&amp;#10;&amp;#10;    # determine duration per rectangle for this block&amp;#10;    # we use average time per rectangle as duration here and add an increment over the duration of the block&amp;#10;    if curr_block == &quot;1back_single_main_no_click&quot;:&amp;#10;        curr_durations = []&amp;#10;        for rect in curr_targets:&amp;#10;            curr_durations.append(RT_per_rectangle_oneback_single)&amp;#10;&amp;#10;        # Latency factor of an incremental increase (increment per trial = 3 ms) added over duration of entire&amp;#10;        # block assuming that participants get tired of the course of the block and thus need a bit more&amp;#10;        # time:&amp;#10;        # Increment of 3 ms per trial&amp;#10;        increment_per_trial = 3&amp;#10;        for i in range(len(curr_durations)):&amp;#10;            # Calculate incremental increase for current trial&amp;#10;            increment = i * increment_per_trial&amp;#10;            # Add incremental increase to current trial's duration&amp;#10;            curr_durations[i] += increment&amp;#10;&amp;#10;    elif curr_block == &quot;2back_single_main_no_click&quot;:&amp;#10;        curr_durations = []&amp;#10;        for rect in curr_targets:&amp;#10;            curr_durations.append(RT_per_rectangle_twoback_single)&amp;#10;&amp;#10;        # Latency factor of an incremental increase (increment per trial = 3 ms) added over duration of entire&amp;#10;        # block assuming that participants get tired of the course of the block and thus need a bit more&amp;#10;        # time:&amp;#10;        # Increment of 3 ms per trial&amp;#10;        increment_per_trial = 3&amp;#10;        for i in range(len(curr_durations)):&amp;#10;            # Calculate incremental increase for current trial&amp;#10;            increment = i * increment_per_trial&amp;#10;            # Add incremental increase to current trial's duration&amp;#10;            curr_durations[i] += increment&amp;#10;&amp;#10;    ### Start block loop&amp;#10;&amp;#10;    # CREATE CLOCKS:&amp;#10;    my_block_clock = core.Clock()&amp;#10;    my_block_clock.reset()  # start block clock&amp;#10;    start_time = my_block_clock.getTime()  # get start time of block&amp;#10;    # also create trial clock&amp;#10;    my_trial_clock = core.Clock()&amp;#10;&amp;#10;    # create empty stimulus&amp;#10;    stim = visual.Rect(win=win,&amp;#10;                       width=0.4,  # width = 3 * 1° visual angle (to make it look rectangle-ish)&amp;#10;                       height=0.15,  # height = 1° visual angle (just like words)&amp;#10;                       # colorSpace = &quot;hex&quot;,&amp;#10;                       pos=(0, 0))  # center stimulus&amp;#10;&amp;#10;    stim.draw()&amp;#10;    win.flip()&amp;#10;&amp;#10;    # clear buffer of all previously recorded key events:&amp;#10;    event.clearEvents()&amp;#10;&amp;#10;    # loop colours in current text&amp;#10;    for trial_idx, curr_col in enumerate(curr_colours):&amp;#10;        # print(&quot;current idx: &quot; + str(trial_idx) + &quot;, curr colour:&quot; + curr_col)&amp;#10;&amp;#10;        ### prepare &amp; show current trial:&amp;#10;        my_trial_clock.reset()  # start trial clock&amp;#10;        onset_time = my_trial_clock.getTime()&amp;#10;&amp;#10;        # if it's a block with an n-back task, prepare target list&amp;#10;        if curr_nback_cond != None:&amp;#10;            curr_target = curr_targets[trial_idx]&amp;#10;            saw_target = False&amp;#10;&amp;#10;        # get duration for current trial&amp;#10;        curr_duration = curr_durations[trial_idx] / 1000  # convert ms to seconds&amp;#10;&amp;#10;        # get trial number (start counting from 1, so add 1)&amp;#10;        curr_trial_nr = trial_idx + 1&amp;#10;&amp;#10;        ### ISI: wait for 200 ms&amp;#10;        while my_trial_clock.getTime() &lt; 0.2:&amp;#10;            win.flip()  # don't draw anything&amp;#10;            core.wait(0.005)  # wait 5 ms before next iteration&amp;#10;&amp;#10;        # set current colour as colour of rectangle&amp;#10;        stim.fillColor = curr_col&amp;#10;&amp;#10;        # draw stimulus on screen&amp;#10;        stim.draw()&amp;#10;        win.flip()&amp;#10;&amp;#10;        # show stimulus on screen &amp; send trigger:&amp;#10;        stim.draw()  # draw stimulus on screen&amp;#10;        # update the window to clear the screen and display&amp;#10;        # the stimulus&amp;#10;&amp;#10;        # start trial clock for measuring RTs from stimulus onset&amp;#10;        my_trial_clock.reset()&amp;#10;        onset_time = my_trial_clock.getTime()&amp;#10;&amp;#10;        ### start recording responses&amp;#10;        # start &quot;endless&quot; while loop that looks for responses&amp;#10;        # --&gt; end while loop only if duration for current word is over&amp;#10;        while my_trial_clock.getTime() &lt; (onset_time + curr_duration):&amp;#10;&amp;#10;            # draw stimulus on screen&amp;#10;            stim.draw()&amp;#10;            win.flip()&amp;#10;&amp;#10;            # check for responses:&amp;#10;            keys = event.getKeys(['c', 'escape'])&amp;#10;&amp;#10;            # check if there was a response. If there wasn't, we can go straight&amp;#10;            # to the next iteration which will hopefully save us some dropped&amp;#10;            # frames in the flicker.&amp;#10;            for key in keys:&amp;#10;&amp;#10;                # if participant pressed button &quot;c&quot; for the first time and it's an n-back condition&amp;#10;                # where they're actually supposed to do that (aka not a reading baseline condition)...&amp;#10;                if key == 'c' and curr_nback_cond != None and saw_target == False:&amp;#10;                    # get reaction time&amp;#10;                    curr_nback_RT = my_trial_clock.getTime() * 1000&amp;#10;                    # send trigger for response:&amp;#10;                    # send_trigger(&quot;response_target&quot;)&amp;#10;                    # only get first target response, we don't care if they press the button more than once:&amp;#10;                    saw_target = True&amp;#10;&amp;#10;                # If esc is pressed, end the experiment:&amp;#10;                elif key == 'escape':&amp;#10;                    # et_abort_exp()  # shut down eyetrigger and download incremental data&amp;#10;                    # close trigger &amp; close experiment&amp;#10;                    # core.wait(time_after_trigger)&amp;#10;                    # parallel.setData(0)&amp;#10;                    core.wait(0.5)&amp;#10;                    core.quit()&amp;#10;&amp;#10;        ### end trial&amp;#10;        # print(&quot;end paced rect trial&quot;)&amp;#10;&amp;#10;        # check whether response was hit, miss, false alarm or correct rejection&amp;#10;        # they saw a target and there was one: hit&amp;#10;        if curr_nback_cond != None:&amp;#10;            if saw_target and curr_target:&amp;#10;                curr_nback_response = &quot;hit&quot;&amp;#10;            # they didn't see a target but there was one: miss&amp;#10;            elif saw_target == False and curr_target:&amp;#10;                curr_nback_response = &quot;miss&quot;&amp;#10;                curr_nback_RT = None&amp;#10;            # they didn't see a target and there was none: correct rejection&amp;#10;            elif saw_target == False and curr_target == False:&amp;#10;                curr_nback_response = &quot;correct rejection&quot;&amp;#10;                curr_nback_RT = None&amp;#10;            # they saw a target but there was none: false alarm&amp;#10;            elif saw_target and curr_target == False:&amp;#10;                curr_nback_response = &quot;false alarm&quot;&amp;#10;        # if it wasn't an n-back task block:&amp;#10;        else:&amp;#10;            curr_target = None&amp;#10;            curr_nback_response = None&amp;#10;            curr_nback_RT = None&amp;#10;&amp;#10;        ### save everything in output csv&amp;#10;        thisExp.addData('colour', curr_col)&amp;#10;        thisExp.addData('target', curr_target)&amp;#10;        thisExp.addData('nback_response', curr_nback_response)&amp;#10;        thisExp.addData('nback_RT', curr_nback_RT)  # in ms&amp;#10;        thisExp.addData('duration', curr_duration)  # in ms&amp;#10;        thisExp.addData('trial_nr', curr_trial_nr)&amp;#10;        thisExp.addData('block_nr', exp_block_counter)&amp;#10;        thisExp.addData('block_name', curr_block)&amp;#10;        thisExp.addData('block_kind', curr_nback_cond)&amp;#10;&amp;#10;        # start a new row in the csv&amp;#10;        thisExp.nextEntry()&amp;#10;&amp;#10;        ### IF TESTING MODE ENABLED: end loop after 4 trials&amp;#10;        if expInfo['testing_mode'] == &quot;yes&quot;:&amp;#10;            if trial_idx == 3:&amp;#10;                break&amp;#10;&amp;#10;    print(&quot;\t\tfinished presenting trials&quot;)&amp;#10;&amp;#10;    # change background colour from grey (RGB: 10, 10, 10)&amp;#10;    # to ivory (RGB: 240, 223, 204)&amp;#10;    win.setColor(light_bg_col, colorSpace='rgb')&amp;#10;    win.flip()&amp;#10;&amp;#10;    # add 1 to the block counter to go load the next block&amp;#10;    exp_block_counter = exp_block_counter + 1&amp;#10;    print(f&quot;\tGoing to block {exp_block_counter + 1}/20 now!&quot;)&amp;#10;&amp;#10;    # go to next routine&amp;#10;    # print(&quot;going to next routine&quot;)&amp;#10;    continueRoutine = False" valType="extendedCode" updates="constant" name="Begin Routine"/>
        <Param val="Py" valType="str" updates="None" name="Code Type"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="Each JS Frame"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Experiment"/>
        <Param val="" valType="extendedCode" updates="constant" name="End JS Routine"/>
        <Param val="" valType="extendedCode" updates="constant" name="End Routine"/>
        <Param val="False" valType="bool" updates="None" name="disabled"/>
        <Param val="no_text_no_click" valType="code" updates="None" name="name"/>
      </CodeComponent>
    </Routine>
  </Routines>
  <Flow>
    <Routine name="Settings"/>
    <Routine name="demographics"/>
    <Routine name="education"/>
    <Routine name="welcome_Ishihara"/>
    <LoopInitiator loopType="TrialHandler" name="ishihara_pics">
      <Param name="Selected rows" updates="None" val="" valType="str"/>
      <Param name="conditions" updates="None" val="[OrderedDict([('DisplayImage', 'Stimuli_and_Resources/Ishihara_Colour_Vision_Test/ishihara_test1_70.png'), ('corrAns', 70)]), OrderedDict([('DisplayImage', 'Stimuli_and_Resources/Ishihara_Colour_Vision_Test/ishihara_test2_17.png'), ('corrAns', 17)]), OrderedDict([('DisplayImage', 'Stimuli_and_Resources/Ishihara_Colour_Vision_Test/ishihara_test3_21.png'), ('corrAns', 78)]), OrderedDict([('DisplayImage', 'Stimuli_and_Resources/Ishihara_Colour_Vision_Test/ishihara_test4_78.png'), ('corrAns', 78)]), OrderedDict([('DisplayImage', 'Stimuli_and_Resources/Ishihara_Colour_Vision_Test/ishihara_test5_23.png'), ('corrAns', 23)]), OrderedDict([('DisplayImage', 'Stimuli_and_Resources/Ishihara_Colour_Vision_Test/ishihara_test6_15.png'), ('corrAns', 15)])]" valType="str"/>
      <Param name="conditionsFile" updates="None" val="ishihara_loop.csv" valType="file"/>
      <Param name="endPoints" updates="None" val="[0, 1]" valType="num"/>
      <Param name="isTrials" updates="None" val="True" valType="bool"/>
      <Param name="loopType" updates="None" val="random" valType="str"/>
      <Param name="nReps" updates="None" val="1" valType="num"/>
      <Param name="name" updates="None" val="ishihara_pics" valType="code"/>
      <Param name="random seed" updates="None" val="" valType="code"/>
    </LoopInitiator>
    <Routine name="Ishihara"/>
    <Routine name="feedback"/>
    <LoopTerminator name="ishihara_pics"/>
    <LoopInitiator loopType="TrialHandler" name="blocks">
      <Param name="Selected rows" updates="None" val="" valType="str"/>
      <Param name="conditions" updates="None" val="None" valType="str"/>
      <Param name="conditionsFile" updates="None" val="" valType="file"/>
      <Param name="endPoints" updates="None" val="[0, 1]" valType="num"/>
      <Param name="isTrials" updates="None" val="True" valType="bool"/>
      <Param name="loopType" updates="None" val="sequential" valType="str"/>
      <Param name="nReps" updates="None" val="30" valType="num"/>
      <Param name="name" updates="None" val="blocks" valType="code"/>
      <Param name="random seed" updates="None" val="" valType="code"/>
    </LoopInitiator>
    <Routine name="no_text_blocks_self_paced"/>
    <Routine name="text_blocks_self_paced"/>
    <Routine name="text_blocks_paced"/>
    <Routine name="no_text_blocks_paced"/>
    <Routine name="pseudotext"/>
    <LoopTerminator name="blocks"/>
    <Routine name="end"/>
  </Flow>
</PsychoPy2experiment>
